# Comparing `tmp/interop-1.2.3-cp39-cp39-win_amd64.whl.zip` & `tmp/interop-1.2.4-cp38-cp38-manylinux1_x86_64.whl.zip`

## zipinfo {}

```diff
@@ -1,24 +1,24 @@
-Zip file size: 2506079 bytes, number of entries: 22
--rw-rw-rw-  2.0 fat    19143 b- defN 23-Apr-03 17:18 interop/CoreTests.py
--rw-rw-rw-  2.0 fat      478 b- defN 23-Apr-03 17:08 interop/__init__.py
--rw-rw-rw-  2.0 fat      972 b- defN 23-Apr-03 17:08 interop/__main__.py
--rw-rw-rw-  2.0 fat   763904 b- defN 23-Apr-03 17:12 interop/_py_interop_comm.pyd
--rw-rw-rw-  2.0 fat  2766848 b- defN 23-Apr-03 17:12 interop/_py_interop_metrics.pyd
--rw-rw-rw-  2.0 fat  1166336 b- defN 23-Apr-03 17:12 interop/_py_interop_plot.pyd
--rw-rw-rw-  2.0 fat   905216 b- defN 23-Apr-03 17:13 interop/_py_interop_run.pyd
--rw-rw-rw-  2.0 fat  1104896 b- defN 23-Apr-03 17:13 interop/_py_interop_run_metrics.pyd
--rw-rw-rw-  2.0 fat  1325056 b- defN 23-Apr-03 17:13 interop/_py_interop_summary.pyd
--rw-rw-rw-  2.0 fat   766464 b- defN 23-Apr-03 17:12 interop/_py_interop_table.pyd
--rw-rw-rw-  2.0 fat    58679 b- defN 23-Apr-03 17:18 interop/core.py
--rw-rw-rw-  2.0 fat     9962 b- defN 23-Apr-03 17:11 interop/py_interop_comm.py
--rw-rw-rw-  2.0 fat   167308 b- defN 23-Apr-03 17:11 interop/py_interop_metrics.py
--rw-rw-rw-  2.0 fat    37219 b- defN 23-Apr-03 17:11 interop/py_interop_plot.py
--rw-rw-rw-  2.0 fat    52881 b- defN 23-Apr-03 17:11 interop/py_interop_run.py
--rw-rw-rw-  2.0 fat    16541 b- defN 23-Apr-03 17:11 interop/py_interop_run_metrics.py
--rw-rw-rw-  2.0 fat    39099 b- defN 23-Apr-03 17:11 interop/py_interop_summary.py
--rw-rw-rw-  2.0 fat    18513 b- defN 23-Apr-03 17:11 interop/py_interop_table.py
--rw-rw-rw-  2.0 fat     1144 b- defN 23-Apr-03 17:18 interop-1.2.3.dist-info/METADATA
--rw-rw-rw-  2.0 fat      100 b- defN 23-Apr-03 17:18 interop-1.2.3.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        8 b- defN 23-Apr-03 17:18 interop-1.2.3.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     1826 b- defN 23-Apr-03 17:18 interop-1.2.3.dist-info/RECORD
-22 files, 9222593 bytes uncompressed, 2503175 bytes compressed:  72.9%
+Zip file size: 4190704 bytes, number of entries: 22
+-rw-rw-r--  2.0 unx     1845 b- defN 23-May-13 18:54 interop-1.2.4.dist-info/RECORD
+-rw-r--r--  2.0 unx      108 b- defN 23-May-13 18:54 interop-1.2.4.dist-info/WHEEL
+-rw-r--r--  2.0 unx        8 b- defN 23-May-13 18:54 interop-1.2.4.dist-info/top_level.txt
+-rw-r--r--  2.0 unx     1325 b- defN 23-May-13 18:54 interop-1.2.4.dist-info/METADATA
+-rw-r--r--  2.0 unx   169192 b- defN 23-May-13 18:50 interop/py_interop_metrics.py
+-rwxr-xr-x  2.0 unx  2420287 b- defN 23-May-13 18:52 interop/_py_interop_run_metrics.so
+-rw-r--r--  2.0 unx      948 b- defN 23-May-13 18:50 interop/__main__.py
+-rwxr-xr-x  2.0 unx  1951290 b- defN 23-May-13 18:53 interop/_py_interop_table.so
+-rwxr-xr-x  2.0 unx  1232854 b- defN 23-May-13 18:54 interop/_py_interop_run.so
+-rw-r--r--  2.0 unx    36306 b- defN 23-May-13 18:50 interop/py_interop_plot.py
+-rw-r--r--  2.0 unx    38189 b- defN 23-May-13 18:50 interop/py_interop_summary.py
+-rwxr-xr-x  2.0 unx  3359680 b- defN 23-May-13 18:54 interop/_py_interop_metrics.so
+-rw-r--r--  2.0 unx      466 b- defN 23-May-13 18:50 interop/__init__.py
+-rwxr-xr-x  2.0 unx  2436226 b- defN 23-May-13 18:53 interop/_py_interop_plot.so
+-rwxr-xr-x  2.0 unx  1730046 b- defN 23-May-13 18:54 interop/_py_interop_comm.so
+-rw-r--r--  2.0 unx    18312 b- defN 23-May-13 18:50 interop/py_interop_table.py
+-rw-r--r--  2.0 unx    51513 b- defN 23-May-13 18:50 interop/py_interop_run.py
+-rw-r--r--  2.0 unx    18708 b- defN 23-May-13 18:54 interop/CoreTests.py
+-rw-r--r--  2.0 unx    10230 b- defN 23-May-13 18:50 interop/py_interop_comm.py
+-rw-r--r--  2.0 unx    57504 b- defN 23-May-13 18:54 interop/core.py
+-rw-r--r--  2.0 unx    16224 b- defN 23-May-13 18:50 interop/py_interop_run_metrics.py
+-rwxr-xr-x  2.0 unx  2598658 b- defN 23-May-13 18:52 interop/_py_interop_summary.so
+22 files, 16149919 bytes uncompressed, 4187814 bytes compressed:  74.1%
```

## zipnote {}

```diff
@@ -1,67 +1,67 @@
-Filename: interop/CoreTests.py
+Filename: interop-1.2.4.dist-info/RECORD
 Comment: 
 
-Filename: interop/__init__.py
+Filename: interop-1.2.4.dist-info/WHEEL
 Comment: 
 
-Filename: interop/__main__.py
+Filename: interop-1.2.4.dist-info/top_level.txt
 Comment: 
 
-Filename: interop/_py_interop_comm.pyd
+Filename: interop-1.2.4.dist-info/METADATA
 Comment: 
 
-Filename: interop/_py_interop_metrics.pyd
+Filename: interop/py_interop_metrics.py
 Comment: 
 
-Filename: interop/_py_interop_plot.pyd
+Filename: interop/_py_interop_run_metrics.so
 Comment: 
 
-Filename: interop/_py_interop_run.pyd
+Filename: interop/__main__.py
 Comment: 
 
-Filename: interop/_py_interop_run_metrics.pyd
+Filename: interop/_py_interop_table.so
 Comment: 
 
-Filename: interop/_py_interop_summary.pyd
+Filename: interop/_py_interop_run.so
 Comment: 
 
-Filename: interop/_py_interop_table.pyd
+Filename: interop/py_interop_plot.py
 Comment: 
 
-Filename: interop/core.py
+Filename: interop/py_interop_summary.py
 Comment: 
 
-Filename: interop/py_interop_comm.py
+Filename: interop/_py_interop_metrics.so
 Comment: 
 
-Filename: interop/py_interop_metrics.py
+Filename: interop/__init__.py
 Comment: 
 
-Filename: interop/py_interop_plot.py
+Filename: interop/_py_interop_plot.so
 Comment: 
 
-Filename: interop/py_interop_run.py
+Filename: interop/_py_interop_comm.so
 Comment: 
 
-Filename: interop/py_interop_run_metrics.py
+Filename: interop/py_interop_table.py
 Comment: 
 
-Filename: interop/py_interop_summary.py
+Filename: interop/py_interop_run.py
 Comment: 
 
-Filename: interop/py_interop_table.py
+Filename: interop/CoreTests.py
 Comment: 
 
-Filename: interop-1.2.3.dist-info/METADATA
+Filename: interop/py_interop_comm.py
 Comment: 
 
-Filename: interop-1.2.3.dist-info/WHEEL
+Filename: interop/core.py
 Comment: 
 
-Filename: interop-1.2.3.dist-info/top_level.txt
+Filename: interop/py_interop_run_metrics.py
 Comment: 
 
-Filename: interop-1.2.3.dist-info/RECORD
+Filename: interop/_py_interop_summary.so
 Comment: 
 
 Zip file comment:
```

## interop/CoreTests.py

 * *Ordering differences only*

```diff
@@ -1,435 +1,435 @@
-"""
-Unit tests for core functionality for the SWIG binding
-"""
-import unittest
-import numpy
-import os
-
-try:
-    from interop import py_interop_run
-except:
-    import sys
-    sys.path.append(".")
-    from interop import py_interop_run
-
-from interop import py_interop_metrics
-from interop import py_interop_plot
-from interop import py_interop_comm
-from interop import py_interop_table
-from interop import py_interop_run_metrics
-
-class CoreTests(unittest.TestCase):
-    """ Unit tests for the core functionality in the binding
-    """
-
-    def test_invalid_read_exception(self):
-        """
-        Test that exceptions can be caught and they have the expected message
-        """
-
-        run_info = py_interop_run.info()
-        try:
-            run_info.read(8)
-            self.fail("invalid_read_exception should have been thrown")
-        except py_interop_run.invalid_read_exception as ex:
-            self.assertEqual(str(ex).split('\n')[0], "Read number not found: 8")
-
-    def test_invalid_tile_naming_method(self):
-        """
-        Test that exceptions can be caught and they have the expected message
-        """
-
-        run_info = py_interop_run.info()
-        try:
-            run_info.validate()
-            self.fail("invalid_tile_naming_method should have been thrown")
-        except py_interop_run.invalid_tile_naming_method as ex:
-            self.assertEqual(str(ex).split('\n')[0], "Unknown tile naming method")
-
-    def test_invalid_run_info_exception(self):
-        """
-        Test that exceptions can be caught and they have the expected message
-        """
-
-        run_info = py_interop_run.info()
-        try:
-            run_info.validate(20, 9999, "Test")
-            self.fail("invalid_run_info_exception should have been thrown")
-        except py_interop_run.invalid_run_info_exception as ex:
-            self.assertEqual(str(ex).split('\n')[0], "Lane identifier exceeds number of lanes in RunInfo.xml for record 20_9999 in file Test - 20 > 1")
-
-    def test_invalid_run_info_cycle_exception(self):
-        """
-        Test that exceptions can be caught and they have the expected message
-        """
-
-        run_info = py_interop_run.info(py_interop_run.flowcell_layout(8, 2, 4, 99))
-        try:
-            run_info.validate_cycle(1, 1101, 3000, "Test")
-            self.fail("invalid_run_info_cycle_exception should have been thrown")
-        except py_interop_run.invalid_run_info_cycle_exception as ex:
-            self.assertEqual(str(ex).split('\n')[0], "Cycle number exceeds number of cycles in RunInfo.xml for record 1_1101 @ 3000 in file Test - 3000 > 0")
-
-    def test_xml_file_not_found_exception(self):
-        """
-        Test that exceptions can be caught and they have the expected message
-        """
-
-        run_info = py_interop_run.info()
-        try:
-            run_info.read("file/not/found")
-            self.fail("xml_file_not_found_exception should have been thrown")
-        except py_interop_run.xml_file_not_found_exception as ex:
-            self.assertEqual(str(ex).split('\n')[0], "cannot open file " + os.path.join("file/not/found", "RunInfo.xml"))
-
-    def test_xml_parse_exception(self):
-        """
-        Test that exceptions can be caught and they have the expected message
-        """
-
-        run_info = py_interop_run.info()
-        try:
-            run_info.parse("<RunInfo></RunInfo")
-            self.fail("xml_parse_exception should have been thrown")
-        except py_interop_run.xml_parse_exception as ex:
-            self.assertEqual(str(ex).split('\n')[0], "expected >")
-
-    def test_empty_xml_format_exception(self):
-        """
-        Test that exceptions can be caught and they have the expected message
-        """
-
-        run_info = py_interop_run.info()
-        try:
-            run_info.parse("")
-            self.fail("empty_xml_format_exception should have been thrown")
-        except py_interop_run.empty_xml_format_exception as ex:
-            self.assertEqual(str(ex).split('\n')[0], "Root node not found")
-
-    def test_missing_xml_element_exception(self):
-        """
-        """
-
-        run_info = py_interop_run.info()
-        try:
-            run_info.parse("<RunInfo><Run><FlowcellLayout> <TileSet> </TileSet></FlowcellLayout></Run></RunInfo>")
-            self.fail("missing_xml_element_exception should have been thrown")
-        except py_interop_run.missing_xml_element_exception as ex:
-            self.assertEqual(str(ex).split('\n')[0], "Cannot find attribute: TileNamingConvention")
-
-    def test_bad_xml_format_exception(self):
-        """
-        Test that exceptions can be caught and they have the expected message
-        """
-
-        run_info = py_interop_run.info()
-        try:
-            run_info.parse("<RunInfo></RunInfo>")
-            self.fail("bad_xml_format_exception should have been thrown")
-        except py_interop_run.bad_xml_format_exception as ex:
-            self.assertEqual(str(ex).split('\n')[0], "Run node not found")
-
-    def test_index_out_of_bounds_exception(self):
-        """
-        Test that exceptions can be caught and they have the expected message
-        TODO: flush this out for the entire model
-        """
-
-        expected_metrics = py_interop_metrics.base_error_metrics(3)
-        try:
-            expected_metrics.at(1)
-            self.fail("index_out_of_bounds_exception should have been thrown")
-        except py_interop_metrics.index_out_of_bounds_exception as ex:
-            self.assertEqual(str(ex).split('\n')[0], "Index out of bounds - 1 >= 0")
-
-    def test_bad_format_exception(self):
-        """
-        Test that exceptions can be caught and they have the expected message
-        """
-
-        tmp = numpy.asarray(
-            [0,3
-            ,7,0,90,4,1,0,-12,-56,15,64,-98,35,12,64,0,0,0,0,0,0,0,0,46,1,17,1,0,0,0,0,96,-41,-104,36,122,-86,-46,-120
-            ,7,0,-66,4,1,0,96,-43,14,64,-63,49,13,64,0,0,0,0,0,0,0,0,56,1,17,1,0,0,0,0,112,125,77,38,122,-86,-46,-120
-            ,7,0,66,8,1,0,74,-68,6,64,-118,-7,8,64,0,0,0,0,0,0,0,0,93,1,46,1,0,0,0,0,-47,-104,2,40,122,-86,-46,-120],
-            dtype=numpy.uint8)
-        run = py_interop_run_metrics.run_metrics()
-        try:
-            py_interop_comm.read_interop_from_buffer(tmp, run.extraction_metric_set())
-            self.fail("bad_format_exception should have been thrown")
-        except py_interop_comm.bad_format_exception as ex:
-            self.assertEqual(str(ex).split('\n')[0], "No format found to parse ExtractionMetricsOut.bin with version: 0 of 2")
-
-    def test_incomplete_file_exception(self):
-        """
-        Test that exceptions can be caught and they have the expected message
-        """
-
-        tmp = numpy.asarray(
-            [3,38
-                ,7,0,90,4,1,0,-12,-56,15,64,-98,35,12,64,0,0,0,0,0,0,0,0,46,1,17,1,0,0,0,0,96,-41,-104,36,122,-86,-46,-120
-                ,7,0,-66,4,1,0,96,-43,14,64,-63,49,13,64,0,0,0,0,0,0,0,0,56,1,17,1,0,0,0,0,112,125,77,38,122,-86,-46,-120
-                ,7,0,66,8,1,0,74,-68,6,64,-118,-7,8,64,0,0,0,0,0,0,0,0,93,1,46,1,0,0,0,0,-47,-104,2,40,122,-86,-46,-120],
-            dtype=numpy.uint8)
-        run = py_interop_run_metrics.run_metrics()
-        try:
-            py_interop_comm.read_interop_from_buffer(tmp, run.extraction_metric_set())
-            self.fail("incomplete_file_exception should have been thrown")
-        except py_interop_comm.incomplete_file_exception as ex:
-            self.assertEqual(str(ex).split('\n')[0], "Insufficient data read from the file, got: 13 != expected: 50 for Extraction  v3")
-
-    def test_invalid_argument(self):
-        """
-        Test that exceptions can be caught and they have the expected message
-        """
-
-        tmp = numpy.asarray(
-            [2,38
-                ,7,0,90,4,1,0,-12,-56,15,64,-98,35,12,64,0,0,0,0,0,0,0,0,46,1,17,1,0,0,0,0,96,-41,-104,36,122,-86,-46,-120
-                ,7,0,-66,4,1,0,96,-43,14,64,-63,49,13,64,0,0,0,0,0,0,0,0,56,1,17,1,0,0,0,0,112,125,77,38,122,-86,-46,-120
-                ,7,0,66,8,1,0,74,-68,6,64,-118,-7,8,64,0,0,0,0,0,0,0,0,93,1,46,1,0,0,0,0,-47,-104,2,40,122,-86,-46,-120],
-                dtype=numpy.uint8)
-        run = py_interop_run_metrics.run_metrics()
-        py_interop_comm.read_interop_from_buffer(tmp, run.extraction_metric_set())
-        try:
-            buf = numpy.zeros(3, dtype=numpy.uint8)
-            py_interop_comm.write_interop_to_buffer(run.extraction_metric_set(), buf)
-            self.fail("invalid_argument should have been thrown")
-        except py_interop_comm.invalid_argument as ex:
-            self.assertEqual(str(ex).split('\n')[0], "Buffer size too small: 3 < 116")
-
-    def test_invalid_argument_run_metrics_read(self):
-        """
-        Test that exceptions can be caught and they have the expected message
-        """
-
-        tmp = numpy.asarray(
-            [2,38
-                ,7,0,90,4,1,0,-12,-56,15,64,-98,35,12,64,0,0,0,0,0,0,0,0,46,1,17,1,0,0,0,0,96,-41,-104,36,122,-86,-46,-120
-                ,7,0,-66,4,1,0,96,-43,14,64,-63,49,13,64,0,0,0,0,0,0,0,0,56,1,17,1,0,0,0,0,112,125,77,38,122,-86,-46,-120
-                ,7,0,66,8,1,0,74,-68,6,64,-118,-7,8,64,0,0,0,0,0,0,0,0,93,1,46,1,0,0,0,0,-47,-104,2,40,122,-86,-46,-120],
-            dtype=numpy.uint8)
-        run = py_interop_run_metrics.run_metrics()
-        run.read_metrics_from_buffer(py_interop_run.Extraction, tmp)
-        try:
-            buf = numpy.zeros(3, dtype=numpy.uint8)
-            py_interop_comm.write_interop_to_buffer(run.extraction_metric_set(), buf)
-            self.fail("invalid_argument should have been thrown")
-        except py_interop_comm.invalid_argument as ex:
-            self.assertEqual(str(ex).split('\n')[0], "Buffer size too small: 3 < 116")
-
-    def test_invalid_filter_option(self):
-        """
-        Test that exceptions can be caught and they have the expected message
-        """
-
-        run_info = py_interop_run.info()
-        options = py_interop_plot.filter_options(py_interop_run.FourDigit)
-        try:
-            options.validate(py_interop_run.Intensity, run_info)
-            self.fail("invalid_filter_option should have been thrown")
-        except py_interop_plot.invalid_filter_option as ex:
-            self.assertEqual(str(ex).split('\n')[0], "Invalid tile naming method: does not match RunInfo.xml: FourDigit != UnknownTileNamingMethod")
-
-    def test_invalid_column_type(self):
-        """
-        Test that exceptions can be caught and they have the expected message
-        """
-
-        channels = py_interop_run.string_vector()
-        filled = py_interop_run.bool_vector()
-        columns = py_interop_table.imaging_column_vector()
-        try:
-            py_interop_table.create_imaging_table_columns(channels, filled, columns)
-            self.fail("invalid_column_type should have been thrown")
-        except py_interop_table.invalid_column_type as ex:
-            self.assertEqual(str(ex).split('\n')[0], "Filled vector does not match number of column names")
-
-    def test_invalid_parameter(self):
-        """
-        Test that exceptions can be caught and they have the expected message
-        """
-
-        valid_to_load = py_interop_run.uchar_vector(2)
-        run_metrics = py_interop_run_metrics.run_metrics()
-        try:
-            run_metrics.read_metrics("", 3, valid_to_load, 1)
-            self.fail("invalid_parameter should have been thrown")
-        except py_interop_run_metrics.invalid_parameter as ex:
-            self.assertEqual(str(ex).split('\n')[0], "Boolean array valid_to_load does not match expected number of metrics: 2 != 13")
-
-    def test_invalid_metric_type(self):
-        """
-        Test that exceptions can be caught and they have the expected message
-        """
-
-        valid_to_load = py_interop_run.uchar_vector()
-        try:
-            py_interop_run_metrics.list_metrics_to_load("Unknown", valid_to_load)
-            self.fail("invalid_metric_type should have been thrown")
-        except py_interop_run_metrics.invalid_metric_type as ex:
-            self.assertEqual(str(ex).split('\n')[0], "Unsupported metric type: Unknown")
-
-    def test_invalid_channel_exception(self):
-        """
-        Test that exceptions can be caught and they have the expected message
-        """
-
-        run_metrics = py_interop_run_metrics.run_metrics()
-        try:
-            run_metrics.finalize_after_load();
-            self.fail("invalid_channel_exception should have been thrown")
-        except py_interop_run_metrics.invalid_channel_exception as ex:
-            self.assertEqual(str(ex).split('\n')[0], "Channel names are missing from the RunInfo.xml, and RunParameters.xml does not contain sufficient information on the instrument run.")
-
-    def test_exception_base(self):
-        """
-        Test that exceptions can be caught and they have the expected message
-        """
-
-        expected_metrics = py_interop_metrics.base_error_metrics(3)
-        try:
-            expected_metrics.at(1)
-            self.fail("index_out_of_bounds_exception should have been thrown")
-        except Exception as ex:
-            self.assertEqual(str(ex).split('\n')[0], "Index out of bounds - 1 >= 0")
-
-    def test_run_metrics_typedef_wrapping(self):
-        """
-        Test that the metric typedefs in run_metrics are properly wrapped
-        """
-
-        run_metrics = py_interop_run_metrics.run_metrics()
-        metric_set_getters = [method for method in dir(run_metrics) if method.endswith('metric_set') and not method.startswith('set_')]
-        for getter in metric_set_getters:
-            metric_set = getattr(run_metrics, getter)()
-            self.assertTrue(hasattr(metric_set, 'size'))
-            self.assertEqual(metric_set.size(),0)
-
-    def test_plot_flowcell_map(self):
-        """
-        Test that plot_flowcell_map is properly wrapped
-        """
-
-        run = py_interop_run_metrics.run_metrics()
-        options = py_interop_plot.filter_options(run.run_info().flowcell().naming_method())
-        bufferSize = py_interop_plot.calculate_flowcell_buffer_size(run, options)
-        dataBuffer = numpy.zeros(bufferSize, dtype=numpy.float32)
-        idBuffer = numpy.zeros(bufferSize, dtype=numpy.uint32)
-        data = py_interop_plot.flowcell_data()
-        try:
-            py_interop_plot.plot_flowcell_map2(run, py_interop_run.Intensity, options, data, dataBuffer, idBuffer)
-        except py_interop_plot.invalid_filter_option:
-            pass
-
-    def test_plot_qscore_heatmap(self):
-        """
-        Test that plot_flowcell_map is properly wrapped
-        """
-
-        run = py_interop_run_metrics.run_metrics()
-        options = py_interop_plot.filter_options(run.run_info().flowcell().naming_method())
-        rows = py_interop_plot.count_rows_for_heatmap(run)
-        cols = py_interop_plot.count_columns_for_heatmap(run)
-        dataBuffer = numpy.zeros((rows, cols), dtype=numpy.float32)
-        data = py_interop_plot.heatmap_data()
-        try:
-            py_interop_plot.plot_qscore_heatmap(run, options, data, dataBuffer.ravel())
-        except py_interop_plot.invalid_filter_option: pass
-
-    def test_list_by_cycle_metrics(self):
-        """
-        Test if list_by_cycle_metrics matches expected type
-        """
-
-        typeList = py_interop_metrics.metric_type_description_vector()
-        py_interop_plot.list_by_cycle_metrics(typeList, False)
-        self.assertEqual(typeList[0].value(), py_interop_run.Intensity)
-
-    def test_populate_imaging_table(self):
-        """
-        Test if imaging logic can be properly used
-        """
-
-        tmp = numpy.asarray([2,38
-            ,7,0,90,4,1,0,-12,-56,15,64,-98,35,12,64,0,0,0,0,0,0,0,0,46,1,17,1,0,0,0,0,96,-41,-104,36,122,-86,-46,-120
-            ,7,0,-66,4,1,0,96,-43,14,64,-63,49,13,64,0,0,0,0,0,0,0,0,56,1,17,1,0,0,0,0,112,125,77,38,122,-86,-46,-120
-            ,7,0,66,8,1,0,74,-68,6,64,-118,-7,8,64,0,0,0,0,0,0,0,0,93,1,46,1,0,0,0,0,-47,-104,2,40,122,-86,-46,-120],
-                            dtype=numpy.uint8)
-        run = py_interop_run_metrics.run_metrics()
-        py_interop_comm.read_interop_from_buffer(tmp, run.extraction_metric_set())
-        self.assertEqual(run.extraction_metric_set().size(), 3)
-
-        reads = py_interop_run.read_info_vector()
-        reads.append(py_interop_run.read_info(1, 1, 26))
-        reads.append(py_interop_run.read_info(2, 27, 76))
-        run.run_info(py_interop_run.info(
-            py_interop_run.flowcell_layout(2, 2, 2, 16),
-            reads
-        ))
-        run.legacy_channel_update(py_interop_run.HiSeq)
-        columns = py_interop_table.imaging_column_vector()
-        py_interop_table.create_imaging_table_columns(run, columns)
-        row_offsets = py_interop_table.map_id_offset()
-        py_interop_table.count_table_rows(run, row_offsets)
-        column_count = py_interop_table.count_table_columns(columns)
-        data = numpy.zeros((len(row_offsets), column_count), dtype=numpy.float32)
-        py_interop_table.populate_imaging_table_data(run, columns, row_offsets, data.ravel())
-        self.assertEqual(data[0, 0], 7)
-
-    def test_count_imaging_table_columns(self):
-        """
-        Test if imaging logic is properly wrapped
-        """
-
-        columns = py_interop_table.imaging_column_vector()
-        self.assertEqual(py_interop_table.count_table_columns(columns), 0)
-
-    def test_to_metric_feature(self):
-        """
-        Test if imaging logic is properly wrapped
-        """
-
-        metric_type = py_interop_run.Intensity
-        self.assertEqual(py_interop_run_metrics.to_feature(metric_type), 18)
-
-    def test_run_metrics_member(self):
-        """
-        Test if the run metrics object is properly wrapped
-        """
-
-        run_metrics = py_interop_run_metrics.run_metrics()
-        self.assertEqual(run_metrics.extraction_metric_set().size(), 0)
-
-    def test_parse_metric_type(self):
-        """
-        Test if the enum parsing is properly wrapped
-        """
-
-        self.assertEqual(py_interop_run.parse_metric_type("Intensity"), py_interop_run.Intensity)
-
-    def test_to_string_metric_type(self):
-        """
-        Test if the enum to_string is properly wrapped
-        """
-
-        self.assertEqual(py_interop_run.to_string_metric_type(py_interop_run.Intensity), "Intensity")
-
-    def test_to_string_metric_group(self):
-        """
-        Test if the enum to_string is properly wrapped
-        """
-
-        self.assertEqual(py_interop_run.to_string_metric_group(py_interop_run.Error), "Error")
-
-    def test_summary_run_metric_set_method(self):
-        """
-        Test if the enum parsing is properly wrapped
-        """
-
-        run = py_interop_run_metrics.run_metrics()
-        summary_run_metric_set = run.summary_run_metric_set()
-
-
-if __name__ == '__main__':
-    unittest.main()
+"""
+Unit tests for core functionality for the SWIG binding
+"""
+import unittest
+import numpy
+import os
+
+try:
+    from interop import py_interop_run
+except:
+    import sys
+    sys.path.append(".")
+    from interop import py_interop_run
+
+from interop import py_interop_metrics
+from interop import py_interop_plot
+from interop import py_interop_comm
+from interop import py_interop_table
+from interop import py_interop_run_metrics
+
+class CoreTests(unittest.TestCase):
+    """ Unit tests for the core functionality in the binding
+    """
+
+    def test_invalid_read_exception(self):
+        """
+        Test that exceptions can be caught and they have the expected message
+        """
+
+        run_info = py_interop_run.info()
+        try:
+            run_info.read(8)
+            self.fail("invalid_read_exception should have been thrown")
+        except py_interop_run.invalid_read_exception as ex:
+            self.assertEqual(str(ex).split('\n')[0], "Read number not found: 8")
+
+    def test_invalid_tile_naming_method(self):
+        """
+        Test that exceptions can be caught and they have the expected message
+        """
+
+        run_info = py_interop_run.info()
+        try:
+            run_info.validate()
+            self.fail("invalid_tile_naming_method should have been thrown")
+        except py_interop_run.invalid_tile_naming_method as ex:
+            self.assertEqual(str(ex).split('\n')[0], "Unknown tile naming method")
+
+    def test_invalid_run_info_exception(self):
+        """
+        Test that exceptions can be caught and they have the expected message
+        """
+
+        run_info = py_interop_run.info()
+        try:
+            run_info.validate(20, 9999, "Test")
+            self.fail("invalid_run_info_exception should have been thrown")
+        except py_interop_run.invalid_run_info_exception as ex:
+            self.assertEqual(str(ex).split('\n')[0], "Lane identifier exceeds number of lanes in RunInfo.xml for record 20_9999 in file Test - 20 > 1")
+
+    def test_invalid_run_info_cycle_exception(self):
+        """
+        Test that exceptions can be caught and they have the expected message
+        """
+
+        run_info = py_interop_run.info(py_interop_run.flowcell_layout(8, 2, 4, 99))
+        try:
+            run_info.validate_cycle(1, 1101, 3000, "Test")
+            self.fail("invalid_run_info_cycle_exception should have been thrown")
+        except py_interop_run.invalid_run_info_cycle_exception as ex:
+            self.assertEqual(str(ex).split('\n')[0], "Cycle number exceeds number of cycles in RunInfo.xml for record 1_1101 @ 3000 in file Test - 3000 > 0")
+
+    def test_xml_file_not_found_exception(self):
+        """
+        Test that exceptions can be caught and they have the expected message
+        """
+
+        run_info = py_interop_run.info()
+        try:
+            run_info.read("file/not/found")
+            self.fail("xml_file_not_found_exception should have been thrown")
+        except py_interop_run.xml_file_not_found_exception as ex:
+            self.assertEqual(str(ex).split('\n')[0], "cannot open file " + os.path.join("file/not/found", "RunInfo.xml"))
+
+    def test_xml_parse_exception(self):
+        """
+        Test that exceptions can be caught and they have the expected message
+        """
+
+        run_info = py_interop_run.info()
+        try:
+            run_info.parse("<RunInfo></RunInfo")
+            self.fail("xml_parse_exception should have been thrown")
+        except py_interop_run.xml_parse_exception as ex:
+            self.assertEqual(str(ex).split('\n')[0], "expected >")
+
+    def test_empty_xml_format_exception(self):
+        """
+        Test that exceptions can be caught and they have the expected message
+        """
+
+        run_info = py_interop_run.info()
+        try:
+            run_info.parse("")
+            self.fail("empty_xml_format_exception should have been thrown")
+        except py_interop_run.empty_xml_format_exception as ex:
+            self.assertEqual(str(ex).split('\n')[0], "Root node not found")
+
+    def test_missing_xml_element_exception(self):
+        """
+        """
+
+        run_info = py_interop_run.info()
+        try:
+            run_info.parse("<RunInfo><Run><FlowcellLayout> <TileSet> </TileSet></FlowcellLayout></Run></RunInfo>")
+            self.fail("missing_xml_element_exception should have been thrown")
+        except py_interop_run.missing_xml_element_exception as ex:
+            self.assertEqual(str(ex).split('\n')[0], "Cannot find attribute: TileNamingConvention")
+
+    def test_bad_xml_format_exception(self):
+        """
+        Test that exceptions can be caught and they have the expected message
+        """
+
+        run_info = py_interop_run.info()
+        try:
+            run_info.parse("<RunInfo></RunInfo>")
+            self.fail("bad_xml_format_exception should have been thrown")
+        except py_interop_run.bad_xml_format_exception as ex:
+            self.assertEqual(str(ex).split('\n')[0], "Run node not found")
+
+    def test_index_out_of_bounds_exception(self):
+        """
+        Test that exceptions can be caught and they have the expected message
+        TODO: flush this out for the entire model
+        """
+
+        expected_metrics = py_interop_metrics.base_error_metrics(3)
+        try:
+            expected_metrics.at(1)
+            self.fail("index_out_of_bounds_exception should have been thrown")
+        except py_interop_metrics.index_out_of_bounds_exception as ex:
+            self.assertEqual(str(ex).split('\n')[0], "Index out of bounds - 1 >= 0")
+
+    def test_bad_format_exception(self):
+        """
+        Test that exceptions can be caught and they have the expected message
+        """
+
+        tmp = numpy.asarray(
+            [0,3
+            ,7,0,90,4,1,0,-12,-56,15,64,-98,35,12,64,0,0,0,0,0,0,0,0,46,1,17,1,0,0,0,0,96,-41,-104,36,122,-86,-46,-120
+            ,7,0,-66,4,1,0,96,-43,14,64,-63,49,13,64,0,0,0,0,0,0,0,0,56,1,17,1,0,0,0,0,112,125,77,38,122,-86,-46,-120
+            ,7,0,66,8,1,0,74,-68,6,64,-118,-7,8,64,0,0,0,0,0,0,0,0,93,1,46,1,0,0,0,0,-47,-104,2,40,122,-86,-46,-120],
+            dtype=numpy.uint8)
+        run = py_interop_run_metrics.run_metrics()
+        try:
+            py_interop_comm.read_interop_from_buffer(tmp, run.extraction_metric_set())
+            self.fail("bad_format_exception should have been thrown")
+        except py_interop_comm.bad_format_exception as ex:
+            self.assertEqual(str(ex).split('\n')[0], "No format found to parse ExtractionMetricsOut.bin with version: 0 of 2")
+
+    def test_incomplete_file_exception(self):
+        """
+        Test that exceptions can be caught and they have the expected message
+        """
+
+        tmp = numpy.asarray(
+            [3,38
+                ,7,0,90,4,1,0,-12,-56,15,64,-98,35,12,64,0,0,0,0,0,0,0,0,46,1,17,1,0,0,0,0,96,-41,-104,36,122,-86,-46,-120
+                ,7,0,-66,4,1,0,96,-43,14,64,-63,49,13,64,0,0,0,0,0,0,0,0,56,1,17,1,0,0,0,0,112,125,77,38,122,-86,-46,-120
+                ,7,0,66,8,1,0,74,-68,6,64,-118,-7,8,64,0,0,0,0,0,0,0,0,93,1,46,1,0,0,0,0,-47,-104,2,40,122,-86,-46,-120],
+            dtype=numpy.uint8)
+        run = py_interop_run_metrics.run_metrics()
+        try:
+            py_interop_comm.read_interop_from_buffer(tmp, run.extraction_metric_set())
+            self.fail("incomplete_file_exception should have been thrown")
+        except py_interop_comm.incomplete_file_exception as ex:
+            self.assertEqual(str(ex).split('\n')[0], "Insufficient data read from the file, got: 13 != expected: 50 for Extraction  v3")
+
+    def test_invalid_argument(self):
+        """
+        Test that exceptions can be caught and they have the expected message
+        """
+
+        tmp = numpy.asarray(
+            [2,38
+                ,7,0,90,4,1,0,-12,-56,15,64,-98,35,12,64,0,0,0,0,0,0,0,0,46,1,17,1,0,0,0,0,96,-41,-104,36,122,-86,-46,-120
+                ,7,0,-66,4,1,0,96,-43,14,64,-63,49,13,64,0,0,0,0,0,0,0,0,56,1,17,1,0,0,0,0,112,125,77,38,122,-86,-46,-120
+                ,7,0,66,8,1,0,74,-68,6,64,-118,-7,8,64,0,0,0,0,0,0,0,0,93,1,46,1,0,0,0,0,-47,-104,2,40,122,-86,-46,-120],
+                dtype=numpy.uint8)
+        run = py_interop_run_metrics.run_metrics()
+        py_interop_comm.read_interop_from_buffer(tmp, run.extraction_metric_set())
+        try:
+            buf = numpy.zeros(3, dtype=numpy.uint8)
+            py_interop_comm.write_interop_to_buffer(run.extraction_metric_set(), buf)
+            self.fail("invalid_argument should have been thrown")
+        except py_interop_comm.invalid_argument as ex:
+            self.assertEqual(str(ex).split('\n')[0], "Buffer size too small: 3 < 116")
+
+    def test_invalid_argument_run_metrics_read(self):
+        """
+        Test that exceptions can be caught and they have the expected message
+        """
+
+        tmp = numpy.asarray(
+            [2,38
+                ,7,0,90,4,1,0,-12,-56,15,64,-98,35,12,64,0,0,0,0,0,0,0,0,46,1,17,1,0,0,0,0,96,-41,-104,36,122,-86,-46,-120
+                ,7,0,-66,4,1,0,96,-43,14,64,-63,49,13,64,0,0,0,0,0,0,0,0,56,1,17,1,0,0,0,0,112,125,77,38,122,-86,-46,-120
+                ,7,0,66,8,1,0,74,-68,6,64,-118,-7,8,64,0,0,0,0,0,0,0,0,93,1,46,1,0,0,0,0,-47,-104,2,40,122,-86,-46,-120],
+            dtype=numpy.uint8)
+        run = py_interop_run_metrics.run_metrics()
+        run.read_metrics_from_buffer(py_interop_run.Extraction, tmp)
+        try:
+            buf = numpy.zeros(3, dtype=numpy.uint8)
+            py_interop_comm.write_interop_to_buffer(run.extraction_metric_set(), buf)
+            self.fail("invalid_argument should have been thrown")
+        except py_interop_comm.invalid_argument as ex:
+            self.assertEqual(str(ex).split('\n')[0], "Buffer size too small: 3 < 116")
+
+    def test_invalid_filter_option(self):
+        """
+        Test that exceptions can be caught and they have the expected message
+        """
+
+        run_info = py_interop_run.info()
+        options = py_interop_plot.filter_options(py_interop_run.FourDigit)
+        try:
+            options.validate(py_interop_run.Intensity, run_info)
+            self.fail("invalid_filter_option should have been thrown")
+        except py_interop_plot.invalid_filter_option as ex:
+            self.assertEqual(str(ex).split('\n')[0], "Invalid tile naming method: does not match RunInfo.xml: FourDigit != UnknownTileNamingMethod")
+
+    def test_invalid_column_type(self):
+        """
+        Test that exceptions can be caught and they have the expected message
+        """
+
+        channels = py_interop_run.string_vector()
+        filled = py_interop_run.bool_vector()
+        columns = py_interop_table.imaging_column_vector()
+        try:
+            py_interop_table.create_imaging_table_columns(channels, filled, columns)
+            self.fail("invalid_column_type should have been thrown")
+        except py_interop_table.invalid_column_type as ex:
+            self.assertEqual(str(ex).split('\n')[0], "Filled vector does not match number of column names")
+
+    def test_invalid_parameter(self):
+        """
+        Test that exceptions can be caught and they have the expected message
+        """
+
+        valid_to_load = py_interop_run.uchar_vector(2)
+        run_metrics = py_interop_run_metrics.run_metrics()
+        try:
+            run_metrics.read_metrics("", 3, valid_to_load, 1)
+            self.fail("invalid_parameter should have been thrown")
+        except py_interop_run_metrics.invalid_parameter as ex:
+            self.assertEqual(str(ex).split('\n')[0], "Boolean array valid_to_load does not match expected number of metrics: 2 != 13")
+
+    def test_invalid_metric_type(self):
+        """
+        Test that exceptions can be caught and they have the expected message
+        """
+
+        valid_to_load = py_interop_run.uchar_vector()
+        try:
+            py_interop_run_metrics.list_metrics_to_load("Unknown", valid_to_load)
+            self.fail("invalid_metric_type should have been thrown")
+        except py_interop_run_metrics.invalid_metric_type as ex:
+            self.assertEqual(str(ex).split('\n')[0], "Unsupported metric type: Unknown")
+
+    def test_invalid_channel_exception(self):
+        """
+        Test that exceptions can be caught and they have the expected message
+        """
+
+        run_metrics = py_interop_run_metrics.run_metrics()
+        try:
+            run_metrics.finalize_after_load();
+            self.fail("invalid_channel_exception should have been thrown")
+        except py_interop_run_metrics.invalid_channel_exception as ex:
+            self.assertEqual(str(ex).split('\n')[0], "Channel names are missing from the RunInfo.xml, and RunParameters.xml does not contain sufficient information on the instrument run.")
+
+    def test_exception_base(self):
+        """
+        Test that exceptions can be caught and they have the expected message
+        """
+
+        expected_metrics = py_interop_metrics.base_error_metrics(3)
+        try:
+            expected_metrics.at(1)
+            self.fail("index_out_of_bounds_exception should have been thrown")
+        except Exception as ex:
+            self.assertEqual(str(ex).split('\n')[0], "Index out of bounds - 1 >= 0")
+
+    def test_run_metrics_typedef_wrapping(self):
+        """
+        Test that the metric typedefs in run_metrics are properly wrapped
+        """
+
+        run_metrics = py_interop_run_metrics.run_metrics()
+        metric_set_getters = [method for method in dir(run_metrics) if method.endswith('metric_set') and not method.startswith('set_')]
+        for getter in metric_set_getters:
+            metric_set = getattr(run_metrics, getter)()
+            self.assertTrue(hasattr(metric_set, 'size'))
+            self.assertEqual(metric_set.size(),0)
+
+    def test_plot_flowcell_map(self):
+        """
+        Test that plot_flowcell_map is properly wrapped
+        """
+
+        run = py_interop_run_metrics.run_metrics()
+        options = py_interop_plot.filter_options(run.run_info().flowcell().naming_method())
+        bufferSize = py_interop_plot.calculate_flowcell_buffer_size(run, options)
+        dataBuffer = numpy.zeros(bufferSize, dtype=numpy.float32)
+        idBuffer = numpy.zeros(bufferSize, dtype=numpy.uint32)
+        data = py_interop_plot.flowcell_data()
+        try:
+            py_interop_plot.plot_flowcell_map2(run, py_interop_run.Intensity, options, data, dataBuffer, idBuffer)
+        except py_interop_plot.invalid_filter_option:
+            pass
+
+    def test_plot_qscore_heatmap(self):
+        """
+        Test that plot_flowcell_map is properly wrapped
+        """
+
+        run = py_interop_run_metrics.run_metrics()
+        options = py_interop_plot.filter_options(run.run_info().flowcell().naming_method())
+        rows = py_interop_plot.count_rows_for_heatmap(run)
+        cols = py_interop_plot.count_columns_for_heatmap(run)
+        dataBuffer = numpy.zeros((rows, cols), dtype=numpy.float32)
+        data = py_interop_plot.heatmap_data()
+        try:
+            py_interop_plot.plot_qscore_heatmap(run, options, data, dataBuffer.ravel())
+        except py_interop_plot.invalid_filter_option: pass
+
+    def test_list_by_cycle_metrics(self):
+        """
+        Test if list_by_cycle_metrics matches expected type
+        """
+
+        typeList = py_interop_metrics.metric_type_description_vector()
+        py_interop_plot.list_by_cycle_metrics(typeList, False)
+        self.assertEqual(typeList[0].value(), py_interop_run.Intensity)
+
+    def test_populate_imaging_table(self):
+        """
+        Test if imaging logic can be properly used
+        """
+
+        tmp = numpy.asarray([2,38
+            ,7,0,90,4,1,0,-12,-56,15,64,-98,35,12,64,0,0,0,0,0,0,0,0,46,1,17,1,0,0,0,0,96,-41,-104,36,122,-86,-46,-120
+            ,7,0,-66,4,1,0,96,-43,14,64,-63,49,13,64,0,0,0,0,0,0,0,0,56,1,17,1,0,0,0,0,112,125,77,38,122,-86,-46,-120
+            ,7,0,66,8,1,0,74,-68,6,64,-118,-7,8,64,0,0,0,0,0,0,0,0,93,1,46,1,0,0,0,0,-47,-104,2,40,122,-86,-46,-120],
+                            dtype=numpy.uint8)
+        run = py_interop_run_metrics.run_metrics()
+        py_interop_comm.read_interop_from_buffer(tmp, run.extraction_metric_set())
+        self.assertEqual(run.extraction_metric_set().size(), 3)
+
+        reads = py_interop_run.read_info_vector()
+        reads.append(py_interop_run.read_info(1, 1, 26))
+        reads.append(py_interop_run.read_info(2, 27, 76))
+        run.run_info(py_interop_run.info(
+            py_interop_run.flowcell_layout(2, 2, 2, 16),
+            reads
+        ))
+        run.legacy_channel_update(py_interop_run.HiSeq)
+        columns = py_interop_table.imaging_column_vector()
+        py_interop_table.create_imaging_table_columns(run, columns)
+        row_offsets = py_interop_table.map_id_offset()
+        py_interop_table.count_table_rows(run, row_offsets)
+        column_count = py_interop_table.count_table_columns(columns)
+        data = numpy.zeros((len(row_offsets), column_count), dtype=numpy.float32)
+        py_interop_table.populate_imaging_table_data(run, columns, row_offsets, data.ravel())
+        self.assertEqual(data[0, 0], 7)
+
+    def test_count_imaging_table_columns(self):
+        """
+        Test if imaging logic is properly wrapped
+        """
+
+        columns = py_interop_table.imaging_column_vector()
+        self.assertEqual(py_interop_table.count_table_columns(columns), 0)
+
+    def test_to_metric_feature(self):
+        """
+        Test if imaging logic is properly wrapped
+        """
+
+        metric_type = py_interop_run.Intensity
+        self.assertEqual(py_interop_run_metrics.to_feature(metric_type), 18)
+
+    def test_run_metrics_member(self):
+        """
+        Test if the run metrics object is properly wrapped
+        """
+
+        run_metrics = py_interop_run_metrics.run_metrics()
+        self.assertEqual(run_metrics.extraction_metric_set().size(), 0)
+
+    def test_parse_metric_type(self):
+        """
+        Test if the enum parsing is properly wrapped
+        """
+
+        self.assertEqual(py_interop_run.parse_metric_type("Intensity"), py_interop_run.Intensity)
+
+    def test_to_string_metric_type(self):
+        """
+        Test if the enum to_string is properly wrapped
+        """
+
+        self.assertEqual(py_interop_run.to_string_metric_type(py_interop_run.Intensity), "Intensity")
+
+    def test_to_string_metric_group(self):
+        """
+        Test if the enum to_string is properly wrapped
+        """
+
+        self.assertEqual(py_interop_run.to_string_metric_group(py_interop_run.Error), "Error")
+
+    def test_summary_run_metric_set_method(self):
+        """
+        Test if the enum parsing is properly wrapped
+        """
+
+        run = py_interop_run_metrics.run_metrics()
+        summary_run_metric_set = run.summary_run_metric_set()
+
+
+if __name__ == '__main__':
+    unittest.main()
```

## interop/__init__.py

```diff
@@ -1,12 +1,12 @@
-__project__ = "Illumina InterOp"
-__license__ = "GPL"
-__copyright__ = "Copyright (C) 2015-2017, Illumina, inc."
-__description__ = "Set of common routines used for reading and writing Illumina InterOp metric files"
-__url__ = "https://github.com/Illumina/interop"
-__doc_url__ = "http://illumina.github.io/interop/index.html"
-__version__ = "1.2.3"
-__maintainer__ = "Illumina, inc."
-__contact__ = "https://github.com/Illumina/interop/issues"
-
-from interop.core import *
-
+__project__ = "Illumina InterOp"
+__license__ = "GPL"
+__copyright__ = "Copyright (C) 2015-2017, Illumina, inc."
+__description__ = "Set of common routines used for reading and writing Illumina InterOp metric files"
+__url__ = "https://github.com/Illumina/interop"
+__doc_url__ = "http://illumina.github.io/interop/index.html"
+__version__ = "1.2.4"
+__maintainer__ = "Illumina, inc."
+__contact__ = "https://github.com/Illumina/interop/issues"
+
+from interop.core import *
+
```

## interop/__main__.py

 * *Ordering differences only*

```diff
@@ -1,24 +1,24 @@
-import interop
-import interop.core
-import unittest
-import argparse
-from interop import py_interop_run,py_interop_metrics,py_interop_run_metrics,py_interop_comm,py_interop_table,py_interop_plot,py_interop_summary
-from interop.CoreTests import CoreTests
-
-def execute_from_commandline():
-    """ Provide a command line interface to a general test script
-    """
-
-    parser = argparse.ArgumentParser(prog='interop_check', description='Test script for the InterOp Library Python Interface')
-    parser.add_argument('--version', action='version', version=interop.__version__)
-    parser.add_argument('--test', action='store_true', help='Run the unit tests')
-    parser.set_defaults(test=False)
-    param = parser.parse_args()
-    if param.test:
-        testsuite = unittest.makeSuite(CoreTests)
-        unittest.TextTestRunner(verbosity=1).run(testsuite)
-        interop.core._run_doctests()
-
-if __name__ == "__main__":
-    execute_from_commandline();
-
+import interop
+import interop.core
+import unittest
+import argparse
+from interop import py_interop_run,py_interop_metrics,py_interop_run_metrics,py_interop_comm,py_interop_table,py_interop_plot,py_interop_summary
+from interop.CoreTests import CoreTests
+
+def execute_from_commandline():
+    """ Provide a command line interface to a general test script
+    """
+
+    parser = argparse.ArgumentParser(prog='interop_check', description='Test script for the InterOp Library Python Interface')
+    parser.add_argument('--version', action='version', version=interop.__version__)
+    parser.add_argument('--test', action='store_true', help='Run the unit tests')
+    parser.set_defaults(test=False)
+    param = parser.parse_args()
+    if param.test:
+        testsuite = unittest.makeSuite(CoreTests)
+        unittest.TextTestRunner(verbosity=1).run(testsuite)
+        interop.core._run_doctests()
+
+if __name__ == "__main__":
+    execute_from_commandline();
+
```

## interop/core.py

 * *Ordering differences only*

```diff
@@ -1,1175 +1,1175 @@
-"""@package interop         {#interop_core}
-Core routines to simplify using the InterOp Library
-
-InterOp is built around a single data structure alled a `run_metrics` object. This contains the full set of InterOps
-along with the RunInfo.xml and some of the RunParameters.xml.
-
-A run metrics object can be read in as follows:
->>> from interop import read
->>> run_metrics = read("some/path/run_folder_name") # doctest: +SKIP
-
-Core routines take the run_metrics object and convert it into a table represented by a structured NumPy array. This can,
-in turn, be converted to a pandas DataFrame or any other data structure.
-
-The core routines include the following:
-
->>> from interop import index_summary
->>> index_summary(run_metrics_with_indexing)
-array([(1, 0.4556, 1015.5555, 520.6667, 1536.2222, 1800., 2000.)],
-      dtype=[('Lane', '<u2'), ('Mapped Reads Cv', '<f4'), ('Max Mapped Reads', '<f4'), ('Min Mapped Reads', '<f4'), ('Total Fraction Mapped Reads', '<f4'), ('Total Pf Reads', '<f4'), ('Total Reads', '<f4')])
-
->>> from interop import summary
->>> summary(run_metrics_example)
-array([(0.36666667, 6.6666665, 0., 0., 0.)],
-      dtype=[('Error Rate', '<f4'), ('First Cycle Intensity', '<f4'), ('Projected Yield G', '<f4'), ('Reads', '<f4'), ('Reads Pf', '<f4')])
-
->>> from interop import indexing
->>> indexing(run_metrics_with_indexing)
-array([(1., 1101., 'ATCACGAC-AAGGTTCA', '1', 4570., 900., 507.77777),
-       (1., 1101., 'ATCACGAC-GGGGGGGG', '2', 2343., 900., 260.33334),
-       (1., 1102., 'ATCACGAC-AAGGTTCA', '1', 4570.,   0.,   0.     ),
-       (1., 1102., 'ATCACGAC-GGGGGGGG', '2', 2343.,   0.,   0.     )],
-      dtype=[('Lane', '<f4'), ('Tile', '<f4'), ('Barcode', 'O'), ('SampleID', 'O'), ('Cluster Count', '<f4'), ('Cluster Count PF', '<f4'), ('% Demux', '<f4')])
-
->>> from interop import imaging
->>> imaging(run_metrics_example)
-rec.array([(1., 1101., 1., 1., 1., 0.1, 10., 10., 25. , 33.3, 33.3, 33.3, 0., 10., 10., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.),
-           (1., 1101., 2., 1., 2., 0.2,  5., 15., 12.5, 42.9, 28.6, 28.6, 0.,  5., 15., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.),
-           (1., 1101., 3., 1., 3., 0.3, 10., 10., 25. , 33.3, 50. , 16.7, 0., 10., 10., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.),
-           (1., 1101., 4., 2., 1., 0.4, 10.,  5., 25. , 16.7, 50. , 33.3, 0., 10.,  5., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.),
-           (1., 1101., 5., 3., 1., 0.5, 15.,  5., 37.5, 20. , 40. , 40. , 0., 15.,  5., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.)],
-          dtype=[('Lane', '<f4'), ('Tile', '<f4'), ('Cycle', '<f4'), ('Read', '<f4'), ('Cycle Within Read', '<f4'), ('Error Rate', '<f4'), ('P90/green', '<f4'), ('P90/blue', '<f4'), ('% No Calls', '<f4'), ('% Base/A', '<f4'), ('% Base/C', '<f4'), ('% Base/G', '<f4'), ('% Base/T', '<f4'), ('Fwhm/green', '<f4'), ('Fwhm/blue', '<f4'), ('Corrected/A', '<f4'), ('Corrected/C', '<f4'), ('Corrected/G', '<f4'), ('Corrected/T', '<f4'), ('Called/A', '<f4'), ('Called/C', '<f4'), ('Called/G', '<f4'), ('Called/T', '<f4'), ('Signal To Noise', '<f4'), ('Surface', '<f4'), ('Swath', '<f4'), ('Tile Number', '<f4')])
-
-Any of the core routines above can take a `run_metrics` object or a string containing a file path to a valid run folder.
-
->>> ar = index_summary("some/path/run_folder_name") # doctest: +SKIP
-
-The structured NumPy array can be converted to a Pandas DataFrame just so:
-
->>> import pandas as pd # doctest: +SKIP
->>> df = pd.DataFrame(ar) # doctest: +SKIP
-
-For more information see the documentation around each function below.
-"""
-
-import interop.py_interop_run_metrics as interop_metrics
-import interop.py_interop_metrics as interop_metric_sets
-import interop.py_interop_run as interop_run
-import interop.py_interop_table as interop_table
-import interop.py_interop_summary as interop_summary
-import numpy as np
-import os
-
-_summary_levels = ('Total', 'NonIndex', 'Read', 'Lane', 'Surface')
-_index_summary_levels = ('Lane', 'Barcode')
-
-
-def index_summary(run_metrics, level='Lane', columns=None, dtype='f4', **extra):
-    """ Index summary table
-
-    >>> from interop import index_summary
-    >>> ar = index_summary("some/path/run_folder_name") # doctest: +SKIP
-
-    >>> index_summary(run_metrics_with_indexing)
-    array([(1, 0.4556, 1015.5555, 520.6667, 1536.2222, 1800., 2000.)],
-          dtype=[('Lane', '<u2'), ('Mapped Reads Cv', '<f4'), ('Max Mapped Reads', '<f4'), ('Min Mapped Reads', '<f4'), ('Total Fraction Mapped Reads', '<f4'), ('Total Pf Reads', '<f4'), ('Total Reads', '<f4')])
-
-    >>> index_summary(run_metrics_with_indexing, level='Barcode')
-    array([(1, 18280., 1015.5555, 1., 'ATCACGAC', 'AAGGTTCA', 'TSCAIndexes', '1'),
-           (1,  9372.,  520.6667, 2., 'ATCACGAC', 'GGGGGGGG', 'TSCAIndexes', '2')],
-          dtype=[('Lane', '<u2'), ('Cluster Count', '<f4'), ('Fraction Mapped', '<f4'), ('Id', '<f4'), ('Index1', 'O'), ('Index2', 'O'), ('Project Name', 'O'), ('Sample Id', 'O')])
-
-    >>> index_summary(run_metrics_with_indexing, columns=['Total Fraction Mapped Reads'])
-    array([(1, 1536.2222)],
-          dtype=[('Lane', '<u2'), ('Total Fraction Mapped Reads', '<f4')])
-
-    >>> index_summary(run_metrics_with_indexing, columns=['Incorrect'])
-    Traceback (most recent call last):
-    ...
-    ValueError: Column `Incorrect` not found in: ['Mapped Reads Cv', 'Max Mapped Reads', 'Min Mapped Reads', 'Total Fraction Mapped Reads', 'Total Pf Reads', 'Total Reads'] - column not consistent with level or misspelled
-
-    >>> index_summary(run_metrics_with_indexing, level='Incorrect')
-    Traceback (most recent call last):
-    ...
-    ValueError: level=Incorrect not in ('Lane', 'Barcode')
-
-    :param run_metrics: py_interop_run_metrics.run_metrics or string run folder path
-    :param level: level of the data to summarize, valid values include: 'Total', 'NonIndex', 'Read', 'Lane', 'Surface' (Default: Total)
-    :param columns: list of columns (valid values depend on the level) see `summary_columns`
-    :param dtype: data type for the array (Default: 'f4')
-    :param extra: all extra parameters are passed to `read` if the first parameter is a str file path to a run folder
-    :return: structured with column names and dype - np.array
-    """
-
-    if columns is None:
-        columns = index_summary_columns(level)
-    else:
-        if level not in _index_summary_levels:
-            raise ValueError("level={} not in {}".format(str(level), str(_index_summary_levels)))
-
-    extra['valid_to_load'] = create_valid_to_load(('Index', 'Tile', ))
-    run_metrics = read(run_metrics, **extra)
-    if run_metrics.empty():
-        return np.asarray([])
-
-    if not isinstance(run_metrics, interop_metrics.run_metrics):
-        raise ValueError("Expected interop.py_interop_run_metrics.run_metrics or str for `run_metrics`")
-
-    if not isinstance(dtype, str):
-        dtype = np.dtype(dtype).str
-    summary_obj = interop_summary.index_flowcell_summary()
-    interop_summary.summarize_index_metrics(run_metrics, summary_obj)
-
-    if isinstance(columns, str):
-        columns = (columns, )
-    column_map = index_summary_columns(level, ret_dict=True)
-    for col in columns:
-        if col not in column_map:
-            raise ValueError("Column `{}` not found in: {} - column not consistent with level or misspelled".format(
-                col, str(sorted([k for k in column_map.keys()]))))
-
-    def summarize(summary_object, column_list, extra_row=None):
-
-        row_vals = []
-        column_header = []
-        if extra_row is None:
-            extra_row = []
-        for column in column_list:
-            method_name = column_map[column]
-            val = getattr(summary_object, method_name)()
-            column_header.append(column)
-            row_vals.append(val)
-        return tuple(extra_row+row_vals), column_header
-
-    extra_cols = [('Lane', np.uint16)]
-    if level == 'Lane':
-        data = []
-        lane_count = summary_obj.size()
-        column_count = None
-        for lane_index in range(lane_count):
-            lane_summary = summary_obj.at(lane_index)
-            lane_number = lane_index+1
-            row, header = summarize(lane_summary
-                                                 , columns
-                                                 , [lane_number])
-            if column_count is None:
-                column_count = len(row)
-            else:
-                assert column_count == len(row)
-            data.append(row)
-        if len(data) == 0:
-            return np.asarray([])
-        return np.asarray(data, dtype=extra_cols+[(col, dtype) for col in header])
-
-    data = []
-    lane_count = summary_obj.size()
-    column_count = None
-    for lane_index in range(lane_count):
-        lane_summary = summary_obj.at(lane_index)
-        lane_number = lane_index+1
-        sample_count = lane_summary.size()
-        for sample_index in range(sample_count):
-            sample_summary = lane_summary.at(sample_index)
-            row, header = summarize(sample_summary
-                                    , columns
-                                    , [lane_number])
-            if column_count is None:
-                column_count = len(row)
-            else:
-                assert column_count == len(row)
-            data.append(row)
-    if len(data) == 0:
-        return np.asarray([])
-    _str_types = ('Index1', 'Index2', 'Sample Id', 'Project Name')
-    return np.asarray(data, dtype=extra_cols+[(col, dtype if col not in _str_types else np.dtype(object)) for col in header])
-
-
-def index_summary_columns(level='Lane', ret_dict=False):
-    """ List the columns of the `index_summary` table
-
-    >>> from interop import index_summary_columns
-    >>> index_summary_columns()
-    ('Mapped Reads Cv', 'Max Mapped Reads', 'Min Mapped Reads', 'Total Fraction Mapped Reads', 'Total Pf Reads', 'Total Reads')
-
-
-    >>> index_summary_columns('Barcode')
-    ('Cluster Count', 'Fraction Mapped', 'Id', 'Index1', 'Index2', 'Project Name', 'Sample Id')
-
-    :param level: level of the data to summarize, valid values include: 'Lane', 'Barcode' (Default: Lane)
-    :param ret_dict: if true, return a dict mapping from column name to method name (Default: False)
-    :return: tuple of columns (or dictionary mapping column name to method depending on `ret_dict` parameter)
-    """
-
-    if level not in _index_summary_levels:
-        raise ValueError("level={} not in {}".format(str(level), str(_index_summary_levels)))
-    summary_obj = interop_summary.index_lane_summary() if level == 'Lane' else interop_summary.index_count_summary()
-    exclude_attrs = ('thisown', 'this', '_s', 'at', 'size', 'resize', 'lane', 'surface', 'cycle_state', 'clear', 'reserve', 'sort', 'push_back', 'set', 'add', 'update_fraction_mapped')
-    methods = tuple([v for v in dir(summary_obj) if not v.startswith('__') and v not in exclude_attrs])
-
-    def to_column_name(method):
-        return " ".join([v.capitalize().replace("Percent", "%") .replace("Gt", ">=") for v in method.split('_')])
-
-    if ret_dict:
-        return dict([(to_column_name(v), v) for v in methods])
-    return tuple([to_column_name(c) for c in methods])
-
-
-def summary(run_metrics, level='Total', columns=None, dtype='f4', ignore_missing_columns=True, **extra):
-    """ Generate a summary table with the given level, columns and dtype from a run_metrics object or run_folder path
-
-    Note that not all columns will be included if InterOp files are missing or purposing excluded using `valid_to_load`.
-
-    The following examples show the different levels that one can summarize the data including:
-
-     - Total (Default)
-     - NonIndex
-     - Read
-     - Lane
-     - Summary
-
-    >>> from interop import summary
-    >>> ar = summary("some/path/run_folder_name") # doctest: +SKIP
-    >>> ar = summary("some/path/run_folder_name", valid_to_load=['Error']) # doctest: +SKIP
-
-
-    >>> summary(run_metrics_example)
-    array([(0.36666667, 6.6666665, 0., 0., 0.)],
-          dtype=[('Error Rate', '<f4'), ('First Cycle Intensity', '<f4'), ('Projected Yield G', '<f4'), ('Reads', '<f4'), ('Reads Pf', '<f4')])
-
-    >>> summary(run_metrics_example, 'Total')
-    array([(0.36666667, 6.6666665, 0., 0., 0.)],
-          dtype=[('Error Rate', '<f4'), ('First Cycle Intensity', '<f4'), ('Projected Yield G', '<f4'), ('Reads', '<f4'), ('Reads Pf', '<f4')])
-
-    >>> summary(run_metrics_example, 'NonIndex')
-    array([(0.2, 10., 0., 0., 0.)],
-          dtype=[('Error Rate', '<f4'), ('First Cycle Intensity', '<f4'), ('Projected Yield G', '<f4'), ('Reads', '<f4'), ('Reads Pf', '<f4')])
-
-    >>> summary(run_metrics_example, 'Read')
-    array([(1, 78, 0.2, 10., 0., 0., 0.), (2, 89, 0.4,  5., 0., 0., 0.),
-           (3, 89, 0.5,  5., 0., 0., 0.)],
-          dtype=[('ReadNumber', '<u2'), ('IsIndex', 'u1'), ('Error Rate', '<f4'), ('First Cycle Intensity', '<f4'), ('Projected Yield G', '<f4'), ('Reads', '<f4'), ('Reads Pf', '<f4')])
-
-    >>> summary(run_metrics_example, 'Lane')
-    array([(1, 78, 1, 0.2, 10., 0., 0., 0., 1.),
-           (2, 89, 1, 0.4,  5., 0., 0., 0., 1.),
-           (3, 89, 1, 0.5,  5., 0., 0., 0., 1.)],
-          dtype=[('ReadNumber', '<u2'), ('IsIndex', 'u1'), ('Lane', '<u2'), ('Error Rate', '<f4'), ('First Cycle Intensity', '<f4'), ('Projected Yield G', '<f4'), ('Reads', '<f4'), ('Reads Pf', '<f4'), ('Tile Count', '<f4')])
-
-    For a single surface, as is this example, nothing is reported.
-    >>> summary(run_metrics_example, 'Surface')
-    array([], dtype=float64)
-
-    We can select specific columns using the `columns` parameter
-    >>> summary(run_metrics_example, 'Total', columns=['First Cycle Intensity', 'Error Rate'])
-    array([(6.6666665, 0.36666667)],
-          dtype=[('First Cycle Intensity', '<f4'), ('Error Rate', '<f4')])
-
-    If a column values are NaN, or missing, then it will automatically be excluded
-    >>> summary(run_metrics_example, 'Total', columns=['% Aligned', 'Error Rate'])
-    array([(0.36666667,)], dtype=[('Error Rate', '<f4')])
-
-    To include missing columns, set `ignore_missing_columns=False`
-    >>> summary(run_metrics_example, 'Total', ignore_missing_columns=False, columns=['% Aligned', 'Error Rate'])
-    array([(nan, 0.36666667)],
-          dtype=[('% Aligned', '<f4'), ('Error Rate', '<f4')])
-
-    >>> summary(run_metrics_example, 'Total', columns=['Incorrect'])
-    Traceback (most recent call last):
-     ...
-    ValueError: Column `Incorrect` not found in: ['Error Rate', 'First Cycle Intensity', '% Aligned', '% >= Q30', '% Occupancy Proxy', '% Occupied', 'Projected Yield G', 'Yield G'] - column not consistent with level or misspelled
-
-
-    :param run_metrics: py_interop_run_metrics.run_metrics or string run folder path
-    :param level: level of the data to summarize, valid values include: 'Total', 'NonIndex', 'Read', 'Lane', 'Surface' (Default: Total)
-    :param columns: list of columns (valid values depend on the level) see `summary_columns`
-    :param dtype: data type for the array (Default: 'f4')
-    :param ignore_missing_columns: ignore missing columns, e.g. those with NaN values (Default: True)
-    :param extra: all extra parameters are passed to `read` if the first parameter is a str file path to a run folder
-    :return: structured with column names and dype - np.array
-    """
-
-    if columns is None:
-        columns = summary_columns(level)
-    else:
-        if level not in _summary_levels:
-            raise ValueError("level={} not in {}".format(str(level), str(_summary_levels)))
-
-    if isinstance(run_metrics, str):
-        if extra.get('valid_to_load', None) is None:
-            extra['valid_to_load'] = load_summary_metrics()
-    run_metrics = read(run_metrics, **extra)
-    if run_metrics.empty():
-        return np.asarray([])
-
-    if not isinstance(run_metrics, interop_metrics.run_metrics):
-        raise ValueError("Expected interop.py_interop_run_metrics.run_metrics or str for `run_metrics`")
-
-    run_summary = interop_summary.run_summary()
-    interop_summary.summarize_run_metrics(run_metrics, run_summary, False, False)
-
-    if isinstance(columns, str):
-        columns = (columns, )
-    column_map = summary_columns(level, ret_dict=True)
-    for col in columns:
-        if col not in column_map:
-            raise ValueError("Column `{}` not found in: {} - column not consistent with level or misspelled".format(
-                col, str(sorted([k for k in column_map.keys()]))))
-    if not isinstance(dtype, str):
-        dtype = np.dtype(dtype).str
-
-    def summarize(summary_object, column_list, extra_row=None, ignore_missing=ignore_missing_columns):
-        row_vals = []
-        column_header = []
-        column_subset = []
-        if extra_row is None:
-            extra_row = []
-        for column in column_list:
-            method_name, subcols = column_map[column]
-            if callable(subcols):
-                subcols = subcols(run_metrics.run_info())
-            val = getattr(summary_object, method_name)()
-            if hasattr(val, 'mean'):
-                val = val.mean()
-            if ignore_missing and not np.any(np.isfinite(val)):
-                continue
-            if len(subcols) > 1:
-                assert len(val) == len(subcols)
-                column_header.extend(subcols)
-                row_vals.extend(val)
-            else:
-                column_header.append(column)
-                row_vals.append(val)
-            column_subset.append(column)
-        return tuple(extra_row+row_vals), column_header, column_subset
-
-    if level in ('Total', 'NonIndex'):
-        summary_obj = run_summary.total_summary() if level == 'Total' else run_summary.nonindex_summary()
-        row, header, _ = summarize(summary_obj, columns)
-        header = [(col, dtype) for col in header]
-        return np.asarray([row], dtype=header)
-
-    extra_cols = [('ReadNumber', np.uint16), ('IsIndex', np.uint8)]
-    if level == 'Read':
-        data = []
-        read_count = run_summary.size()
-        column_count = None
-        for read_index in range(read_count):
-            read_summary = run_summary.at(read_index)
-            read_info = read_summary.read()
-            read_number = read_info.number()
-            is_index = read_info.is_index()
-            read_summary = read_summary.summary()
-            row, header, columns_sel = summarize(read_summary
-                                     , columns
-                                     , [read_number, int(ord('Y' if is_index else 'N'))]
-                                     , ignore_missing_columns and column_count is None)
-            if column_count is None:
-                column_count = len(row)
-                columns = columns_sel
-            data.append(row)
-        return np.asarray(data, dtype=extra_cols+[(col, dtype) for col in header])
-
-    extra_cols += [('Lane', np.uint16)]
-    if level == 'Lane':
-        data = []
-        read_count = run_summary.size()
-        column_count = None
-        for read_index in range(read_count):
-            read_summary = run_summary.at(read_index)
-            read_info = read_summary.read()
-            read_number = read_info.number()
-            is_index = read_info.is_index()
-            for lane_index in range(read_summary.size()):
-                lane_summary = read_summary.at(lane_index)
-                lane_number = lane_summary.lane()
-                row, header, columns_sel = summarize(lane_summary
-                                         , columns
-                                         , [read_number, int(ord('Y' if is_index else 'N')), lane_number]
-                                         , ignore_missing_columns and column_count is None)
-                if column_count is None:
-                    column_count = len(row)
-                    columns = columns_sel
-                data.append(row)
-        return np.asarray(data, dtype=extra_cols+[(col, dtype) for col in header])
-
-    data = []
-    read_count = run_summary.size()
-    column_count = None
-    extra_cols += [('Surface', np.uint16)]
-    for read_index in range(read_count):
-        read_summary = run_summary.at(read_index)
-        read_info = read_summary.read()
-        read_number = read_info.number()
-        is_index = read_info.is_index()
-        for lane_index in range(read_summary.size()):
-            lane_summary = read_summary.at(lane_index)
-            lane_number = lane_summary.lane()
-            for surface_index in range(lane_summary.size()):
-                surface_summary = lane_summary.at(surface_index)
-                surface_number = surface_summary.surface()
-                row, header, columns_sel = summarize(surface_summary
-                                         , columns
-                                         , [read_number, int(ord('Y' if is_index else 'N')), lane_number, surface_number]
-                                         , ignore_missing_columns and column_count is None)
-                if column_count is None:
-                    column_count = len(row)
-                    columns = columns_sel
-                data.append(row)
-    if len(data) == 0:
-        return np.asarray([])
-    return np.asarray(data, dtype=extra_cols+[(col, dtype) for col in header])
-
-
-def load_summary_metrics():
-    """ List of valid summary metrics to load
-
-    >>> from interop import load_to_string_list
-    >>> from interop import load_summary_metrics
-    >>> load_to_string_list(load_summary_metrics())
-    ['CorrectedInt', 'Error', 'Extraction', 'Q', 'Tile', 'QByLane', 'QCollapsed', 'EmpiricalPhasing', 'ExtendedTile']
-
-    :return: valid_to_load
-    """
-
-    valid_to_load = interop_run.uchar_vector(interop_run.MetricCount, 0)
-    interop_metrics.list_summary_metrics_to_load(valid_to_load, interop_run.NovaSeq)
-    return valid_to_load
-
-
-def summary_columns(level='Total', ret_dict=False):
-    """ Get a list of column names supported at each level of the summary table
-
-    >>> from interop import summary_columns
-
-    The default columns are for the Run/Read level
-    >>> summary_columns()
-    ('Cluster Count', 'Cluster Count Pf', 'Error Rate', 'First Cycle Intensity', '% Aligned', '% >= Q30', '% Occupancy Proxy', '% Occupied', 'Projected Yield G', 'Reads', 'Reads Pf', 'Yield G')
-    >>> summary_columns(level='Total')
-    ('Cluster Count', 'Cluster Count Pf', 'Error Rate', 'First Cycle Intensity', '% Aligned', '% >= Q30', '% Occupancy Proxy', '% Occupied', 'Projected Yield G', 'Reads', 'Reads Pf', 'Yield G')
-    >>> summary_columns(level='NonIndex')
-    ('Cluster Count', 'Cluster Count Pf', 'Error Rate', 'First Cycle Intensity', '% Aligned', '% >= Q30', '% Occupancy Proxy', '% Occupied', 'Projected Yield G', 'Reads', 'Reads Pf', 'Yield G')
-    >>> summary_columns(level='Read')
-    ('Cluster Count', 'Cluster Count Pf', 'Error Rate', 'First Cycle Intensity', '% Aligned', '% >= Q30', '% Occupancy Proxy', '% Occupied', 'Projected Yield G', 'Reads', 'Reads Pf', 'Yield G')
-
-    The lane/surface level give another set of columns for the summary table
-    >>> summary_columns(level='Lane')
-    ('Cluster Count', 'Cluster Count Pf', 'Density', 'Density Pf', 'Error Rate', 'Error Rate 100', 'Error Rate 35', 'Error Rate 50', 'Error Rate 75', 'First Cycle Intensity', '% Aligned', '% >= Q30', '% Occupied', '% Pf', 'Phasing', 'Phasing Offset', 'Phasing Slope', 'Prephasing', 'Prephasing Offset', 'Prephasing Slope', 'Projected Yield G', 'Reads', 'Reads Pf', 'Tile Count', 'Yield G')
-    >>> summary_columns(level='Surface')
-    ('Cluster Count', 'Cluster Count Pf', 'Density', 'Density Pf', 'Error Rate', 'Error Rate 100', 'Error Rate 35', 'Error Rate 50', 'Error Rate 75', 'First Cycle Intensity', '% Aligned', '% >= Q30', '% Occupied', '% Pf', 'Phasing', 'Phasing Offset', 'Phasing Slope', 'Prephasing', 'Prephasing Offset', 'Prephasing Slope', 'Projected Yield G', 'Reads', 'Reads Pf', 'Tile Count', 'Yield G')
-
-    :param level: level of the data to summarize, valid values include: 'Run', 'Read', 'Lane', 'Surface' (Default: Run)
-    :param ret_dict: if true, return a dict mapping from column name to method name (Default: False)
-    :return: tuple of columns - each column is a tuple, or a tuple of lambda functions that take the run_info as an argument
-    """
-
-    if level not in _summary_levels:
-        raise ValueError("level={} not in {}".format(str(level), str(_summary_levels)))
-    if level == 'Lane' or level == 'Surface':
-        summary_obj = interop_summary.lane_summary()
-    else:
-        summary_obj = interop_summary.read_summary().summary()
-    exclude_attrs = ('thisown', 'this', '_s', 'at', 'size', 'resize', 'resize_stat', 'lane', 'surface', 'cycle_state')
-    methods = tuple([v for v in dir(summary_obj) if not v.startswith('__') and v not in exclude_attrs])
-
-    def to_column_name(method):
-        return " ".join([v.capitalize().replace("Percent", "%") .replace("Gt", ">=") for v in method.split('_')])
-
-    def sub_cols(method):
-
-        column_name = to_column_name(method)
-        if method == 'percent_base':
-            base_map = {interop_run.A: 'A', interop_run.C: 'C', interop_run.G: 'G', interop_run.T: 'T'}
-            return tuple([column_name+" "+base_map[i] for i in range(4)])
-        if method == 'fwhm':
-            def fwhm_columns(run_info):
-                return tuple([column_name+" "+channel for channel in run_info.channels()])
-            fwhm_columns.__name__ = 'fwhm_columns'
-            return fwhm_columns
-        if method == 'resynthesis':
-            def resynthesis_columns(run_info):
-                return tuple([column_name+" "+channel for channel in run_info.channels()])
-            resynthesis_columns.__name__ = 'resynthesis_columns'
-            return resynthesis_columns
-        return tuple()
-
-    if ret_dict:
-        return dict([(to_column_name(v), (v, sub_cols(v))) for v in methods])
-    return tuple([to_column_name(c) for c in methods])
-
-
-def indexing(run_metrics, per_sample=True, dtype='f4', stype='O', **extra):
-    """ Convert InterOp run_metrics (or read run_metrics from disk) to a numpy structured array containing an
-    indexing table
-
-    We can read an indexing table directly from a run folder. Note, this does not load all metrics, only those required
-    by the indexing table, e.g. IndexMetricsOut.bin
-
-    >>> from interop import indexing
-    >>> ar = indexing("some/path/run_folder_name") # doctest: +SKIP
-
-    Note that `valid_to_load` in `read` is ignored.
-
-
-    We can also convert a `run_metrics` object to an indexing table as follows
-    >>> ar = indexing(run_metrics_with_indexing)
-    >>> ar
-    array([(1., 1101., 'ATCACGAC-AAGGTTCA', '1', 4570., 900., 507.77777),
-           (1., 1101., 'ATCACGAC-GGGGGGGG', '2', 2343., 900., 260.33334),
-           (1., 1102., 'ATCACGAC-AAGGTTCA', '1', 4570.,   0.,   0.     ),
-           (1., 1102., 'ATCACGAC-GGGGGGGG', '2', 2343.,   0.,   0.     )],
-          dtype=[('Lane', '<f4'), ('Tile', '<f4'), ('Barcode', 'O'), ('SampleID', 'O'), ('Cluster Count', '<f4'), ('Cluster Count PF', '<f4'), ('% Demux', '<f4')])
-
-    The `indexing` function also provides an overall sample view by setting `per_sample=False`.
-
-    >>> ar = indexing(run_metrics_with_indexing, per_sample=False)
-    >>> ar
-    array([(1., 1101., 1000., 900., 768.11115),
-           (1., 1102.,    0.,   0.,   0.     )],
-          dtype=[('Lane', '<f4'), ('Tile', '<f4'), ('Cluster Count', '<f4'), ('Cluster Count PF', '<f4'), ('% Demux', '<f4')])
-
-    :param run_metrics: py_interop_run_metrics.run_metrics or string run folder path
-    :param per_sample: return demux per sample (Default: True)
-    :param dtype: data type for the array (Default: 'f4')
-    :param stype: string type for the array (Default: 'O')
-    :param extra: all extra parameters are passed to `read` if the first parameter is a str file path to a run folder
-    :return: structured with column names and dype - np.array
-    """
-
-    extra['valid_to_load'] = create_valid_to_load(('Index', 'Tile'))
-    run_metrics = read(run_metrics, **extra)
-    if not isinstance(run_metrics, interop_metrics.run_metrics):
-        raise ValueError("Expected interop.py_interop_run_metrics.run_metrics or str for `run_metrics`")
-
-    if run_metrics.empty():
-        return np.asarray([])
-    if not isinstance(dtype, str):
-        dtype = np.dtype(dtype).str
-    if not isinstance(stype, str):
-        stype = np.dtype(stype).str
-
-    index_metric_set = run_metrics.index_metric_set()
-    column_names = [("Lane", dtype), ("Tile", dtype)]
-    if per_sample:
-        column_names += [("Barcode", stype), ("SampleID", stype)]
-    column_names += [("Cluster Count", dtype), ("Cluster Count PF", dtype), ("% Demux", dtype)]
-    sample_count = len(index_metric_set.index_order()) if per_sample else 1
-    if sample_count == 0:
-        raise ValueError("No samples found, was `finalize_after_load` called in run_metrics?")
-    reads_list = run_metrics.run_info().reads()
-    index_read_count = sum([1 for i in range(len(reads_list)) if reads_list[i].is_index()])
-    table = np.zeros(index_metric_set.size()//index_read_count*sample_count, dtype=column_names)
-    select_read = index_metric_set.at(0).read() if index_metric_set.size() > 0 else 1
-    k = 0
-    for i in range(index_metric_set.size()):
-        metric = index_metric_set.at(i)
-        if metric.read() != select_read:
-            continue
-        if per_sample:
-            for index_info in metric.indices():
-                if metric.cluster_count_pf() > 0:
-                    percent_demux = float(index_info.cluster_count()) / np.float32(metric.cluster_count_pf()) * 100.0
-                else:
-                    percent_demux = 0
-                table[k] = (metric.lane()
-                            , metric.tile()
-                            , index_info.index_seq()
-                            , index_info.sample_id()
-                            , index_info.cluster_count()
-                            , metric.cluster_count_pf()
-                            , percent_demux
-                            )
-                k += 1
-        else:
-            percent_demux = metric.percent_demultiplexed("")
-            if not np.isfinite(percent_demux):
-                percent_demux = 0.0
-            table[k] = (metric.lane()
-                        , metric.tile()
-                        , metric.cluster_count()
-                        , metric.cluster_count_pf()
-                        , percent_demux
-                        )
-            k += 1
-    return table
-
-
-def imaging(run_metrics, dtype='f4', **extra):
-    """ Convert InterOp run_metrics (or read run_metrics from disk) to a numpy structured array containing the imaging
-    table
-
-    We can read an imaging table directly from a run folder. Note, this does not load all metrics, only those required
-    by the imaging table. See `load_imaging_metrics` for that list.
-
-    Also note that loading only tile level metrics (e.g. metrics without cycles) will result in an empty table. This is
-    a limitation of the imaging table.
-
-    >>> from interop import imaging
-    >>> from interop import load_imaging_metrics
-    >>> import interop.py_interop_run_metrics as interop_metrics
-    >>> import numpy as np
-    >>> ar = imaging("some/path/run_folder_name") # doctest: +SKIP
-
-    The above function is equivalent to
-    >>> ar = imaging("some/path/run_folder_name", valid_to_load=load_imaging_metrics()) # doctest: +SKIP
-
-    We can select a subset of metrics to include based on metric groups
-    >>> ar = imaging("some/path/run_folder_name", valid_to_load=['Error']) # doctest: +SKIP
-
-    See `read` below for more examples.
-
-    The following example will rely on an existing run_metrics object (possibly created by the `read` function below).
-
-    >>> ar = imaging(run_metrics_example)
-    >>> ar
-    rec.array([(1., 1101., 1., 1., 1., 0.1, 10., 10., 25. , 33.3, 33.3, 33.3, 0., 10., 10., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.),
-               (1., 1101., 2., 1., 2., 0.2,  5., 15., 12.5, 42.9, 28.6, 28.6, 0.,  5., 15., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.),
-               (1., 1101., 3., 1., 3., 0.3, 10., 10., 25. , 33.3, 50. , 16.7, 0., 10., 10., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.),
-               (1., 1101., 4., 2., 1., 0.4, 10.,  5., 25. , 16.7, 50. , 33.3, 0., 10.,  5., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.),
-               (1., 1101., 5., 3., 1., 0.5, 15.,  5., 37.5, 20. , 40. , 40. , 0., 15.,  5., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.)],
-              dtype=[('Lane', '<f4'), ('Tile', '<f4'), ('Cycle', '<f4'), ('Read', '<f4'), ('Cycle Within Read', '<f4'), ('Error Rate', '<f4'), ('P90/green', '<f4'), ('P90/blue', '<f4'), ('% No Calls', '<f4'), ('% Base/A', '<f4'), ('% Base/C', '<f4'), ('% Base/G', '<f4'), ('% Base/T', '<f4'), ('Fwhm/green', '<f4'), ('Fwhm/blue', '<f4'), ('Corrected/A', '<f4'), ('Corrected/C', '<f4'), ('Corrected/G', '<f4'), ('Corrected/T', '<f4'), ('Called/A', '<f4'), ('Called/C', '<f4'), ('Called/G', '<f4'), ('Called/T', '<f4'), ('Signal To Noise', '<f4'), ('Surface', '<f4'), ('Swath', '<f4'), ('Tile Number', '<f4')])
-
-    >>> ar.dtype
-    dtype((numpy.record, [('Lane', '<f4'), ('Tile', '<f4'), ('Cycle', '<f4'), ('Read', '<f4'), ('Cycle Within Read', '<f4'), ('Error Rate', '<f4'), ('P90/green', '<f4'), ('P90/blue', '<f4'), ('% No Calls', '<f4'), ('% Base/A', '<f4'), ('% Base/C', '<f4'), ('% Base/G', '<f4'), ('% Base/T', '<f4'), ('Fwhm/green', '<f4'), ('Fwhm/blue', '<f4'), ('Corrected/A', '<f4'), ('Corrected/C', '<f4'), ('Corrected/G', '<f4'), ('Corrected/T', '<f4'), ('Called/A', '<f4'), ('Called/C', '<f4'), ('Called/G', '<f4'), ('Called/T', '<f4'), ('Signal To Noise', '<f4'), ('Surface', '<f4'), ('Swath', '<f4'), ('Tile Number', '<f4')]))
-
-    We can convert the numpy array to a Pandas DataFrame as follows:
-
-    >>> import pandas as pd  # doctest: +SKIP
-    >>> df = pd.DataFrame(ar)  # doctest: +SKIP
-    >>> df  # doctest: +SKIP
-       Lane  ...  Tile Number
-    0   1.0  ...          1.0
-    1   1.0  ...          1.0
-    2   1.0  ...          1.0
-    3   1.0  ...          1.0
-    4   1.0  ...          1.0
-    <BLANKLINE>
-    [5 rows x 27 columns]
-
-    You can also change the dtype of the resulting data array table.
-    >>> imaging(run_metrics_example, dtype=np.float32)
-    rec.array([(1., 1101., 1., 1., 1., 0.1, 10., 10., 25. , 33.3, 33.3, 33.3, 0., 10., 10., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.),
-               (1., 1101., 2., 1., 2., 0.2,  5., 15., 12.5, 42.9, 28.6, 28.6, 0.,  5., 15., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.),
-               (1., 1101., 3., 1., 3., 0.3, 10., 10., 25. , 33.3, 50. , 16.7, 0., 10., 10., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.),
-               (1., 1101., 4., 2., 1., 0.4, 10.,  5., 25. , 16.7, 50. , 33.3, 0., 10.,  5., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.),
-               (1., 1101., 5., 3., 1., 0.5, 15.,  5., 37.5, 20. , 40. , 40. , 0., 15.,  5., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.)],
-              dtype=[('Lane', '<f4'), ('Tile', '<f4'), ('Cycle', '<f4'), ('Read', '<f4'), ('Cycle Within Read', '<f4'), ('Error Rate', '<f4'), ('P90/green', '<f4'), ('P90/blue', '<f4'), ('% No Calls', '<f4'), ('% Base/A', '<f4'), ('% Base/C', '<f4'), ('% Base/G', '<f4'), ('% Base/T', '<f4'), ('Fwhm/green', '<f4'), ('Fwhm/blue', '<f4'), ('Corrected/A', '<f4'), ('Corrected/C', '<f4'), ('Corrected/G', '<f4'), ('Corrected/T', '<f4'), ('Called/A', '<f4'), ('Called/C', '<f4'), ('Called/G', '<f4'), ('Called/T', '<f4'), ('Signal To Noise', '<f4'), ('Surface', '<f4'), ('Swath', '<f4'), ('Tile Number', '<f4')])
-
-    Here is the output if an empty run_metrics was provided
-    >>> imaging(interop_metrics.run_metrics())
-    array([], dtype=float64)
-
-    Here is an example exception if an improper input is given
-    >>> imaging(None)
-    Traceback (most recent call last):
-    ...
-    ValueError: Expected interop.py_interop_run_metrics.run_metrics or str for `run_metrics`
-
-    :param run_metrics: py_interop_run_metrics.run_metrics or str file path to a run folder
-    :param dtype: data type for the array (Default: 'f4')
-    :param extra: all extra parameters are passed to `read` if the first parameter is a str file path to a run folder
-    :return: structured with column names and dype - np.array
-    """
-
-    if isinstance(run_metrics, str):
-        if extra.get('valid_to_load', None) is None:
-            extra['valid_to_load'] = load_imaging_metrics()
-        run_metrics = read(run_metrics, **extra)
-    if not isinstance(run_metrics, interop_metrics.run_metrics):
-        raise ValueError("Expected interop.py_interop_run_metrics.run_metrics or str for `run_metrics`")
-
-    if run_metrics.empty():
-        return np.asarray([])
-
-    headers, columns = _imaging_columns(run_metrics)
-    row_offsets = interop_table.map_id_offset()
-    interop_table.count_table_rows(run_metrics, row_offsets)
-    column_count = interop_table.count_table_columns(columns)
-    data = np.zeros((len(row_offsets), column_count), dtype=dtype)
-    interop_table.populate_imaging_table_data(run_metrics, columns, row_offsets, data.ravel())
-
-    if not isinstance(dtype, str):
-        dtype = np.dtype(dtype).str
-    return np.core.records.fromarrays(data.transpose()
-                                      , names=",".join(headers)
-                                      , formats=",".join([dtype for _ in headers]))
-
-
-def imaging_columns(run_metrics, **extra):
-    """ Get a list of imaging table columns
-
-    >>> from interop import imaging_columns
-    >>> from interop import load_imaging_metrics
-    >>> import interop.py_interop_run_metrics as interop_metrics
-    >>> import numpy as np
-    >>> ar = imaging_columns("some/path/run_folder_name") # doctest: +SKIP
-
-    The above function is equivalent to
-    >>> ar = imaging_columns("some/path/run_folder_name", valid_to_load=load_imaging_metrics()) # doctest: +SKIP
-
-    We can select a subset of metrics to include based on metric groups
-    >>> ar = imaging_columns("some/path/run_folder_name", valid_to_load=['Error']) # doctest: +SKIP
-
-    See `read` below for more examples.
-
-    The following example will rely on an existing run_metrics object (possibly created by the `read` function below).
-
-    >>> imaging_columns(run_metrics_example)
-    ['Lane', 'Tile', 'Cycle', 'Read', 'Cycle Within Read', 'Error Rate', 'P90/green', 'P90/blue', '% No Calls', '% Base/A', '% Base/C', '% Base/G', '% Base/T', 'Fwhm/green', 'Fwhm/blue', 'Corrected/A', 'Corrected/C', 'Corrected/G', 'Corrected/T', 'Called/A', 'Called/C', 'Called/G', 'Called/T', 'Signal To Noise', 'Surface', 'Swath', 'Tile Number']
-
-    :param run_metrics: py_interop_run_metrics.run_metrics or str file path to a run folder
-    :param extra: all extra parameters are passed to `read` if the first parameter is a str file path to a run folder
-    :return: list of string headers
-    """
-
-    if isinstance(run_metrics, str):
-        if extra.get('valid_to_load', None) is None:
-            extra['valid_to_load'] = load_imaging_metrics()
-        run_metrics = read(run_metrics, **extra)
-    if not isinstance(run_metrics, interop_metrics.run_metrics):
-        raise ValueError("Expected interop.py_interop_run_metrics.run_metrics or str for `run_metrics`")
-
-    return _imaging_columns(run_metrics)[0]
-
-
-def _imaging_columns(run_metrics):
-    """ Internal function for getting the imaging columns
-
-    :param run_metrics: py_interop_run_metrics.run_metrics or str file path to a run folder
-    :return: a tuple including (headers, imaging_column_vector)
-    """
-
-    columns = interop_table.imaging_column_vector()
-    interop_table.create_imaging_table_columns(run_metrics, columns)
-
-    headers = []
-    for i in range(columns.size()):
-        column = columns[i]
-        if column.has_children():
-            headers.extend([str(column.name()) + "/" + str(subname).strip() for subname in column.subcolumns()])
-        else:
-            headers.append(str(column.name()))
-    return headers, columns
-
-
-def read(run, valid_to_load=None, requires=None, search_paths=None, **extra):
-    """ Read InterOp metrics into a run_metrics object
-
-    - List of validate valid_to_load names can be gotten using `list_interop_files`
-    - If run is `interop.py_interop_run_metrics.run_metrics` then run is returned.
-    - If an InterOp file is missing from the `requires` list, then an empty run_metrics object is returned
-
-    Read in all metrics from a run folder
-    >>> from interop import read
-    >>> metrics = read("some/path/run_folder_name") # doctest: +SKIP
-
-    Read in only ErrorMetricsOut.bin in a run folder
-    >>> metrics = read("some/path/run_folder_name", valid_to_load=['Error']) # doctest: +SKIP
-
-    Read in ErrorMetricsOut.bin and ExtractionMetricsOut.bin but if ErrorMetricsOut.bin is missing return an empty
-    >>> metrics = read("some/path/run_folder_name", valid_to_load=['Error', 'Extraction'], requires=['Error']) # doctest: +SKIP
-
-    Read in IndexMetricsOut.bin and search for it outside the run folder in `fastq/reports`
-    >>> metrics = read("some/path/run_folder_name", valid_to_load=['Index'], search_paths=['fastq/reports']) # doctest: +SKIP
-
-    Read in a run folder that is not found
-    >>> metrics = read("some/non/existing/run_folder_name")
-    Traceback (most recent call last):
-    ...
-    interop.py_interop_run.xml_file_not_found_exception: cannot open file some/non/existing/run_folder_name/RunInfo.xml
-
-    Read from a None object
-    >>> metrics = read(None)
-    Traceback (most recent call last):
-    ...
-    ValueError: invalid null reference in method 'run_metrics_read', argument 2 of type 'std::string const &'
-
-    :param run: string path including name of run folder (or run_metrics object)
-    :param valid_to_load: list of strings containing InterOp metric names (Default: None, load everything)
-    :param requires: list of required metric (Default: None, check nothing)
-    :param search_paths: list of paths to search when looking for `IndexMetricsOut.bin` (Default: None, do not search)
-    :return: interop.py_interop_run_metrics.run_metrics
-    """
-
-    if isinstance(run, interop_metrics.run_metrics):
-        return run
-
-    if search_paths is None:
-        search_paths = (os.path.join('Analysis', '1', 'Data', 'Reports'))
-    if isinstance(search_paths, str):
-        search_paths = [search_paths]
-    if valid_to_load is None:
-        valid_to_load = []
-    if requires is None:
-        requires = []
-
-    run_metrics = interop_metrics.run_metrics()
-    valid_to_load = create_valid_to_load(valid_to_load)
-    if valid_to_load is not None:
-        run_metrics.read(run, valid_to_load)
-    else:
-        run_metrics.read(run)
-
-    if (valid_to_load is None or 'Index' in load_to_string_list(valid_to_load)) and run_metrics.index_metric_set().empty():
-        for path in search_paths:
-            filename = os.path.join(run, path, "IndexMetricsOut.bin")
-            if not os.path.exists(filename):
-                continue
-            if run_metrics.run_info().name() == "":
-                run_metrics.read_xml(run)
-            run_metrics = read_metric(filename, run_metrics=run_metrics, finalize=True)
-            break
-    for group in requires:
-        if run_metrics.is_group_empty(group):
-            return interop_metrics.run_metrics()
-
-    return run_metrics
-
-
-def read_metric(filename, run_metrics=None, finalize=False):
-    """ Read a specific metric from a file into a run_metrics object
-
-    This function allows incremental reading of metric files from disk. The last call should set
-    `finalize=True`.
-
-    Read in `ErrorMetricsOut.bin` into a run_metrics object and finalize since this is the only metric we plan to read
-
-    >>> from interop import read_metric
-    >>> metrics = read_metric("some/path/run_folder_name/InterOp/ErrorMetricsOut.bin", finalize=True) # doctest: +SKIP
-
-    :param filename: path to InterOp file
-    :param run_metrics: existing run_metrics object (Default None, one will be created)
-    :param finalize: if true, then call finalize_after_load (last call to `read_metric` should set finalize=True)
-    :return: interop.py_interop_run_metrics.run_metrics
-    """
-
-    if run_metrics is None:
-        run_metrics = interop_metrics.run_metrics()
-    metric_group = group_from_filename(filename)
-    data = np.fromfile(filename, dtype=np.uint8)
-    run_metrics.read_metrics_from_buffer(metric_group, data)
-    if finalize:
-        run_metrics.finalize_after_load()
-    return run_metrics
-
-
-def create_valid_to_load(interop_prefixes):
-    """ Create list of metrics valid to load by the InterOp library
-
-    List of validate metric_names can be gotten using `list_interop_files`
-
-    >>> from interop import create_valid_to_load
-    >>> int(create_valid_to_load(['Extraction'])[0])
-    0
-    >>> create_valid_to_load(0)
-    Traceback (most recent call last):
-        ...
-    TypeError: Parameter valid_to_load must be a collection of values
-
-    :param interop_prefixes: list of strings containing InterOp metric names
-    :return: py_interop_run.uchar_vector
-    """
-
-    if not hasattr(interop_prefixes, '__len__'):
-        raise TypeError("Parameter valid_to_load must be a collection of values")
-
-    if interop_prefixes is None or len(interop_prefixes) == 0:
-        return None
-
-    if isinstance(interop_prefixes, interop_run.uchar_vector):
-        return interop_prefixes
-
-    valid_to_load = interop_run.uchar_vector(interop_run.MetricCount, 0)
-    enable_metrics(valid_to_load, interop_prefixes)
-
-    return valid_to_load
-
-
-def enable_metrics(valid_to_load, interop_prefixes):
-    """ Enable metrics in valid_to_load
-
-    >>> from interop import enable_metrics, load_to_string_list
-    >>> import interop.py_interop_run as interop_run
-    >>> valid_to_load = interop_run.uchar_vector(interop_run.MetricCount, 0)
-    >>> load_to_string_list(enable_metrics(valid_to_load, 'Extraction'))
-    ['Extraction']
-    >>> load_to_string_list(enable_metrics(valid_to_load, ['Error', 'Q']))
-    ['Error', 'Extraction', 'Q']
-
-    Nothing changes when passing in an empty list
-    >>> load_to_string_list(enable_metrics(valid_to_load, []))
-    ['Error', 'Extraction', 'Q']
-
-    Here are some example exceptions when the improper parameter is given
-
-    >>> enable_metrics(valid_to_load, None)
-    Traceback (most recent call last):
-      ...
-    TypeError: 'NoneType' object is not iterable
-    >>> enable_metrics(None, [])
-    Traceback (most recent call last):
-    ...
-    TypeError: Parameter valid_to_load must be of type interop.py_interop_run.uchar_vector
-    >>> enable_metrics("None", [])
-    Traceback (most recent call last):
-    ...
-    TypeError: Parameter valid_to_load must be of type interop.py_interop_run.uchar_vector
-
-
-    :param valid_to_load: interop_run.uchar_vector (boolean array)
-    :param interop_prefixes: list of metrics to enable
-    :return: interop_run.uchar_vector (It is updated in-place so the return can be ignored)
-    """
-    if not isinstance(valid_to_load, interop_run.uchar_vector):
-        raise TypeError("Parameter valid_to_load must be of type interop.py_interop_run.uchar_vector")
-
-    if isinstance(interop_prefixes, str):
-        interop_prefixes = [interop_prefixes]
-
-    for metric_name in interop_prefixes:
-        if interop_run.parse_metric_group(metric_name) >= interop_run.MetricCount:
-            raise ValueError("Cannot parse metric file name: {}".format(metric_name))
-        valid_to_load[interop_run.parse_metric_group(metric_name)] = 1
-    return valid_to_load
-
-
-def load_to_string_list(valid_to_load):
-    """ Create a string list of names for each enabled metric in `valid_to_load`
-
-    >>> from interop import create_valid_to_load, load_to_string_list
-    >>> import interop.py_interop_run as interop_run
-    >>> valid_to_load = create_valid_to_load('Extraction')
-    >>> load_to_string_list(valid_to_load)
-    ['Extraction']
-    >>> valid_to_load = interop_run.uchar_vector(interop_run.MetricCount, 1)
-    >>> load_to_string_list(valid_to_load)
-    ['CorrectedInt', 'Error', 'Extraction', 'Image', 'Index', 'Q', 'Tile', 'QByLane', 'QCollapsed', 'EmpiricalPhasing', 'DynamicPhasing', 'ExtendedTile', 'SummaryRun']
-
-    :param valid_to_load: boolean buffer
-    :return: list of strings containing the name of each metric enabled in `valid_to_load`
-    """
-
-    if not isinstance(valid_to_load, interop_run.uchar_vector):
-        raise TypeError("Parameter valid_to_load must be of type interop.py_interop_run.uchar_vector")
-
-    names = []
-    for i in range(interop_run.MetricCount):
-        if valid_to_load[i] > 0:
-            names.append(interop_run.to_string_metric_group(i))
-    return names
-
-
-def group_from_filename(filename):
-    """ Get the metric group id from an InterOp filename path
-
-    >>> from interop import group_from_filename
-    >>> import interop.py_interop_run as interop_run
-    >>> group_from_filename("some/path/run/InterOp/ExtractionMetricsOut.bin")
-    2
-    >>> interop_run.Extraction
-    2
-
-    This group id can be used to load a metric from a binary buffer as in `interop.core.read_metric`
-
-    :param filename: path to interop metric
-    :return: interop_run.metric_group
-    """
-
-    metric_name = os.path.basename(filename)
-    metric_name, ext = os.path.splitext(metric_name)
-    if ext != '.bin':
-        raise ValueError("InterOp file must have `bin` extension: {}".format(filename))
-    if metric_name.endswith('Out'):
-        metric_name = metric_name[:-3]
-    if metric_name.endswith('Metrics'):
-        metric_name = metric_name[:-7]
-    else:
-        if ext != 'bin':
-            raise ValueError("InterOp file must have `Metrics.bin` or `MetricsOut.bin` suffix: {}".format(filename))
-    group = interop_run.parse_metric_group(metric_name)
-    if group >= interop_run.MetricCount:
-        raise ValueError("Cannot identify InteropMetric from: {}".format(filename))
-    return group
-
-
-def load_imaging_metrics():
-    """ List of valid imaging metrics to load
-
-    >>> from interop import load_to_string_list
-    >>> from interop import load_imaging_metrics
-    >>> load_to_string_list(load_imaging_metrics())
-    ['CorrectedInt', 'Error', 'Extraction', 'Image', 'Q', 'Tile', 'QByLane', 'QCollapsed', 'EmpiricalPhasing', 'DynamicPhasing', 'ExtendedTile']
-
-    :return: valid_to_load
-    """
-
-    valid_to_load = interop_run.uchar_vector(interop_run.MetricCount, 0)
-    interop_table.list_imaging_table_metrics_to_load(valid_to_load)
-    return valid_to_load
-
-########################################################################################################################
-# Functions and other code to support doc tests
-########################################################################################################################
-
-
-def _run_info_example_fixture(tiles=None):
-    """Fixture used for doctests"""
-
-    run_name = "111111_UNKNOWN_1_XXYT"
-    run_info_version = 6
-    run_date, instrument_name, run_number, flowcell_id = run_name.split('_')
-    if tiles is None:
-        tiles = ['1_1101']
-    lane_count = len(set(tile.split('_')[0] for tile in tiles))
-    surface_count = len(set(tile.split('_')[1][0] for tile in tiles))
-    swath_count = len(set(tile.split('_')[1][1] for tile in tiles))
-    tile_count = len(set(tile.split('_')[1][2:] for tile in tiles))
-    sections_per_lane = 1
-    lanes_per_section = 1
-    naming_method = interop_run.FourDigit
-    flowcell_layout = interop_run.flowcell_layout(lane_count
-                                                  , surface_count
-                                                  , swath_count
-                                                  , tile_count
-                                                  , sections_per_lane
-                                                  , lanes_per_section
-                                                  , tiles
-                                                  , naming_method
-                                                  , flowcell_id)
-    channels = ['green', 'blue']
-    width = 7875
-    height = 10500
-    image_dimensions = interop_run.image_dimensions(width, height)
-    reads = interop_run.read_info_vector()
-    is_reverse_complement = False
-    first_cycle = 1
-    for read_num, cycle_count, is_index in [(1, 3, False), (2, 1, True), (3, 1, True)]:
-        last_cycle = first_cycle + cycle_count
-        reads.push_back(interop_run.read_info(read_num, first_cycle, last_cycle, is_index, is_reverse_complement))
-        first_cycle = last_cycle
-    run_info = interop_run.info(run_name
-                                , run_date
-                                , instrument_name
-                                , int(run_number)
-                                , run_info_version
-                                , flowcell_layout
-                                , channels
-                                , image_dimensions
-                                , reads)
-    return run_info
-
-
-def _run_metrics_example_fixture():
-    """Fixture used for doctests"""
-
-    run_info = _run_info_example_fixture()
-    metrics = interop_metrics.run_metrics(run_info)
-    adapter_rate = np.nan
-    tile_num = 1101
-    lane_num = 1
-
-    error_metric_set = metrics.error_metric_set()
-    for cycle, error_rate in enumerate([0.1, 0.2, 0.3, 0.4, 0.5]):
-        error_metric_set.insert(interop_metric_sets.error_metric(lane_num, tile_num, cycle+1, error_rate, adapter_rate))
-
-    corrected_int_metric_set = metrics.corrected_intensity_metric_set()
-    for cycle, call_counts in enumerate([[10, 10, 10, 10, 0], [5, 15, 10, 10, 0], [10, 10, 15, 5, 0], [10, 5, 15, 10, 0], [15, 5, 10, 10, 0]]):
-        call_counts = np.array(call_counts, dtype=np.uint32)
-        corrected_int_metric_set.insert(interop_metric_sets.corrected_intensity_metric(
-            lane_num, tile_num, cycle+1, call_counts, 0, 0))  # Dummy 0s are to work around swig bug
-
-    extraction_metric_set = metrics.extraction_metric_set()
-    for cycle, call_counts in enumerate([[10, 10], [5, 15], [10, 10], [10, 5], [15, 5]]):
-        intensity_array = np.array(call_counts, dtype=np.uint16)
-        focus_array = np.array(call_counts, dtype=np.float32)
-        extraction_metric_set.insert(interop_metric_sets.extraction_metric(
-            lane_num, tile_num, cycle+1, intensity_array, focus_array, 0))
-    return metrics
-
-
-def _index_metrics_example_fixture():
-    """Fixture used for doctests"""
-
-    run_info = _run_info_example_fixture(['1_1101', '1_1102'])
-    metrics = interop_metrics.run_metrics(run_info)
-    index_metric_set = metrics.index_metric_set()
-
-    indices = interop_metric_sets.index_info_vector()
-    for barcode, sample_id, sample_proj, cluster_count in [
-        ("ATCACGAC-AAGGTTCA", "1", "TSCAIndexes", 4570)
-        , ("ATCACGAC-GGGGGGGG", "2", "TSCAIndexes", 2343)
-    ]:
-        indices.push_back(interop_metric_sets.index_info(barcode, sample_id, sample_proj, cluster_count))
-    tile_num = 1101
-    lane_num = 1
-
-    for read_num in [2, 3]:
-        index_metric_set.insert(interop_metric_sets.index_metric(lane_num, tile_num, read_num, indices));
-
-    tile_metric_set = metrics.tile_metric_set()
-    reads = interop_metric_sets.read_metric_vector()
-    cluster_density = 1000
-    cluster_density_pf = 900
-    cluster_count = 1000
-    cluster_count_pf = 900
-    tile_metric_set.insert(interop_metric_sets.tile_metric(lane_num
-                                                           , tile_num
-                                                           , cluster_density
-                                                           , cluster_density_pf
-                                                           , cluster_count
-                                                           , cluster_count_pf
-                                                           , reads))
-
-    tile_num = 1102
-    lane_num = 1
-    cluster_density = 0
-    cluster_density_pf = 0
-    cluster_count = 0
-    cluster_count_pf = 0
-
-    for read_num in [2, 3]:
-        index_metric_set.insert(interop_metric_sets.index_metric(lane_num, tile_num, read_num, indices));
-    tile_metric_set.insert(interop_metric_sets.tile_metric(lane_num
-                                                           , tile_num
-                                                           , cluster_density
-                                                           , cluster_density_pf
-                                                           , cluster_count
-                                                           , cluster_count_pf
-                                                           , reads))
-
-    metrics.finalize_after_load()
-    return metrics
-
-
-# class RunFolderToDiskFixture(object):
-#
-#     def __init__(self):
-#
-#         self.run_folder = os.path.absolue("./210326_")
-#         run = _run_metrics_example_fixture()
-#         run.write
-#
-#     def __del__(self):
-#         if self.run_folder is not None:
-#             import shutil
-#             shutil.deltree(self.run_folder)
-
-
-def _run_doctests():
-
-    import interop.core
-    import doctest
-    import sys
-    failure_count, test_count = doctest.testmod(interop.core
-                                                , optionflags=doctest.IGNORE_EXCEPTION_DETAIL
-                                                , globs=dict(
-        run_metrics_with_indexing=_index_metrics_example_fixture(),
-        run_metrics_example=_run_metrics_example_fixture()
-    ))
-    if failure_count > 0:
-        sys.exit(1)
-
-
-
-if __name__ == "__main__":
-
-    _run_doctests()
+"""@package interop         {#interop_core}
+Core routines to simplify using the InterOp Library
+
+InterOp is built around a single data structure alled a `run_metrics` object. This contains the full set of InterOps
+along with the RunInfo.xml and some of the RunParameters.xml.
+
+A run metrics object can be read in as follows:
+>>> from interop import read
+>>> run_metrics = read("some/path/run_folder_name") # doctest: +SKIP
+
+Core routines take the run_metrics object and convert it into a table represented by a structured NumPy array. This can,
+in turn, be converted to a pandas DataFrame or any other data structure.
+
+The core routines include the following:
+
+>>> from interop import index_summary
+>>> index_summary(run_metrics_with_indexing)
+array([(1, 0.4556, 1015.5555, 520.6667, 1536.2222, 1800., 2000.)],
+      dtype=[('Lane', '<u2'), ('Mapped Reads Cv', '<f4'), ('Max Mapped Reads', '<f4'), ('Min Mapped Reads', '<f4'), ('Total Fraction Mapped Reads', '<f4'), ('Total Pf Reads', '<f4'), ('Total Reads', '<f4')])
+
+>>> from interop import summary
+>>> summary(run_metrics_example)
+array([(0.36666667, 6.6666665, 0., 0., 0.)],
+      dtype=[('Error Rate', '<f4'), ('First Cycle Intensity', '<f4'), ('Projected Yield G', '<f4'), ('Reads', '<f4'), ('Reads Pf', '<f4')])
+
+>>> from interop import indexing
+>>> indexing(run_metrics_with_indexing)
+array([(1., 1101., 'ATCACGAC-AAGGTTCA', '1', 4570., 900., 507.77777),
+       (1., 1101., 'ATCACGAC-GGGGGGGG', '2', 2343., 900., 260.33334),
+       (1., 1102., 'ATCACGAC-AAGGTTCA', '1', 4570.,   0.,   0.     ),
+       (1., 1102., 'ATCACGAC-GGGGGGGG', '2', 2343.,   0.,   0.     )],
+      dtype=[('Lane', '<f4'), ('Tile', '<f4'), ('Barcode', 'O'), ('SampleID', 'O'), ('Cluster Count', '<f4'), ('Cluster Count PF', '<f4'), ('% Demux', '<f4')])
+
+>>> from interop import imaging
+>>> imaging(run_metrics_example)
+rec.array([(1., 1101., 1., 1., 1., 0.1, 10., 10., 25. , 33.3, 33.3, 33.3, 0., 10., 10., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.),
+           (1., 1101., 2., 1., 2., 0.2,  5., 15., 12.5, 42.9, 28.6, 28.6, 0.,  5., 15., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.),
+           (1., 1101., 3., 1., 3., 0.3, 10., 10., 25. , 33.3, 50. , 16.7, 0., 10., 10., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.),
+           (1., 1101., 4., 2., 1., 0.4, 10.,  5., 25. , 16.7, 50. , 33.3, 0., 10.,  5., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.),
+           (1., 1101., 5., 3., 1., 0.5, 15.,  5., 37.5, 20. , 40. , 40. , 0., 15.,  5., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.)],
+          dtype=[('Lane', '<f4'), ('Tile', '<f4'), ('Cycle', '<f4'), ('Read', '<f4'), ('Cycle Within Read', '<f4'), ('Error Rate', '<f4'), ('P90/green', '<f4'), ('P90/blue', '<f4'), ('% No Calls', '<f4'), ('% Base/A', '<f4'), ('% Base/C', '<f4'), ('% Base/G', '<f4'), ('% Base/T', '<f4'), ('Fwhm/green', '<f4'), ('Fwhm/blue', '<f4'), ('Corrected/A', '<f4'), ('Corrected/C', '<f4'), ('Corrected/G', '<f4'), ('Corrected/T', '<f4'), ('Called/A', '<f4'), ('Called/C', '<f4'), ('Called/G', '<f4'), ('Called/T', '<f4'), ('Signal To Noise', '<f4'), ('Surface', '<f4'), ('Swath', '<f4'), ('Tile Number', '<f4')])
+
+Any of the core routines above can take a `run_metrics` object or a string containing a file path to a valid run folder.
+
+>>> ar = index_summary("some/path/run_folder_name") # doctest: +SKIP
+
+The structured NumPy array can be converted to a Pandas DataFrame just so:
+
+>>> import pandas as pd # doctest: +SKIP
+>>> df = pd.DataFrame(ar) # doctest: +SKIP
+
+For more information see the documentation around each function below.
+"""
+
+import interop.py_interop_run_metrics as interop_metrics
+import interop.py_interop_metrics as interop_metric_sets
+import interop.py_interop_run as interop_run
+import interop.py_interop_table as interop_table
+import interop.py_interop_summary as interop_summary
+import numpy as np
+import os
+
+_summary_levels = ('Total', 'NonIndex', 'Read', 'Lane', 'Surface')
+_index_summary_levels = ('Lane', 'Barcode')
+
+
+def index_summary(run_metrics, level='Lane', columns=None, dtype='f4', **extra):
+    """ Index summary table
+
+    >>> from interop import index_summary
+    >>> ar = index_summary("some/path/run_folder_name") # doctest: +SKIP
+
+    >>> index_summary(run_metrics_with_indexing)
+    array([(1, 0.4556, 1015.5555, 520.6667, 1536.2222, 1800., 2000.)],
+          dtype=[('Lane', '<u2'), ('Mapped Reads Cv', '<f4'), ('Max Mapped Reads', '<f4'), ('Min Mapped Reads', '<f4'), ('Total Fraction Mapped Reads', '<f4'), ('Total Pf Reads', '<f4'), ('Total Reads', '<f4')])
+
+    >>> index_summary(run_metrics_with_indexing, level='Barcode')
+    array([(1, 18280., 1015.5555, 1., 'ATCACGAC', 'AAGGTTCA', 'TSCAIndexes', '1'),
+           (1,  9372.,  520.6667, 2., 'ATCACGAC', 'GGGGGGGG', 'TSCAIndexes', '2')],
+          dtype=[('Lane', '<u2'), ('Cluster Count', '<f4'), ('Fraction Mapped', '<f4'), ('Id', '<f4'), ('Index1', 'O'), ('Index2', 'O'), ('Project Name', 'O'), ('Sample Id', 'O')])
+
+    >>> index_summary(run_metrics_with_indexing, columns=['Total Fraction Mapped Reads'])
+    array([(1, 1536.2222)],
+          dtype=[('Lane', '<u2'), ('Total Fraction Mapped Reads', '<f4')])
+
+    >>> index_summary(run_metrics_with_indexing, columns=['Incorrect'])
+    Traceback (most recent call last):
+    ...
+    ValueError: Column `Incorrect` not found in: ['Mapped Reads Cv', 'Max Mapped Reads', 'Min Mapped Reads', 'Total Fraction Mapped Reads', 'Total Pf Reads', 'Total Reads'] - column not consistent with level or misspelled
+
+    >>> index_summary(run_metrics_with_indexing, level='Incorrect')
+    Traceback (most recent call last):
+    ...
+    ValueError: level=Incorrect not in ('Lane', 'Barcode')
+
+    :param run_metrics: py_interop_run_metrics.run_metrics or string run folder path
+    :param level: level of the data to summarize, valid values include: 'Total', 'NonIndex', 'Read', 'Lane', 'Surface' (Default: Total)
+    :param columns: list of columns (valid values depend on the level) see `summary_columns`
+    :param dtype: data type for the array (Default: 'f4')
+    :param extra: all extra parameters are passed to `read` if the first parameter is a str file path to a run folder
+    :return: structured with column names and dype - np.array
+    """
+
+    if columns is None:
+        columns = index_summary_columns(level)
+    else:
+        if level not in _index_summary_levels:
+            raise ValueError("level={} not in {}".format(str(level), str(_index_summary_levels)))
+
+    extra['valid_to_load'] = create_valid_to_load(('Index', 'Tile', ))
+    run_metrics = read(run_metrics, **extra)
+    if run_metrics.empty():
+        return np.asarray([])
+
+    if not isinstance(run_metrics, interop_metrics.run_metrics):
+        raise ValueError("Expected interop.py_interop_run_metrics.run_metrics or str for `run_metrics`")
+
+    if not isinstance(dtype, str):
+        dtype = np.dtype(dtype).str
+    summary_obj = interop_summary.index_flowcell_summary()
+    interop_summary.summarize_index_metrics(run_metrics, summary_obj)
+
+    if isinstance(columns, str):
+        columns = (columns, )
+    column_map = index_summary_columns(level, ret_dict=True)
+    for col in columns:
+        if col not in column_map:
+            raise ValueError("Column `{}` not found in: {} - column not consistent with level or misspelled".format(
+                col, str(sorted([k for k in column_map.keys()]))))
+
+    def summarize(summary_object, column_list, extra_row=None):
+
+        row_vals = []
+        column_header = []
+        if extra_row is None:
+            extra_row = []
+        for column in column_list:
+            method_name = column_map[column]
+            val = getattr(summary_object, method_name)()
+            column_header.append(column)
+            row_vals.append(val)
+        return tuple(extra_row+row_vals), column_header
+
+    extra_cols = [('Lane', np.uint16)]
+    if level == 'Lane':
+        data = []
+        lane_count = summary_obj.size()
+        column_count = None
+        for lane_index in range(lane_count):
+            lane_summary = summary_obj.at(lane_index)
+            lane_number = lane_index+1
+            row, header = summarize(lane_summary
+                                                 , columns
+                                                 , [lane_number])
+            if column_count is None:
+                column_count = len(row)
+            else:
+                assert column_count == len(row)
+            data.append(row)
+        if len(data) == 0:
+            return np.asarray([])
+        return np.asarray(data, dtype=extra_cols+[(col, dtype) for col in header])
+
+    data = []
+    lane_count = summary_obj.size()
+    column_count = None
+    for lane_index in range(lane_count):
+        lane_summary = summary_obj.at(lane_index)
+        lane_number = lane_index+1
+        sample_count = lane_summary.size()
+        for sample_index in range(sample_count):
+            sample_summary = lane_summary.at(sample_index)
+            row, header = summarize(sample_summary
+                                    , columns
+                                    , [lane_number])
+            if column_count is None:
+                column_count = len(row)
+            else:
+                assert column_count == len(row)
+            data.append(row)
+    if len(data) == 0:
+        return np.asarray([])
+    _str_types = ('Index1', 'Index2', 'Sample Id', 'Project Name')
+    return np.asarray(data, dtype=extra_cols+[(col, dtype if col not in _str_types else np.dtype(object)) for col in header])
+
+
+def index_summary_columns(level='Lane', ret_dict=False):
+    """ List the columns of the `index_summary` table
+
+    >>> from interop import index_summary_columns
+    >>> index_summary_columns()
+    ('Mapped Reads Cv', 'Max Mapped Reads', 'Min Mapped Reads', 'Total Fraction Mapped Reads', 'Total Pf Reads', 'Total Reads')
+
+
+    >>> index_summary_columns('Barcode')
+    ('Cluster Count', 'Fraction Mapped', 'Id', 'Index1', 'Index2', 'Project Name', 'Sample Id')
+
+    :param level: level of the data to summarize, valid values include: 'Lane', 'Barcode' (Default: Lane)
+    :param ret_dict: if true, return a dict mapping from column name to method name (Default: False)
+    :return: tuple of columns (or dictionary mapping column name to method depending on `ret_dict` parameter)
+    """
+
+    if level not in _index_summary_levels:
+        raise ValueError("level={} not in {}".format(str(level), str(_index_summary_levels)))
+    summary_obj = interop_summary.index_lane_summary() if level == 'Lane' else interop_summary.index_count_summary()
+    exclude_attrs = ('thisown', 'this', '_s', 'at', 'size', 'resize', 'lane', 'surface', 'cycle_state', 'clear', 'reserve', 'sort', 'push_back', 'set', 'add', 'update_fraction_mapped')
+    methods = tuple([v for v in dir(summary_obj) if not v.startswith('__') and v not in exclude_attrs])
+
+    def to_column_name(method):
+        return " ".join([v.capitalize().replace("Percent", "%") .replace("Gt", ">=") for v in method.split('_')])
+
+    if ret_dict:
+        return dict([(to_column_name(v), v) for v in methods])
+    return tuple([to_column_name(c) for c in methods])
+
+
+def summary(run_metrics, level='Total', columns=None, dtype='f4', ignore_missing_columns=True, **extra):
+    """ Generate a summary table with the given level, columns and dtype from a run_metrics object or run_folder path
+
+    Note that not all columns will be included if InterOp files are missing or purposing excluded using `valid_to_load`.
+
+    The following examples show the different levels that one can summarize the data including:
+
+     - Total (Default)
+     - NonIndex
+     - Read
+     - Lane
+     - Summary
+
+    >>> from interop import summary
+    >>> ar = summary("some/path/run_folder_name") # doctest: +SKIP
+    >>> ar = summary("some/path/run_folder_name", valid_to_load=['Error']) # doctest: +SKIP
+
+
+    >>> summary(run_metrics_example)
+    array([(0.36666667, 6.6666665, 0., 0., 0.)],
+          dtype=[('Error Rate', '<f4'), ('First Cycle Intensity', '<f4'), ('Projected Yield G', '<f4'), ('Reads', '<f4'), ('Reads Pf', '<f4')])
+
+    >>> summary(run_metrics_example, 'Total')
+    array([(0.36666667, 6.6666665, 0., 0., 0.)],
+          dtype=[('Error Rate', '<f4'), ('First Cycle Intensity', '<f4'), ('Projected Yield G', '<f4'), ('Reads', '<f4'), ('Reads Pf', '<f4')])
+
+    >>> summary(run_metrics_example, 'NonIndex')
+    array([(0.2, 10., 0., 0., 0.)],
+          dtype=[('Error Rate', '<f4'), ('First Cycle Intensity', '<f4'), ('Projected Yield G', '<f4'), ('Reads', '<f4'), ('Reads Pf', '<f4')])
+
+    >>> summary(run_metrics_example, 'Read')
+    array([(1, 78, 0.2, 10., 0., 0., 0.), (2, 89, 0.4,  5., 0., 0., 0.),
+           (3, 89, 0.5,  5., 0., 0., 0.)],
+          dtype=[('ReadNumber', '<u2'), ('IsIndex', 'u1'), ('Error Rate', '<f4'), ('First Cycle Intensity', '<f4'), ('Projected Yield G', '<f4'), ('Reads', '<f4'), ('Reads Pf', '<f4')])
+
+    >>> summary(run_metrics_example, 'Lane')
+    array([(1, 78, 1, 0.2, 10., 0., 0., 0., 1.),
+           (2, 89, 1, 0.4,  5., 0., 0., 0., 1.),
+           (3, 89, 1, 0.5,  5., 0., 0., 0., 1.)],
+          dtype=[('ReadNumber', '<u2'), ('IsIndex', 'u1'), ('Lane', '<u2'), ('Error Rate', '<f4'), ('First Cycle Intensity', '<f4'), ('Projected Yield G', '<f4'), ('Reads', '<f4'), ('Reads Pf', '<f4'), ('Tile Count', '<f4')])
+
+    For a single surface, as is this example, nothing is reported.
+    >>> summary(run_metrics_example, 'Surface')
+    array([], dtype=float64)
+
+    We can select specific columns using the `columns` parameter
+    >>> summary(run_metrics_example, 'Total', columns=['First Cycle Intensity', 'Error Rate'])
+    array([(6.6666665, 0.36666667)],
+          dtype=[('First Cycle Intensity', '<f4'), ('Error Rate', '<f4')])
+
+    If a column values are NaN, or missing, then it will automatically be excluded
+    >>> summary(run_metrics_example, 'Total', columns=['% Aligned', 'Error Rate'])
+    array([(0.36666667,)], dtype=[('Error Rate', '<f4')])
+
+    To include missing columns, set `ignore_missing_columns=False`
+    >>> summary(run_metrics_example, 'Total', ignore_missing_columns=False, columns=['% Aligned', 'Error Rate'])
+    array([(nan, 0.36666667)],
+          dtype=[('% Aligned', '<f4'), ('Error Rate', '<f4')])
+
+    >>> summary(run_metrics_example, 'Total', columns=['Incorrect'])
+    Traceback (most recent call last):
+     ...
+    ValueError: Column `Incorrect` not found in: ['Error Rate', 'First Cycle Intensity', '% Aligned', '% >= Q30', '% Occupancy Proxy', '% Occupied', 'Projected Yield G', 'Yield G'] - column not consistent with level or misspelled
+
+
+    :param run_metrics: py_interop_run_metrics.run_metrics or string run folder path
+    :param level: level of the data to summarize, valid values include: 'Total', 'NonIndex', 'Read', 'Lane', 'Surface' (Default: Total)
+    :param columns: list of columns (valid values depend on the level) see `summary_columns`
+    :param dtype: data type for the array (Default: 'f4')
+    :param ignore_missing_columns: ignore missing columns, e.g. those with NaN values (Default: True)
+    :param extra: all extra parameters are passed to `read` if the first parameter is a str file path to a run folder
+    :return: structured with column names and dype - np.array
+    """
+
+    if columns is None:
+        columns = summary_columns(level)
+    else:
+        if level not in _summary_levels:
+            raise ValueError("level={} not in {}".format(str(level), str(_summary_levels)))
+
+    if isinstance(run_metrics, str):
+        if extra.get('valid_to_load', None) is None:
+            extra['valid_to_load'] = load_summary_metrics()
+    run_metrics = read(run_metrics, **extra)
+    if run_metrics.empty():
+        return np.asarray([])
+
+    if not isinstance(run_metrics, interop_metrics.run_metrics):
+        raise ValueError("Expected interop.py_interop_run_metrics.run_metrics or str for `run_metrics`")
+
+    run_summary = interop_summary.run_summary()
+    interop_summary.summarize_run_metrics(run_metrics, run_summary, False, False)
+
+    if isinstance(columns, str):
+        columns = (columns, )
+    column_map = summary_columns(level, ret_dict=True)
+    for col in columns:
+        if col not in column_map:
+            raise ValueError("Column `{}` not found in: {} - column not consistent with level or misspelled".format(
+                col, str(sorted([k for k in column_map.keys()]))))
+    if not isinstance(dtype, str):
+        dtype = np.dtype(dtype).str
+
+    def summarize(summary_object, column_list, extra_row=None, ignore_missing=ignore_missing_columns):
+        row_vals = []
+        column_header = []
+        column_subset = []
+        if extra_row is None:
+            extra_row = []
+        for column in column_list:
+            method_name, subcols = column_map[column]
+            if callable(subcols):
+                subcols = subcols(run_metrics.run_info())
+            val = getattr(summary_object, method_name)()
+            if hasattr(val, 'mean'):
+                val = val.mean()
+            if ignore_missing and not np.any(np.isfinite(val)):
+                continue
+            if len(subcols) > 1:
+                assert len(val) == len(subcols)
+                column_header.extend(subcols)
+                row_vals.extend(val)
+            else:
+                column_header.append(column)
+                row_vals.append(val)
+            column_subset.append(column)
+        return tuple(extra_row+row_vals), column_header, column_subset
+
+    if level in ('Total', 'NonIndex'):
+        summary_obj = run_summary.total_summary() if level == 'Total' else run_summary.nonindex_summary()
+        row, header, _ = summarize(summary_obj, columns)
+        header = [(col, dtype) for col in header]
+        return np.asarray([row], dtype=header)
+
+    extra_cols = [('ReadNumber', np.uint16), ('IsIndex', np.uint8)]
+    if level == 'Read':
+        data = []
+        read_count = run_summary.size()
+        column_count = None
+        for read_index in range(read_count):
+            read_summary = run_summary.at(read_index)
+            read_info = read_summary.read()
+            read_number = read_info.number()
+            is_index = read_info.is_index()
+            read_summary = read_summary.summary()
+            row, header, columns_sel = summarize(read_summary
+                                     , columns
+                                     , [read_number, int(ord('Y' if is_index else 'N'))]
+                                     , ignore_missing_columns and column_count is None)
+            if column_count is None:
+                column_count = len(row)
+                columns = columns_sel
+            data.append(row)
+        return np.asarray(data, dtype=extra_cols+[(col, dtype) for col in header])
+
+    extra_cols += [('Lane', np.uint16)]
+    if level == 'Lane':
+        data = []
+        read_count = run_summary.size()
+        column_count = None
+        for read_index in range(read_count):
+            read_summary = run_summary.at(read_index)
+            read_info = read_summary.read()
+            read_number = read_info.number()
+            is_index = read_info.is_index()
+            for lane_index in range(read_summary.size()):
+                lane_summary = read_summary.at(lane_index)
+                lane_number = lane_summary.lane()
+                row, header, columns_sel = summarize(lane_summary
+                                         , columns
+                                         , [read_number, int(ord('Y' if is_index else 'N')), lane_number]
+                                         , ignore_missing_columns and column_count is None)
+                if column_count is None:
+                    column_count = len(row)
+                    columns = columns_sel
+                data.append(row)
+        return np.asarray(data, dtype=extra_cols+[(col, dtype) for col in header])
+
+    data = []
+    read_count = run_summary.size()
+    column_count = None
+    extra_cols += [('Surface', np.uint16)]
+    for read_index in range(read_count):
+        read_summary = run_summary.at(read_index)
+        read_info = read_summary.read()
+        read_number = read_info.number()
+        is_index = read_info.is_index()
+        for lane_index in range(read_summary.size()):
+            lane_summary = read_summary.at(lane_index)
+            lane_number = lane_summary.lane()
+            for surface_index in range(lane_summary.size()):
+                surface_summary = lane_summary.at(surface_index)
+                surface_number = surface_summary.surface()
+                row, header, columns_sel = summarize(surface_summary
+                                         , columns
+                                         , [read_number, int(ord('Y' if is_index else 'N')), lane_number, surface_number]
+                                         , ignore_missing_columns and column_count is None)
+                if column_count is None:
+                    column_count = len(row)
+                    columns = columns_sel
+                data.append(row)
+    if len(data) == 0:
+        return np.asarray([])
+    return np.asarray(data, dtype=extra_cols+[(col, dtype) for col in header])
+
+
+def load_summary_metrics():
+    """ List of valid summary metrics to load
+
+    >>> from interop import load_to_string_list
+    >>> from interop import load_summary_metrics
+    >>> load_to_string_list(load_summary_metrics())
+    ['CorrectedInt', 'Error', 'Extraction', 'Q', 'Tile', 'QByLane', 'QCollapsed', 'EmpiricalPhasing', 'ExtendedTile']
+
+    :return: valid_to_load
+    """
+
+    valid_to_load = interop_run.uchar_vector(interop_run.MetricCount, 0)
+    interop_metrics.list_summary_metrics_to_load(valid_to_load, interop_run.NovaSeq)
+    return valid_to_load
+
+
+def summary_columns(level='Total', ret_dict=False):
+    """ Get a list of column names supported at each level of the summary table
+
+    >>> from interop import summary_columns
+
+    The default columns are for the Run/Read level
+    >>> summary_columns()
+    ('Cluster Count', 'Cluster Count Pf', 'Error Rate', 'First Cycle Intensity', '% Aligned', '% >= Q30', '% Occupancy Proxy', '% Occupied', 'Projected Yield G', 'Reads', 'Reads Pf', 'Yield G')
+    >>> summary_columns(level='Total')
+    ('Cluster Count', 'Cluster Count Pf', 'Error Rate', 'First Cycle Intensity', '% Aligned', '% >= Q30', '% Occupancy Proxy', '% Occupied', 'Projected Yield G', 'Reads', 'Reads Pf', 'Yield G')
+    >>> summary_columns(level='NonIndex')
+    ('Cluster Count', 'Cluster Count Pf', 'Error Rate', 'First Cycle Intensity', '% Aligned', '% >= Q30', '% Occupancy Proxy', '% Occupied', 'Projected Yield G', 'Reads', 'Reads Pf', 'Yield G')
+    >>> summary_columns(level='Read')
+    ('Cluster Count', 'Cluster Count Pf', 'Error Rate', 'First Cycle Intensity', '% Aligned', '% >= Q30', '% Occupancy Proxy', '% Occupied', 'Projected Yield G', 'Reads', 'Reads Pf', 'Yield G')
+
+    The lane/surface level give another set of columns for the summary table
+    >>> summary_columns(level='Lane')
+    ('Cluster Count', 'Cluster Count Pf', 'Density', 'Density Pf', 'Error Rate', 'Error Rate 100', 'Error Rate 35', 'Error Rate 50', 'Error Rate 75', 'First Cycle Intensity', '% Aligned', '% >= Q30', '% Occupied', '% Pf', 'Phasing', 'Phasing Offset', 'Phasing Slope', 'Prephasing', 'Prephasing Offset', 'Prephasing Slope', 'Projected Yield G', 'Reads', 'Reads Pf', 'Tile Count', 'Yield G')
+    >>> summary_columns(level='Surface')
+    ('Cluster Count', 'Cluster Count Pf', 'Density', 'Density Pf', 'Error Rate', 'Error Rate 100', 'Error Rate 35', 'Error Rate 50', 'Error Rate 75', 'First Cycle Intensity', '% Aligned', '% >= Q30', '% Occupied', '% Pf', 'Phasing', 'Phasing Offset', 'Phasing Slope', 'Prephasing', 'Prephasing Offset', 'Prephasing Slope', 'Projected Yield G', 'Reads', 'Reads Pf', 'Tile Count', 'Yield G')
+
+    :param level: level of the data to summarize, valid values include: 'Run', 'Read', 'Lane', 'Surface' (Default: Run)
+    :param ret_dict: if true, return a dict mapping from column name to method name (Default: False)
+    :return: tuple of columns - each column is a tuple, or a tuple of lambda functions that take the run_info as an argument
+    """
+
+    if level not in _summary_levels:
+        raise ValueError("level={} not in {}".format(str(level), str(_summary_levels)))
+    if level == 'Lane' or level == 'Surface':
+        summary_obj = interop_summary.lane_summary()
+    else:
+        summary_obj = interop_summary.read_summary().summary()
+    exclude_attrs = ('thisown', 'this', '_s', 'at', 'size', 'resize', 'resize_stat', 'lane', 'surface', 'cycle_state')
+    methods = tuple([v for v in dir(summary_obj) if not v.startswith('__') and v not in exclude_attrs])
+
+    def to_column_name(method):
+        return " ".join([v.capitalize().replace("Percent", "%") .replace("Gt", ">=") for v in method.split('_')])
+
+    def sub_cols(method):
+
+        column_name = to_column_name(method)
+        if method == 'percent_base':
+            base_map = {interop_run.A: 'A', interop_run.C: 'C', interop_run.G: 'G', interop_run.T: 'T'}
+            return tuple([column_name+" "+base_map[i] for i in range(4)])
+        if method == 'fwhm':
+            def fwhm_columns(run_info):
+                return tuple([column_name+" "+channel for channel in run_info.channels()])
+            fwhm_columns.__name__ = 'fwhm_columns'
+            return fwhm_columns
+        if method == 'resynthesis':
+            def resynthesis_columns(run_info):
+                return tuple([column_name+" "+channel for channel in run_info.channels()])
+            resynthesis_columns.__name__ = 'resynthesis_columns'
+            return resynthesis_columns
+        return tuple()
+
+    if ret_dict:
+        return dict([(to_column_name(v), (v, sub_cols(v))) for v in methods])
+    return tuple([to_column_name(c) for c in methods])
+
+
+def indexing(run_metrics, per_sample=True, dtype='f4', stype='O', **extra):
+    """ Convert InterOp run_metrics (or read run_metrics from disk) to a numpy structured array containing an
+    indexing table
+
+    We can read an indexing table directly from a run folder. Note, this does not load all metrics, only those required
+    by the indexing table, e.g. IndexMetricsOut.bin
+
+    >>> from interop import indexing
+    >>> ar = indexing("some/path/run_folder_name") # doctest: +SKIP
+
+    Note that `valid_to_load` in `read` is ignored.
+
+
+    We can also convert a `run_metrics` object to an indexing table as follows
+    >>> ar = indexing(run_metrics_with_indexing)
+    >>> ar
+    array([(1., 1101., 'ATCACGAC-AAGGTTCA', '1', 4570., 900., 507.77777),
+           (1., 1101., 'ATCACGAC-GGGGGGGG', '2', 2343., 900., 260.33334),
+           (1., 1102., 'ATCACGAC-AAGGTTCA', '1', 4570.,   0.,   0.     ),
+           (1., 1102., 'ATCACGAC-GGGGGGGG', '2', 2343.,   0.,   0.     )],
+          dtype=[('Lane', '<f4'), ('Tile', '<f4'), ('Barcode', 'O'), ('SampleID', 'O'), ('Cluster Count', '<f4'), ('Cluster Count PF', '<f4'), ('% Demux', '<f4')])
+
+    The `indexing` function also provides an overall sample view by setting `per_sample=False`.
+
+    >>> ar = indexing(run_metrics_with_indexing, per_sample=False)
+    >>> ar
+    array([(1., 1101., 1000., 900., 768.11115),
+           (1., 1102.,    0.,   0.,   0.     )],
+          dtype=[('Lane', '<f4'), ('Tile', '<f4'), ('Cluster Count', '<f4'), ('Cluster Count PF', '<f4'), ('% Demux', '<f4')])
+
+    :param run_metrics: py_interop_run_metrics.run_metrics or string run folder path
+    :param per_sample: return demux per sample (Default: True)
+    :param dtype: data type for the array (Default: 'f4')
+    :param stype: string type for the array (Default: 'O')
+    :param extra: all extra parameters are passed to `read` if the first parameter is a str file path to a run folder
+    :return: structured with column names and dype - np.array
+    """
+
+    extra['valid_to_load'] = create_valid_to_load(('Index', 'Tile'))
+    run_metrics = read(run_metrics, **extra)
+    if not isinstance(run_metrics, interop_metrics.run_metrics):
+        raise ValueError("Expected interop.py_interop_run_metrics.run_metrics or str for `run_metrics`")
+
+    if run_metrics.empty():
+        return np.asarray([])
+    if not isinstance(dtype, str):
+        dtype = np.dtype(dtype).str
+    if not isinstance(stype, str):
+        stype = np.dtype(stype).str
+
+    index_metric_set = run_metrics.index_metric_set()
+    column_names = [("Lane", dtype), ("Tile", dtype)]
+    if per_sample:
+        column_names += [("Barcode", stype), ("SampleID", stype)]
+    column_names += [("Cluster Count", dtype), ("Cluster Count PF", dtype), ("% Demux", dtype)]
+    sample_count = len(index_metric_set.index_order()) if per_sample else 1
+    if sample_count == 0:
+        raise ValueError("No samples found, was `finalize_after_load` called in run_metrics?")
+    reads_list = run_metrics.run_info().reads()
+    index_read_count = sum([1 for i in range(len(reads_list)) if reads_list[i].is_index()])
+    table = np.zeros(index_metric_set.size()//index_read_count*sample_count, dtype=column_names)
+    select_read = index_metric_set.at(0).read() if index_metric_set.size() > 0 else 1
+    k = 0
+    for i in range(index_metric_set.size()):
+        metric = index_metric_set.at(i)
+        if metric.read() != select_read:
+            continue
+        if per_sample:
+            for index_info in metric.indices():
+                if metric.cluster_count_pf() > 0:
+                    percent_demux = float(index_info.cluster_count()) / np.float32(metric.cluster_count_pf()) * 100.0
+                else:
+                    percent_demux = 0
+                table[k] = (metric.lane()
+                            , metric.tile()
+                            , index_info.index_seq()
+                            , index_info.sample_id()
+                            , index_info.cluster_count()
+                            , metric.cluster_count_pf()
+                            , percent_demux
+                            )
+                k += 1
+        else:
+            percent_demux = metric.percent_demultiplexed("")
+            if not np.isfinite(percent_demux):
+                percent_demux = 0.0
+            table[k] = (metric.lane()
+                        , metric.tile()
+                        , metric.cluster_count()
+                        , metric.cluster_count_pf()
+                        , percent_demux
+                        )
+            k += 1
+    return table
+
+
+def imaging(run_metrics, dtype='f4', **extra):
+    """ Convert InterOp run_metrics (or read run_metrics from disk) to a numpy structured array containing the imaging
+    table
+
+    We can read an imaging table directly from a run folder. Note, this does not load all metrics, only those required
+    by the imaging table. See `load_imaging_metrics` for that list.
+
+    Also note that loading only tile level metrics (e.g. metrics without cycles) will result in an empty table. This is
+    a limitation of the imaging table.
+
+    >>> from interop import imaging
+    >>> from interop import load_imaging_metrics
+    >>> import interop.py_interop_run_metrics as interop_metrics
+    >>> import numpy as np
+    >>> ar = imaging("some/path/run_folder_name") # doctest: +SKIP
+
+    The above function is equivalent to
+    >>> ar = imaging("some/path/run_folder_name", valid_to_load=load_imaging_metrics()) # doctest: +SKIP
+
+    We can select a subset of metrics to include based on metric groups
+    >>> ar = imaging("some/path/run_folder_name", valid_to_load=['Error']) # doctest: +SKIP
+
+    See `read` below for more examples.
+
+    The following example will rely on an existing run_metrics object (possibly created by the `read` function below).
+
+    >>> ar = imaging(run_metrics_example)
+    >>> ar
+    rec.array([(1., 1101., 1., 1., 1., 0.1, 10., 10., 25. , 33.3, 33.3, 33.3, 0., 10., 10., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.),
+               (1., 1101., 2., 1., 2., 0.2,  5., 15., 12.5, 42.9, 28.6, 28.6, 0.,  5., 15., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.),
+               (1., 1101., 3., 1., 3., 0.3, 10., 10., 25. , 33.3, 50. , 16.7, 0., 10., 10., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.),
+               (1., 1101., 4., 2., 1., 0.4, 10.,  5., 25. , 16.7, 50. , 33.3, 0., 10.,  5., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.),
+               (1., 1101., 5., 3., 1., 0.5, 15.,  5., 37.5, 20. , 40. , 40. , 0., 15.,  5., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.)],
+              dtype=[('Lane', '<f4'), ('Tile', '<f4'), ('Cycle', '<f4'), ('Read', '<f4'), ('Cycle Within Read', '<f4'), ('Error Rate', '<f4'), ('P90/green', '<f4'), ('P90/blue', '<f4'), ('% No Calls', '<f4'), ('% Base/A', '<f4'), ('% Base/C', '<f4'), ('% Base/G', '<f4'), ('% Base/T', '<f4'), ('Fwhm/green', '<f4'), ('Fwhm/blue', '<f4'), ('Corrected/A', '<f4'), ('Corrected/C', '<f4'), ('Corrected/G', '<f4'), ('Corrected/T', '<f4'), ('Called/A', '<f4'), ('Called/C', '<f4'), ('Called/G', '<f4'), ('Called/T', '<f4'), ('Signal To Noise', '<f4'), ('Surface', '<f4'), ('Swath', '<f4'), ('Tile Number', '<f4')])
+
+    >>> ar.dtype
+    dtype((numpy.record, [('Lane', '<f4'), ('Tile', '<f4'), ('Cycle', '<f4'), ('Read', '<f4'), ('Cycle Within Read', '<f4'), ('Error Rate', '<f4'), ('P90/green', '<f4'), ('P90/blue', '<f4'), ('% No Calls', '<f4'), ('% Base/A', '<f4'), ('% Base/C', '<f4'), ('% Base/G', '<f4'), ('% Base/T', '<f4'), ('Fwhm/green', '<f4'), ('Fwhm/blue', '<f4'), ('Corrected/A', '<f4'), ('Corrected/C', '<f4'), ('Corrected/G', '<f4'), ('Corrected/T', '<f4'), ('Called/A', '<f4'), ('Called/C', '<f4'), ('Called/G', '<f4'), ('Called/T', '<f4'), ('Signal To Noise', '<f4'), ('Surface', '<f4'), ('Swath', '<f4'), ('Tile Number', '<f4')]))
+
+    We can convert the numpy array to a Pandas DataFrame as follows:
+
+    >>> import pandas as pd  # doctest: +SKIP
+    >>> df = pd.DataFrame(ar)  # doctest: +SKIP
+    >>> df  # doctest: +SKIP
+       Lane  ...  Tile Number
+    0   1.0  ...          1.0
+    1   1.0  ...          1.0
+    2   1.0  ...          1.0
+    3   1.0  ...          1.0
+    4   1.0  ...          1.0
+    <BLANKLINE>
+    [5 rows x 27 columns]
+
+    You can also change the dtype of the resulting data array table.
+    >>> imaging(run_metrics_example, dtype=np.float32)
+    rec.array([(1., 1101., 1., 1., 1., 0.1, 10., 10., 25. , 33.3, 33.3, 33.3, 0., 10., 10., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.),
+               (1., 1101., 2., 1., 2., 0.2,  5., 15., 12.5, 42.9, 28.6, 28.6, 0.,  5., 15., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.),
+               (1., 1101., 3., 1., 3., 0.3, 10., 10., 25. , 33.3, 50. , 16.7, 0., 10., 10., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.),
+               (1., 1101., 4., 2., 1., 0.4, 10.,  5., 25. , 16.7, 50. , 33.3, 0., 10.,  5., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.),
+               (1., 1101., 5., 3., 1., 0.5, 15.,  5., 37.5, 20. , 40. , 40. , 0., 15.,  5., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.)],
+              dtype=[('Lane', '<f4'), ('Tile', '<f4'), ('Cycle', '<f4'), ('Read', '<f4'), ('Cycle Within Read', '<f4'), ('Error Rate', '<f4'), ('P90/green', '<f4'), ('P90/blue', '<f4'), ('% No Calls', '<f4'), ('% Base/A', '<f4'), ('% Base/C', '<f4'), ('% Base/G', '<f4'), ('% Base/T', '<f4'), ('Fwhm/green', '<f4'), ('Fwhm/blue', '<f4'), ('Corrected/A', '<f4'), ('Corrected/C', '<f4'), ('Corrected/G', '<f4'), ('Corrected/T', '<f4'), ('Called/A', '<f4'), ('Called/C', '<f4'), ('Called/G', '<f4'), ('Called/T', '<f4'), ('Signal To Noise', '<f4'), ('Surface', '<f4'), ('Swath', '<f4'), ('Tile Number', '<f4')])
+
+    Here is the output if an empty run_metrics was provided
+    >>> imaging(interop_metrics.run_metrics())
+    array([], dtype=float64)
+
+    Here is an example exception if an improper input is given
+    >>> imaging(None)
+    Traceback (most recent call last):
+    ...
+    ValueError: Expected interop.py_interop_run_metrics.run_metrics or str for `run_metrics`
+
+    :param run_metrics: py_interop_run_metrics.run_metrics or str file path to a run folder
+    :param dtype: data type for the array (Default: 'f4')
+    :param extra: all extra parameters are passed to `read` if the first parameter is a str file path to a run folder
+    :return: structured with column names and dype - np.array
+    """
+
+    if isinstance(run_metrics, str):
+        if extra.get('valid_to_load', None) is None:
+            extra['valid_to_load'] = load_imaging_metrics()
+        run_metrics = read(run_metrics, **extra)
+    if not isinstance(run_metrics, interop_metrics.run_metrics):
+        raise ValueError("Expected interop.py_interop_run_metrics.run_metrics or str for `run_metrics`")
+
+    if run_metrics.empty():
+        return np.asarray([])
+
+    headers, columns = _imaging_columns(run_metrics)
+    row_offsets = interop_table.map_id_offset()
+    interop_table.count_table_rows(run_metrics, row_offsets)
+    column_count = interop_table.count_table_columns(columns)
+    data = np.zeros((len(row_offsets), column_count), dtype=dtype)
+    interop_table.populate_imaging_table_data(run_metrics, columns, row_offsets, data.ravel())
+
+    if not isinstance(dtype, str):
+        dtype = np.dtype(dtype).str
+    return np.core.records.fromarrays(data.transpose()
+                                      , names=",".join(headers)
+                                      , formats=",".join([dtype for _ in headers]))
+
+
+def imaging_columns(run_metrics, **extra):
+    """ Get a list of imaging table columns
+
+    >>> from interop import imaging_columns
+    >>> from interop import load_imaging_metrics
+    >>> import interop.py_interop_run_metrics as interop_metrics
+    >>> import numpy as np
+    >>> ar = imaging_columns("some/path/run_folder_name") # doctest: +SKIP
+
+    The above function is equivalent to
+    >>> ar = imaging_columns("some/path/run_folder_name", valid_to_load=load_imaging_metrics()) # doctest: +SKIP
+
+    We can select a subset of metrics to include based on metric groups
+    >>> ar = imaging_columns("some/path/run_folder_name", valid_to_load=['Error']) # doctest: +SKIP
+
+    See `read` below for more examples.
+
+    The following example will rely on an existing run_metrics object (possibly created by the `read` function below).
+
+    >>> imaging_columns(run_metrics_example)
+    ['Lane', 'Tile', 'Cycle', 'Read', 'Cycle Within Read', 'Error Rate', 'P90/green', 'P90/blue', '% No Calls', '% Base/A', '% Base/C', '% Base/G', '% Base/T', 'Fwhm/green', 'Fwhm/blue', 'Corrected/A', 'Corrected/C', 'Corrected/G', 'Corrected/T', 'Called/A', 'Called/C', 'Called/G', 'Called/T', 'Signal To Noise', 'Surface', 'Swath', 'Tile Number']
+
+    :param run_metrics: py_interop_run_metrics.run_metrics or str file path to a run folder
+    :param extra: all extra parameters are passed to `read` if the first parameter is a str file path to a run folder
+    :return: list of string headers
+    """
+
+    if isinstance(run_metrics, str):
+        if extra.get('valid_to_load', None) is None:
+            extra['valid_to_load'] = load_imaging_metrics()
+        run_metrics = read(run_metrics, **extra)
+    if not isinstance(run_metrics, interop_metrics.run_metrics):
+        raise ValueError("Expected interop.py_interop_run_metrics.run_metrics or str for `run_metrics`")
+
+    return _imaging_columns(run_metrics)[0]
+
+
+def _imaging_columns(run_metrics):
+    """ Internal function for getting the imaging columns
+
+    :param run_metrics: py_interop_run_metrics.run_metrics or str file path to a run folder
+    :return: a tuple including (headers, imaging_column_vector)
+    """
+
+    columns = interop_table.imaging_column_vector()
+    interop_table.create_imaging_table_columns(run_metrics, columns)
+
+    headers = []
+    for i in range(columns.size()):
+        column = columns[i]
+        if column.has_children():
+            headers.extend([str(column.name()) + "/" + str(subname).strip() for subname in column.subcolumns()])
+        else:
+            headers.append(str(column.name()))
+    return headers, columns
+
+
+def read(run, valid_to_load=None, requires=None, search_paths=None, **extra):
+    """ Read InterOp metrics into a run_metrics object
+
+    - List of validate valid_to_load names can be gotten using `list_interop_files`
+    - If run is `interop.py_interop_run_metrics.run_metrics` then run is returned.
+    - If an InterOp file is missing from the `requires` list, then an empty run_metrics object is returned
+
+    Read in all metrics from a run folder
+    >>> from interop import read
+    >>> metrics = read("some/path/run_folder_name") # doctest: +SKIP
+
+    Read in only ErrorMetricsOut.bin in a run folder
+    >>> metrics = read("some/path/run_folder_name", valid_to_load=['Error']) # doctest: +SKIP
+
+    Read in ErrorMetricsOut.bin and ExtractionMetricsOut.bin but if ErrorMetricsOut.bin is missing return an empty
+    >>> metrics = read("some/path/run_folder_name", valid_to_load=['Error', 'Extraction'], requires=['Error']) # doctest: +SKIP
+
+    Read in IndexMetricsOut.bin and search for it outside the run folder in `fastq/reports`
+    >>> metrics = read("some/path/run_folder_name", valid_to_load=['Index'], search_paths=['fastq/reports']) # doctest: +SKIP
+
+    Read in a run folder that is not found
+    >>> metrics = read("some/non/existing/run_folder_name")
+    Traceback (most recent call last):
+    ...
+    interop.py_interop_run.xml_file_not_found_exception: cannot open file some/non/existing/run_folder_name/RunInfo.xml
+
+    Read from a None object
+    >>> metrics = read(None)
+    Traceback (most recent call last):
+    ...
+    ValueError: invalid null reference in method 'run_metrics_read', argument 2 of type 'std::string const &'
+
+    :param run: string path including name of run folder (or run_metrics object)
+    :param valid_to_load: list of strings containing InterOp metric names (Default: None, load everything)
+    :param requires: list of required metric (Default: None, check nothing)
+    :param search_paths: list of paths to search when looking for `IndexMetricsOut.bin` (Default: None, do not search)
+    :return: interop.py_interop_run_metrics.run_metrics
+    """
+
+    if isinstance(run, interop_metrics.run_metrics):
+        return run
+
+    if search_paths is None:
+        search_paths = (os.path.join('Analysis', '1', 'Data', 'Reports'))
+    if isinstance(search_paths, str):
+        search_paths = [search_paths]
+    if valid_to_load is None:
+        valid_to_load = []
+    if requires is None:
+        requires = []
+
+    run_metrics = interop_metrics.run_metrics()
+    valid_to_load = create_valid_to_load(valid_to_load)
+    if valid_to_load is not None:
+        run_metrics.read(run, valid_to_load)
+    else:
+        run_metrics.read(run)
+
+    if (valid_to_load is None or 'Index' in load_to_string_list(valid_to_load)) and run_metrics.index_metric_set().empty():
+        for path in search_paths:
+            filename = os.path.join(run, path, "IndexMetricsOut.bin")
+            if not os.path.exists(filename):
+                continue
+            if run_metrics.run_info().name() == "":
+                run_metrics.read_xml(run)
+            run_metrics = read_metric(filename, run_metrics=run_metrics, finalize=True)
+            break
+    for group in requires:
+        if run_metrics.is_group_empty(group):
+            return interop_metrics.run_metrics()
+
+    return run_metrics
+
+
+def read_metric(filename, run_metrics=None, finalize=False):
+    """ Read a specific metric from a file into a run_metrics object
+
+    This function allows incremental reading of metric files from disk. The last call should set
+    `finalize=True`.
+
+    Read in `ErrorMetricsOut.bin` into a run_metrics object and finalize since this is the only metric we plan to read
+
+    >>> from interop import read_metric
+    >>> metrics = read_metric("some/path/run_folder_name/InterOp/ErrorMetricsOut.bin", finalize=True) # doctest: +SKIP
+
+    :param filename: path to InterOp file
+    :param run_metrics: existing run_metrics object (Default None, one will be created)
+    :param finalize: if true, then call finalize_after_load (last call to `read_metric` should set finalize=True)
+    :return: interop.py_interop_run_metrics.run_metrics
+    """
+
+    if run_metrics is None:
+        run_metrics = interop_metrics.run_metrics()
+    metric_group = group_from_filename(filename)
+    data = np.fromfile(filename, dtype=np.uint8)
+    run_metrics.read_metrics_from_buffer(metric_group, data)
+    if finalize:
+        run_metrics.finalize_after_load()
+    return run_metrics
+
+
+def create_valid_to_load(interop_prefixes):
+    """ Create list of metrics valid to load by the InterOp library
+
+    List of validate metric_names can be gotten using `list_interop_files`
+
+    >>> from interop import create_valid_to_load
+    >>> int(create_valid_to_load(['Extraction'])[0])
+    0
+    >>> create_valid_to_load(0)
+    Traceback (most recent call last):
+        ...
+    TypeError: Parameter valid_to_load must be a collection of values
+
+    :param interop_prefixes: list of strings containing InterOp metric names
+    :return: py_interop_run.uchar_vector
+    """
+
+    if not hasattr(interop_prefixes, '__len__'):
+        raise TypeError("Parameter valid_to_load must be a collection of values")
+
+    if interop_prefixes is None or len(interop_prefixes) == 0:
+        return None
+
+    if isinstance(interop_prefixes, interop_run.uchar_vector):
+        return interop_prefixes
+
+    valid_to_load = interop_run.uchar_vector(interop_run.MetricCount, 0)
+    enable_metrics(valid_to_load, interop_prefixes)
+
+    return valid_to_load
+
+
+def enable_metrics(valid_to_load, interop_prefixes):
+    """ Enable metrics in valid_to_load
+
+    >>> from interop import enable_metrics, load_to_string_list
+    >>> import interop.py_interop_run as interop_run
+    >>> valid_to_load = interop_run.uchar_vector(interop_run.MetricCount, 0)
+    >>> load_to_string_list(enable_metrics(valid_to_load, 'Extraction'))
+    ['Extraction']
+    >>> load_to_string_list(enable_metrics(valid_to_load, ['Error', 'Q']))
+    ['Error', 'Extraction', 'Q']
+
+    Nothing changes when passing in an empty list
+    >>> load_to_string_list(enable_metrics(valid_to_load, []))
+    ['Error', 'Extraction', 'Q']
+
+    Here are some example exceptions when the improper parameter is given
+
+    >>> enable_metrics(valid_to_load, None)
+    Traceback (most recent call last):
+      ...
+    TypeError: 'NoneType' object is not iterable
+    >>> enable_metrics(None, [])
+    Traceback (most recent call last):
+    ...
+    TypeError: Parameter valid_to_load must be of type interop.py_interop_run.uchar_vector
+    >>> enable_metrics("None", [])
+    Traceback (most recent call last):
+    ...
+    TypeError: Parameter valid_to_load must be of type interop.py_interop_run.uchar_vector
+
+
+    :param valid_to_load: interop_run.uchar_vector (boolean array)
+    :param interop_prefixes: list of metrics to enable
+    :return: interop_run.uchar_vector (It is updated in-place so the return can be ignored)
+    """
+    if not isinstance(valid_to_load, interop_run.uchar_vector):
+        raise TypeError("Parameter valid_to_load must be of type interop.py_interop_run.uchar_vector")
+
+    if isinstance(interop_prefixes, str):
+        interop_prefixes = [interop_prefixes]
+
+    for metric_name in interop_prefixes:
+        if interop_run.parse_metric_group(metric_name) >= interop_run.MetricCount:
+            raise ValueError("Cannot parse metric file name: {}".format(metric_name))
+        valid_to_load[interop_run.parse_metric_group(metric_name)] = 1
+    return valid_to_load
+
+
+def load_to_string_list(valid_to_load):
+    """ Create a string list of names for each enabled metric in `valid_to_load`
+
+    >>> from interop import create_valid_to_load, load_to_string_list
+    >>> import interop.py_interop_run as interop_run
+    >>> valid_to_load = create_valid_to_load('Extraction')
+    >>> load_to_string_list(valid_to_load)
+    ['Extraction']
+    >>> valid_to_load = interop_run.uchar_vector(interop_run.MetricCount, 1)
+    >>> load_to_string_list(valid_to_load)
+    ['CorrectedInt', 'Error', 'Extraction', 'Image', 'Index', 'Q', 'Tile', 'QByLane', 'QCollapsed', 'EmpiricalPhasing', 'DynamicPhasing', 'ExtendedTile', 'SummaryRun']
+
+    :param valid_to_load: boolean buffer
+    :return: list of strings containing the name of each metric enabled in `valid_to_load`
+    """
+
+    if not isinstance(valid_to_load, interop_run.uchar_vector):
+        raise TypeError("Parameter valid_to_load must be of type interop.py_interop_run.uchar_vector")
+
+    names = []
+    for i in range(interop_run.MetricCount):
+        if valid_to_load[i] > 0:
+            names.append(interop_run.to_string_metric_group(i))
+    return names
+
+
+def group_from_filename(filename):
+    """ Get the metric group id from an InterOp filename path
+
+    >>> from interop import group_from_filename
+    >>> import interop.py_interop_run as interop_run
+    >>> group_from_filename("some/path/run/InterOp/ExtractionMetricsOut.bin")
+    2
+    >>> interop_run.Extraction
+    2
+
+    This group id can be used to load a metric from a binary buffer as in `interop.core.read_metric`
+
+    :param filename: path to interop metric
+    :return: interop_run.metric_group
+    """
+
+    metric_name = os.path.basename(filename)
+    metric_name, ext = os.path.splitext(metric_name)
+    if ext != '.bin':
+        raise ValueError("InterOp file must have `bin` extension: {}".format(filename))
+    if metric_name.endswith('Out'):
+        metric_name = metric_name[:-3]
+    if metric_name.endswith('Metrics'):
+        metric_name = metric_name[:-7]
+    else:
+        if ext != 'bin':
+            raise ValueError("InterOp file must have `Metrics.bin` or `MetricsOut.bin` suffix: {}".format(filename))
+    group = interop_run.parse_metric_group(metric_name)
+    if group >= interop_run.MetricCount:
+        raise ValueError("Cannot identify InteropMetric from: {}".format(filename))
+    return group
+
+
+def load_imaging_metrics():
+    """ List of valid imaging metrics to load
+
+    >>> from interop import load_to_string_list
+    >>> from interop import load_imaging_metrics
+    >>> load_to_string_list(load_imaging_metrics())
+    ['CorrectedInt', 'Error', 'Extraction', 'Image', 'Q', 'Tile', 'QByLane', 'QCollapsed', 'EmpiricalPhasing', 'DynamicPhasing', 'ExtendedTile']
+
+    :return: valid_to_load
+    """
+
+    valid_to_load = interop_run.uchar_vector(interop_run.MetricCount, 0)
+    interop_table.list_imaging_table_metrics_to_load(valid_to_load)
+    return valid_to_load
+
+########################################################################################################################
+# Functions and other code to support doc tests
+########################################################################################################################
+
+
+def _run_info_example_fixture(tiles=None):
+    """Fixture used for doctests"""
+
+    run_name = "111111_UNKNOWN_1_XXYT"
+    run_info_version = 6
+    run_date, instrument_name, run_number, flowcell_id = run_name.split('_')
+    if tiles is None:
+        tiles = ['1_1101']
+    lane_count = len(set(tile.split('_')[0] for tile in tiles))
+    surface_count = len(set(tile.split('_')[1][0] for tile in tiles))
+    swath_count = len(set(tile.split('_')[1][1] for tile in tiles))
+    tile_count = len(set(tile.split('_')[1][2:] for tile in tiles))
+    sections_per_lane = 1
+    lanes_per_section = 1
+    naming_method = interop_run.FourDigit
+    flowcell_layout = interop_run.flowcell_layout(lane_count
+                                                  , surface_count
+                                                  , swath_count
+                                                  , tile_count
+                                                  , sections_per_lane
+                                                  , lanes_per_section
+                                                  , tiles
+                                                  , naming_method
+                                                  , flowcell_id)
+    channels = ['green', 'blue']
+    width = 7875
+    height = 10500
+    image_dimensions = interop_run.image_dimensions(width, height)
+    reads = interop_run.read_info_vector()
+    is_reverse_complement = False
+    first_cycle = 1
+    for read_num, cycle_count, is_index in [(1, 3, False), (2, 1, True), (3, 1, True)]:
+        last_cycle = first_cycle + cycle_count
+        reads.push_back(interop_run.read_info(read_num, first_cycle, last_cycle, is_index, is_reverse_complement))
+        first_cycle = last_cycle
+    run_info = interop_run.info(run_name
+                                , run_date
+                                , instrument_name
+                                , int(run_number)
+                                , run_info_version
+                                , flowcell_layout
+                                , channels
+                                , image_dimensions
+                                , reads)
+    return run_info
+
+
+def _run_metrics_example_fixture():
+    """Fixture used for doctests"""
+
+    run_info = _run_info_example_fixture()
+    metrics = interop_metrics.run_metrics(run_info)
+    adapter_rate = np.nan
+    tile_num = 1101
+    lane_num = 1
+
+    error_metric_set = metrics.error_metric_set()
+    for cycle, error_rate in enumerate([0.1, 0.2, 0.3, 0.4, 0.5]):
+        error_metric_set.insert(interop_metric_sets.error_metric(lane_num, tile_num, cycle+1, error_rate, adapter_rate))
+
+    corrected_int_metric_set = metrics.corrected_intensity_metric_set()
+    for cycle, call_counts in enumerate([[10, 10, 10, 10, 0], [5, 15, 10, 10, 0], [10, 10, 15, 5, 0], [10, 5, 15, 10, 0], [15, 5, 10, 10, 0]]):
+        call_counts = np.array(call_counts, dtype=np.uint32)
+        corrected_int_metric_set.insert(interop_metric_sets.corrected_intensity_metric(
+            lane_num, tile_num, cycle+1, call_counts, 0, 0))  # Dummy 0s are to work around swig bug
+
+    extraction_metric_set = metrics.extraction_metric_set()
+    for cycle, call_counts in enumerate([[10, 10], [5, 15], [10, 10], [10, 5], [15, 5]]):
+        intensity_array = np.array(call_counts, dtype=np.uint16)
+        focus_array = np.array(call_counts, dtype=np.float32)
+        extraction_metric_set.insert(interop_metric_sets.extraction_metric(
+            lane_num, tile_num, cycle+1, intensity_array, focus_array, 0))
+    return metrics
+
+
+def _index_metrics_example_fixture():
+    """Fixture used for doctests"""
+
+    run_info = _run_info_example_fixture(['1_1101', '1_1102'])
+    metrics = interop_metrics.run_metrics(run_info)
+    index_metric_set = metrics.index_metric_set()
+
+    indices = interop_metric_sets.index_info_vector()
+    for barcode, sample_id, sample_proj, cluster_count in [
+        ("ATCACGAC-AAGGTTCA", "1", "TSCAIndexes", 4570)
+        , ("ATCACGAC-GGGGGGGG", "2", "TSCAIndexes", 2343)
+    ]:
+        indices.push_back(interop_metric_sets.index_info(barcode, sample_id, sample_proj, cluster_count))
+    tile_num = 1101
+    lane_num = 1
+
+    for read_num in [2, 3]:
+        index_metric_set.insert(interop_metric_sets.index_metric(lane_num, tile_num, read_num, indices));
+
+    tile_metric_set = metrics.tile_metric_set()
+    reads = interop_metric_sets.read_metric_vector()
+    cluster_density = 1000
+    cluster_density_pf = 900
+    cluster_count = 1000
+    cluster_count_pf = 900
+    tile_metric_set.insert(interop_metric_sets.tile_metric(lane_num
+                                                           , tile_num
+                                                           , cluster_density
+                                                           , cluster_density_pf
+                                                           , cluster_count
+                                                           , cluster_count_pf
+                                                           , reads))
+
+    tile_num = 1102
+    lane_num = 1
+    cluster_density = 0
+    cluster_density_pf = 0
+    cluster_count = 0
+    cluster_count_pf = 0
+
+    for read_num in [2, 3]:
+        index_metric_set.insert(interop_metric_sets.index_metric(lane_num, tile_num, read_num, indices));
+    tile_metric_set.insert(interop_metric_sets.tile_metric(lane_num
+                                                           , tile_num
+                                                           , cluster_density
+                                                           , cluster_density_pf
+                                                           , cluster_count
+                                                           , cluster_count_pf
+                                                           , reads))
+
+    metrics.finalize_after_load()
+    return metrics
+
+
+# class RunFolderToDiskFixture(object):
+#
+#     def __init__(self):
+#
+#         self.run_folder = os.path.absolue("./210326_")
+#         run = _run_metrics_example_fixture()
+#         run.write
+#
+#     def __del__(self):
+#         if self.run_folder is not None:
+#             import shutil
+#             shutil.deltree(self.run_folder)
+
+
+def _run_doctests():
+
+    import interop.core
+    import doctest
+    import sys
+    failure_count, test_count = doctest.testmod(interop.core
+                                                , optionflags=doctest.IGNORE_EXCEPTION_DETAIL
+                                                , globs=dict(
+        run_metrics_with_indexing=_index_metrics_example_fixture(),
+        run_metrics_example=_run_metrics_example_fixture()
+    ))
+    if failure_count > 0:
+        sys.exit(1)
+
+
+
+if __name__ == "__main__":
+
+    _run_doctests()
```

## interop/py_interop_comm.py

```diff
@@ -1,265 +1,288 @@
-# This file was automatically generated by SWIG (https://www.swig.org).
-# Version 4.1.1
-#
-# Do not make changes to this file unless you know what you are doing - modify
-# the SWIG interface file instead.
-
-from sys import version_info as _swig_python_version_info
-# Import the low-level C/C++ module
-if __package__ or "." in __name__:
-    from . import _py_interop_comm
-else:
-    import _py_interop_comm
-
-try:
-    import builtins as __builtin__
-except ImportError:
-    import __builtin__
-
-def _swig_repr(self):
-    try:
-        strthis = "proxy of " + self.this.__repr__()
-    except __builtin__.Exception:
-        strthis = ""
-    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)
-
-
-def _swig_setattr_nondynamic_instance_variable(set):
-    def set_instance_attr(self, name, value):
-        if name == "this":
-            set(self, name, value)
-        elif name == "thisown":
-            self.this.own(value)
-        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
-            set(self, name, value)
-        else:
-            raise AttributeError("You cannot add instance attributes to %s" % self)
-    return set_instance_attr
-
-
-def _swig_setattr_nondynamic_class_variable(set):
-    def set_class_attr(cls, name, value):
-        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
-            set(cls, name, value)
-        else:
-            raise AttributeError("You cannot add class attributes to %s" % cls)
-    return set_class_attr
-
-
-def _swig_add_metaclass(metaclass):
-    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
-    def wrapper(cls):
-        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
-    return wrapper
-
-
-class _SwigNonDynamicMeta(type):
-    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
-    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)
-
-
-class SwigPyIterator(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined - class is abstract")
-    __repr__ = _swig_repr
-    __swig_destroy__ = _py_interop_comm.delete_SwigPyIterator
-
-    def value(self):
-        return _py_interop_comm.SwigPyIterator_value(self)
-
-    def incr(self, n=1):
-        return _py_interop_comm.SwigPyIterator_incr(self, n)
-
-    def decr(self, n=1):
-        return _py_interop_comm.SwigPyIterator_decr(self, n)
-
-    def distance(self, x):
-        return _py_interop_comm.SwigPyIterator_distance(self, x)
-
-    def equal(self, x):
-        return _py_interop_comm.SwigPyIterator_equal(self, x)
-
-    def copy(self):
-        return _py_interop_comm.SwigPyIterator_copy(self)
-
-    def next(self):
-        return _py_interop_comm.SwigPyIterator_next(self)
-
-    def __next__(self):
-        return _py_interop_comm.SwigPyIterator___next__(self)
-
-    def previous(self):
-        return _py_interop_comm.SwigPyIterator_previous(self)
-
-    def advance(self, n):
-        return _py_interop_comm.SwigPyIterator_advance(self, n)
-
-    def __eq__(self, x):
-        return _py_interop_comm.SwigPyIterator___eq__(self, x)
-
-    def __ne__(self, x):
-        return _py_interop_comm.SwigPyIterator___ne__(self, x)
-
-    def __iadd__(self, n):
-        return _py_interop_comm.SwigPyIterator___iadd__(self, n)
-
-    def __isub__(self, n):
-        return _py_interop_comm.SwigPyIterator___isub__(self, n)
-
-    def __add__(self, n):
-        return _py_interop_comm.SwigPyIterator___add__(self, n)
-
-    def __sub__(self, *args):
-        return _py_interop_comm.SwigPyIterator___sub__(self, *args)
-    def __iter__(self):
-        return self
-
-# Register SwigPyIterator in _py_interop_comm:
-_py_interop_comm.SwigPyIterator_swigregister(SwigPyIterator)
-import interop.py_interop_run
-import interop.py_interop_metrics
-class format_exception(interop.py_interop_run.base_exception):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, mesg):
-        _py_interop_comm.format_exception_swiginit(self, _py_interop_comm.new_format_exception(mesg))
-
-    def __str__(self):
-        return _py_interop_comm.format_exception___str__(self)
-    __swig_destroy__ = _py_interop_comm.delete_format_exception
-
-# Register format_exception in _py_interop_comm:
-_py_interop_comm.format_exception_swigregister(format_exception)
-class file_not_found_exception(interop.py_interop_run.base_exception):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, mesg):
-        _py_interop_comm.file_not_found_exception_swiginit(self, _py_interop_comm.new_file_not_found_exception(mesg))
-
-    def __str__(self):
-        return _py_interop_comm.file_not_found_exception___str__(self)
-    __swig_destroy__ = _py_interop_comm.delete_file_not_found_exception
-
-# Register file_not_found_exception in _py_interop_comm:
-_py_interop_comm.file_not_found_exception_swigregister(file_not_found_exception)
-class bad_format_exception(format_exception):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, mesg):
-        _py_interop_comm.bad_format_exception_swiginit(self, _py_interop_comm.new_bad_format_exception(mesg))
-
-    def __str__(self):
-        return _py_interop_comm.bad_format_exception___str__(self)
-    __swig_destroy__ = _py_interop_comm.delete_bad_format_exception
-
-# Register bad_format_exception in _py_interop_comm:
-_py_interop_comm.bad_format_exception_swigregister(bad_format_exception)
-class incomplete_file_exception(format_exception):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, mesg):
-        _py_interop_comm.incomplete_file_exception_swiginit(self, _py_interop_comm.new_incomplete_file_exception(mesg))
-
-    def __str__(self):
-        return _py_interop_comm.incomplete_file_exception___str__(self)
-    __swig_destroy__ = _py_interop_comm.delete_incomplete_file_exception
-
-# Register incomplete_file_exception in _py_interop_comm:
-_py_interop_comm.incomplete_file_exception_swigregister(incomplete_file_exception)
-class invalid_argument(interop.py_interop_run.base_exception):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, mesg):
-        _py_interop_comm.invalid_argument_swiginit(self, _py_interop_comm.new_invalid_argument(mesg))
-
-    def __str__(self):
-        return _py_interop_comm.invalid_argument___str__(self)
-    __swig_destroy__ = _py_interop_comm.delete_invalid_argument
-
-# Register invalid_argument in _py_interop_comm:
-_py_interop_comm.invalid_argument_swigregister(invalid_argument)
-class paths(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    @staticmethod
-    def run_info(*args):
-        return _py_interop_comm.paths_run_info(*args)
-
-    @staticmethod
-    def run_parameters(*args):
-        return _py_interop_comm.paths_run_parameters(*args)
-
-    @staticmethod
-    def rta_config(*args):
-        return _py_interop_comm.paths_rta_config(*args)
-
-    @staticmethod
-    def interop_filename(run_directory, prefix, suffix, cycle, use_out=True):
-        return _py_interop_comm.paths_interop_filename(run_directory, prefix, suffix, cycle, use_out)
-
-    def __init__(self):
-        _py_interop_comm.paths_swiginit(self, _py_interop_comm.new_paths())
-    __swig_destroy__ = _py_interop_comm.delete_paths
-
-# Register paths in _py_interop_comm:
-_py_interop_comm.paths_swigregister(paths)
-
-def is_corrected_intensity_metric_deprecated(version):
-    return _py_interop_comm.is_corrected_intensity_metric_deprecated(version)
-
-def is_error_metric_deprecated(version):
-    return _py_interop_comm.is_error_metric_deprecated(version)
-
-def is_extended_tile_metric_deprecated(version):
-    return _py_interop_comm.is_extended_tile_metric_deprecated(version)
-
-def is_extraction_metric_deprecated(version):
-    return _py_interop_comm.is_extraction_metric_deprecated(version)
-
-def is_image_metric_deprecated(version):
-    return _py_interop_comm.is_image_metric_deprecated(version)
-
-def is_q_metric_deprecated(version):
-    return _py_interop_comm.is_q_metric_deprecated(version)
-
-def is_tile_metric_deprecated(version):
-    return _py_interop_comm.is_tile_metric_deprecated(version)
-
-def is_index_metric_deprecated(version):
-    return _py_interop_comm.is_index_metric_deprecated(version)
-
-def is_q_collapsed_metric_deprecated(version):
-    return _py_interop_comm.is_q_collapsed_metric_deprecated(version)
-
-def is_q_by_lane_metric_deprecated(version):
-    return _py_interop_comm.is_q_by_lane_metric_deprecated(version)
-
-def compute_buffer_size(*args):
-    return _py_interop_comm.compute_buffer_size(*args)
-
-def write_interop_to_buffer(*args):
-    return _py_interop_comm.write_interop_to_buffer(*args)
-
-def read_interop_from_buffer(*args):
-    return _py_interop_comm.read_interop_from_buffer(*args)
-
-def read_interop(*args):
-    return _py_interop_comm.read_interop(*args)
-
-def write_interop(*args):
-    return _py_interop_comm.write_interop(*args)
-
-def read_interop_by_cycle(*args):
-    return _py_interop_comm.read_interop_by_cycle(*args)
-
-def is_summary_run_metric_deprecated(version):
-    return _py_interop_comm.is_summary_run_metric_deprecated(version)
-
+# This file was automatically generated by SWIG (http://www.swig.org).
+# Version 4.0.2
+#
+# Do not make changes to this file unless you know what you are doing--modify
+# the SWIG interface file instead.
+
+from sys import version_info as _swig_python_version_info
+if _swig_python_version_info < (2, 7, 0):
+    raise RuntimeError("Python 2.7 or later required")
+
+# Import the low-level C/C++ module
+if __package__ or "." in __name__:
+    from . import _py_interop_comm
+else:
+    import _py_interop_comm
+
+try:
+    import builtins as __builtin__
+except ImportError:
+    import __builtin__
+
+def _swig_repr(self):
+    try:
+        strthis = "proxy of " + self.this.__repr__()
+    except __builtin__.Exception:
+        strthis = ""
+    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)
+
+
+def _swig_setattr_nondynamic_instance_variable(set):
+    def set_instance_attr(self, name, value):
+        if name == "thisown":
+            self.this.own(value)
+        elif name == "this":
+            set(self, name, value)
+        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
+            set(self, name, value)
+        else:
+            raise AttributeError("You cannot add instance attributes to %s" % self)
+    return set_instance_attr
+
+
+def _swig_setattr_nondynamic_class_variable(set):
+    def set_class_attr(cls, name, value):
+        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
+            set(cls, name, value)
+        else:
+            raise AttributeError("You cannot add class attributes to %s" % cls)
+    return set_class_attr
+
+
+def _swig_add_metaclass(metaclass):
+    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
+    def wrapper(cls):
+        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
+    return wrapper
+
+
+class _SwigNonDynamicMeta(type):
+    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
+    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)
+
+
+class SwigPyIterator(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined - class is abstract")
+    __repr__ = _swig_repr
+    __swig_destroy__ = _py_interop_comm.delete_SwigPyIterator
+
+    def value(self):
+        return _py_interop_comm.SwigPyIterator_value(self)
+
+    def incr(self, n=1):
+        return _py_interop_comm.SwigPyIterator_incr(self, n)
+
+    def decr(self, n=1):
+        return _py_interop_comm.SwigPyIterator_decr(self, n)
+
+    def distance(self, x):
+        return _py_interop_comm.SwigPyIterator_distance(self, x)
+
+    def equal(self, x):
+        return _py_interop_comm.SwigPyIterator_equal(self, x)
+
+    def copy(self):
+        return _py_interop_comm.SwigPyIterator_copy(self)
+
+    def next(self):
+        return _py_interop_comm.SwigPyIterator_next(self)
+
+    def __next__(self):
+        return _py_interop_comm.SwigPyIterator___next__(self)
+
+    def previous(self):
+        return _py_interop_comm.SwigPyIterator_previous(self)
+
+    def advance(self, n):
+        return _py_interop_comm.SwigPyIterator_advance(self, n)
+
+    def __eq__(self, x):
+        return _py_interop_comm.SwigPyIterator___eq__(self, x)
+
+    def __ne__(self, x):
+        return _py_interop_comm.SwigPyIterator___ne__(self, x)
+
+    def __iadd__(self, n):
+        return _py_interop_comm.SwigPyIterator___iadd__(self, n)
+
+    def __isub__(self, n):
+        return _py_interop_comm.SwigPyIterator___isub__(self, n)
+
+    def __add__(self, n):
+        return _py_interop_comm.SwigPyIterator___add__(self, n)
+
+    def __sub__(self, *args):
+        return _py_interop_comm.SwigPyIterator___sub__(self, *args)
+    def __iter__(self):
+        return self
+
+# Register SwigPyIterator in _py_interop_comm:
+_py_interop_comm.SwigPyIterator_swigregister(SwigPyIterator)
+
+import interop.py_interop_run
+import interop.py_interop_metrics
+class format_exception(interop.py_interop_run.base_exception):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, mesg):
+        _py_interop_comm.format_exception_swiginit(self, _py_interop_comm.new_format_exception(mesg))
+
+    def __str__(self):
+        return _py_interop_comm.format_exception___str__(self)
+    __swig_destroy__ = _py_interop_comm.delete_format_exception
+
+# Register format_exception in _py_interop_comm:
+_py_interop_comm.format_exception_swigregister(format_exception)
+
+class file_not_found_exception(interop.py_interop_run.base_exception):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, mesg):
+        _py_interop_comm.file_not_found_exception_swiginit(self, _py_interop_comm.new_file_not_found_exception(mesg))
+
+    def __str__(self):
+        return _py_interop_comm.file_not_found_exception___str__(self)
+    __swig_destroy__ = _py_interop_comm.delete_file_not_found_exception
+
+# Register file_not_found_exception in _py_interop_comm:
+_py_interop_comm.file_not_found_exception_swigregister(file_not_found_exception)
+
+class bad_format_exception(format_exception):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, mesg):
+        _py_interop_comm.bad_format_exception_swiginit(self, _py_interop_comm.new_bad_format_exception(mesg))
+
+    def __str__(self):
+        return _py_interop_comm.bad_format_exception___str__(self)
+    __swig_destroy__ = _py_interop_comm.delete_bad_format_exception
+
+# Register bad_format_exception in _py_interop_comm:
+_py_interop_comm.bad_format_exception_swigregister(bad_format_exception)
+
+class incomplete_file_exception(format_exception):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, mesg):
+        _py_interop_comm.incomplete_file_exception_swiginit(self, _py_interop_comm.new_incomplete_file_exception(mesg))
+
+    def __str__(self):
+        return _py_interop_comm.incomplete_file_exception___str__(self)
+    __swig_destroy__ = _py_interop_comm.delete_incomplete_file_exception
+
+# Register incomplete_file_exception in _py_interop_comm:
+_py_interop_comm.incomplete_file_exception_swigregister(incomplete_file_exception)
+
+class invalid_argument(interop.py_interop_run.base_exception):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, mesg):
+        _py_interop_comm.invalid_argument_swiginit(self, _py_interop_comm.new_invalid_argument(mesg))
+
+    def __str__(self):
+        return _py_interop_comm.invalid_argument___str__(self)
+    __swig_destroy__ = _py_interop_comm.delete_invalid_argument
+
+# Register invalid_argument in _py_interop_comm:
+_py_interop_comm.invalid_argument_swigregister(invalid_argument)
+
+class paths(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    @staticmethod
+    def run_info(*args):
+        return _py_interop_comm.paths_run_info(*args)
+
+    @staticmethod
+    def run_parameters(*args):
+        return _py_interop_comm.paths_run_parameters(*args)
+
+    @staticmethod
+    def rta_config(*args):
+        return _py_interop_comm.paths_rta_config(*args)
+
+    @staticmethod
+    def interop_filename(run_directory, prefix, suffix, cycle, use_out=True):
+        return _py_interop_comm.paths_interop_filename(run_directory, prefix, suffix, cycle, use_out)
+
+    def __init__(self):
+        _py_interop_comm.paths_swiginit(self, _py_interop_comm.new_paths())
+    __swig_destroy__ = _py_interop_comm.delete_paths
+
+# Register paths in _py_interop_comm:
+_py_interop_comm.paths_swigregister(paths)
+
+def paths_run_info(*args):
+    return _py_interop_comm.paths_run_info(*args)
+
+def paths_run_parameters(*args):
+    return _py_interop_comm.paths_run_parameters(*args)
+
+def paths_rta_config(*args):
+    return _py_interop_comm.paths_rta_config(*args)
+
+def paths_interop_filename(run_directory, prefix, suffix, cycle, use_out=True):
+    return _py_interop_comm.paths_interop_filename(run_directory, prefix, suffix, cycle, use_out)
+
+
+def is_corrected_intensity_metric_deprecated(version):
+    return _py_interop_comm.is_corrected_intensity_metric_deprecated(version)
+
+def is_error_metric_deprecated(version):
+    return _py_interop_comm.is_error_metric_deprecated(version)
+
+def is_extended_tile_metric_deprecated(version):
+    return _py_interop_comm.is_extended_tile_metric_deprecated(version)
+
+def is_extraction_metric_deprecated(version):
+    return _py_interop_comm.is_extraction_metric_deprecated(version)
+
+def is_image_metric_deprecated(version):
+    return _py_interop_comm.is_image_metric_deprecated(version)
+
+def is_q_metric_deprecated(version):
+    return _py_interop_comm.is_q_metric_deprecated(version)
+
+def is_tile_metric_deprecated(version):
+    return _py_interop_comm.is_tile_metric_deprecated(version)
+
+def is_index_metric_deprecated(version):
+    return _py_interop_comm.is_index_metric_deprecated(version)
+
+def is_q_collapsed_metric_deprecated(version):
+    return _py_interop_comm.is_q_collapsed_metric_deprecated(version)
+
+def is_q_by_lane_metric_deprecated(version):
+    return _py_interop_comm.is_q_by_lane_metric_deprecated(version)
+
+def compute_buffer_size(*args):
+    return _py_interop_comm.compute_buffer_size(*args)
+
+def write_interop_to_buffer(*args):
+    return _py_interop_comm.write_interop_to_buffer(*args)
+
+def read_interop_from_buffer(*args):
+    return _py_interop_comm.read_interop_from_buffer(*args)
+
+def read_interop(*args):
+    return _py_interop_comm.read_interop(*args)
+
+def write_interop(*args):
+    return _py_interop_comm.write_interop(*args)
+
+def read_interop_by_cycle(*args):
+    return _py_interop_comm.read_interop_by_cycle(*args)
+
+def is_summary_run_metric_deprecated(version):
+    return _py_interop_comm.is_summary_run_metric_deprecated(version)
+
+
```

## interop/py_interop_metrics.py

```diff
@@ -1,4346 +1,4595 @@
-# This file was automatically generated by SWIG (https://www.swig.org).
-# Version 4.1.1
-#
-# Do not make changes to this file unless you know what you are doing - modify
-# the SWIG interface file instead.
-
-from sys import version_info as _swig_python_version_info
-# Import the low-level C/C++ module
-if __package__ or "." in __name__:
-    from . import _py_interop_metrics
-else:
-    import _py_interop_metrics
-
-try:
-    import builtins as __builtin__
-except ImportError:
-    import __builtin__
-
-def _swig_repr(self):
-    try:
-        strthis = "proxy of " + self.this.__repr__()
-    except __builtin__.Exception:
-        strthis = ""
-    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)
-
-
-def _swig_setattr_nondynamic_instance_variable(set):
-    def set_instance_attr(self, name, value):
-        if name == "this":
-            set(self, name, value)
-        elif name == "thisown":
-            self.this.own(value)
-        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
-            set(self, name, value)
-        else:
-            raise AttributeError("You cannot add instance attributes to %s" % self)
-    return set_instance_attr
-
-
-def _swig_setattr_nondynamic_class_variable(set):
-    def set_class_attr(cls, name, value):
-        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
-            set(cls, name, value)
-        else:
-            raise AttributeError("You cannot add class attributes to %s" % cls)
-    return set_class_attr
-
-
-def _swig_add_metaclass(metaclass):
-    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
-    def wrapper(cls):
-        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
-    return wrapper
-
-
-class _SwigNonDynamicMeta(type):
-    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
-    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)
-
-
-class SwigPyIterator(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined - class is abstract")
-    __repr__ = _swig_repr
-    __swig_destroy__ = _py_interop_metrics.delete_SwigPyIterator
-
-    def value(self):
-        return _py_interop_metrics.SwigPyIterator_value(self)
-
-    def incr(self, n=1):
-        return _py_interop_metrics.SwigPyIterator_incr(self, n)
-
-    def decr(self, n=1):
-        return _py_interop_metrics.SwigPyIterator_decr(self, n)
-
-    def distance(self, x):
-        return _py_interop_metrics.SwigPyIterator_distance(self, x)
-
-    def equal(self, x):
-        return _py_interop_metrics.SwigPyIterator_equal(self, x)
-
-    def copy(self):
-        return _py_interop_metrics.SwigPyIterator_copy(self)
-
-    def next(self):
-        return _py_interop_metrics.SwigPyIterator_next(self)
-
-    def __next__(self):
-        return _py_interop_metrics.SwigPyIterator___next__(self)
-
-    def previous(self):
-        return _py_interop_metrics.SwigPyIterator_previous(self)
-
-    def advance(self, n):
-        return _py_interop_metrics.SwigPyIterator_advance(self, n)
-
-    def __eq__(self, x):
-        return _py_interop_metrics.SwigPyIterator___eq__(self, x)
-
-    def __ne__(self, x):
-        return _py_interop_metrics.SwigPyIterator___ne__(self, x)
-
-    def __iadd__(self, n):
-        return _py_interop_metrics.SwigPyIterator___iadd__(self, n)
-
-    def __isub__(self, n):
-        return _py_interop_metrics.SwigPyIterator___isub__(self, n)
-
-    def __add__(self, n):
-        return _py_interop_metrics.SwigPyIterator___add__(self, n)
-
-    def __sub__(self, *args):
-        return _py_interop_metrics.SwigPyIterator___sub__(self, *args)
-    def __iter__(self):
-        return self
-
-# Register SwigPyIterator in _py_interop_metrics:
-_py_interop_metrics.SwigPyIterator_swigregister(SwigPyIterator)
-import interop.py_interop_run
-class index_out_of_bounds_exception(interop.py_interop_run.base_exception):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, mesg):
-        _py_interop_metrics.index_out_of_bounds_exception_swiginit(self, _py_interop_metrics.new_index_out_of_bounds_exception(mesg))
-
-    def __str__(self):
-        return _py_interop_metrics.index_out_of_bounds_exception___str__(self)
-    __swig_destroy__ = _py_interop_metrics.delete_index_out_of_bounds_exception
-
-# Register index_out_of_bounds_exception in _py_interop_metrics:
-_py_interop_metrics.index_out_of_bounds_exception_swigregister(index_out_of_bounds_exception)
-class csharp_date_time(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, v=0):
-        _py_interop_metrics.csharp_date_time_swiginit(self, _py_interop_metrics.new_csharp_date_time(v))
-
-    @staticmethod
-    def to_unix(*args):
-        return _py_interop_metrics.csharp_date_time_to_unix(*args)
-
-    @staticmethod
-    def to_seconds(*args):
-        return _py_interop_metrics.csharp_date_time_to_seconds(*args)
-
-    @staticmethod
-    def to_csharp(uval):
-        return _py_interop_metrics.csharp_date_time_to_csharp(uval)
-    value = property(_py_interop_metrics.csharp_date_time_value_get, _py_interop_metrics.csharp_date_time_value_set)
-
-    def to_int(self):
-        return _py_interop_metrics.csharp_date_time_to_int(self)
-
-    def to_binary(self):
-        return _py_interop_metrics.csharp_date_time_to_binary(self)
-
-    def __eq__(self, other):
-        return _py_interop_metrics.csharp_date_time___eq__(self, other)
-    __swig_destroy__ = _py_interop_metrics.delete_csharp_date_time
-
-# Register csharp_date_time in _py_interop_metrics:
-_py_interop_metrics.csharp_date_time_swigregister(csharp_date_time)
-class empty_header(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self):
-        _py_interop_metrics.empty_header_swiginit(self, _py_interop_metrics.new_empty_header())
-    __swig_destroy__ = _py_interop_metrics.delete_empty_header
-
-# Register empty_header in _py_interop_metrics:
-_py_interop_metrics.empty_header_swigregister(empty_header)
-class base_metric_header(empty_header):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    @staticmethod
-    def default_header():
-        return _py_interop_metrics.base_metric_header_default_header()
-
-    def __init__(self):
-        _py_interop_metrics.base_metric_header_swiginit(self, _py_interop_metrics.new_base_metric_header())
-    __swig_destroy__ = _py_interop_metrics.delete_base_metric_header
-
-# Register base_metric_header in _py_interop_metrics:
-_py_interop_metrics.base_metric_header_swigregister(base_metric_header)
-class empty_metric(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def set_base(self, arg2, arg3):
-        return _py_interop_metrics.empty_metric_set_base(self, arg2, arg3)
-
-    @staticmethod
-    def suffix():
-        return _py_interop_metrics.empty_metric_suffix()
-
-    def __lt__(self, arg2):
-        return _py_interop_metrics.empty_metric___lt__(self, arg2)
-
-    @staticmethod
-    def create_id(arg1, arg2, arg3=0):
-        return _py_interop_metrics.empty_metric_create_id(arg1, arg2, arg3)
-
-    def __init__(self):
-        _py_interop_metrics.empty_metric_swiginit(self, _py_interop_metrics.new_empty_metric())
-    __swig_destroy__ = _py_interop_metrics.delete_empty_metric
-
-# Register empty_metric in _py_interop_metrics:
-_py_interop_metrics.empty_metric_swigregister(empty_metric)
-class base_metric(empty_metric):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    LANE_BIT_COUNT = _py_interop_metrics.base_metric_LANE_BIT_COUNT
-    TILE_BIT_COUNT = _py_interop_metrics.base_metric_TILE_BIT_COUNT
-    CYCLE_BIT_COUNT = _py_interop_metrics.base_metric_CYCLE_BIT_COUNT
-    READ_BIT_COUNT = _py_interop_metrics.base_metric_READ_BIT_COUNT
-    RESERVED_BIT_COUNT = _py_interop_metrics.base_metric_RESERVED_BIT_COUNT
-    READ_BIT_SHIFT = _py_interop_metrics.base_metric_READ_BIT_SHIFT
-    CYCLE_BIT_SHIFT = _py_interop_metrics.base_metric_CYCLE_BIT_SHIFT
-    TILE_BIT_SHIFT = _py_interop_metrics.base_metric_TILE_BIT_SHIFT
-    LANE_BIT_SHIFT = _py_interop_metrics.base_metric_LANE_BIT_SHIFT
-
-    def __init__(self, lane=0, tile=0):
-        _py_interop_metrics.base_metric_swiginit(self, _py_interop_metrics.new_base_metric(lane, tile))
-
-    def set_base(self, lane, tile):
-        return _py_interop_metrics.base_metric_set_base(self, lane, tile)
-
-    def id(self):
-        return _py_interop_metrics.base_metric_id(self)
-
-    def tile_hash(self):
-        return _py_interop_metrics.base_metric_tile_hash(self)
-
-    @staticmethod
-    def create_id(lane, tile, arg3=0):
-        return _py_interop_metrics.base_metric_create_id(lane, tile, arg3)
-
-    @staticmethod
-    def lane_from_id(id):
-        return _py_interop_metrics.base_metric_lane_from_id(id)
-
-    @staticmethod
-    def tile_hash_from_id(id):
-        return _py_interop_metrics.base_metric_tile_hash_from_id(id)
-
-    @staticmethod
-    def tile_from_id(id):
-        return _py_interop_metrics.base_metric_tile_from_id(id)
-
-    def lane(self):
-        return _py_interop_metrics.base_metric_lane(self)
-
-    def tile(self):
-        return _py_interop_metrics.base_metric_tile(self)
-
-    def number(self, arg2):
-        return _py_interop_metrics.base_metric_number(self, arg2)
-
-    def section(self, method):
-        return _py_interop_metrics.base_metric_section(self, method)
-
-    def surface(self, method):
-        return _py_interop_metrics.base_metric_surface(self, method)
-
-    def swath(self, method):
-        return _py_interop_metrics.base_metric_swath(self, method)
-
-    def phyiscalLocationIndex(self, method, section_per_lane, tile_count, swath_count, all_surfaces):
-        return _py_interop_metrics.base_metric_phyiscalLocationIndex(self, method, section_per_lane, tile_count, swath_count, all_surfaces)
-
-    def phyiscalLocationColumn(self, method, swath_count, all_surfaces):
-        return _py_interop_metrics.base_metric_phyiscalLocationColumn(self, method, swath_count, all_surfaces)
-
-    def phyiscalLocationRow(self, method, section_per_lane, tile_count):
-        return _py_interop_metrics.base_metric_phyiscalLocationRow(self, method, section_per_lane, tile_count)
-
-    def physical_location_index(self, method, section_per_lane, tile_count, swath_count, all_surfaces):
-        return _py_interop_metrics.base_metric_physical_location_index(self, method, section_per_lane, tile_count, swath_count, all_surfaces)
-
-    def physical_location_column(self, method, swath_count, all_surfaces):
-        return _py_interop_metrics.base_metric_physical_location_column(self, method, swath_count, all_surfaces)
-
-    def physical_location_row(self, method, section_per_lane, tile_count):
-        return _py_interop_metrics.base_metric_physical_location_row(self, method, section_per_lane, tile_count)
-
-    @staticmethod
-    def suffix():
-        return _py_interop_metrics.base_metric_suffix()
-
-    def __lt__(self, metric2):
-        return _py_interop_metrics.base_metric___lt__(self, metric2)
-    __swig_destroy__ = _py_interop_metrics.delete_base_metric
-
-# Register base_metric in _py_interop_metrics:
-_py_interop_metrics.base_metric_swigregister(base_metric)
-class base_cycle_metric_header(empty_header):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self):
-        _py_interop_metrics.base_cycle_metric_header_swiginit(self, _py_interop_metrics.new_base_cycle_metric_header())
-
-    @staticmethod
-    def default_header():
-        return _py_interop_metrics.base_cycle_metric_header_default_header()
-
-    def max_cycle(self):
-        return _py_interop_metrics.base_cycle_metric_header_max_cycle(self)
-
-    def clear(self):
-        return _py_interop_metrics.base_cycle_metric_header_clear(self)
-    __swig_destroy__ = _py_interop_metrics.delete_base_cycle_metric_header
-
-# Register base_cycle_metric_header in _py_interop_metrics:
-_py_interop_metrics.base_cycle_metric_header_swigregister(base_cycle_metric_header)
-class base_cycle_metric(base_metric):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, lane=0, tile=0, cycle=0):
-        _py_interop_metrics.base_cycle_metric_swiginit(self, _py_interop_metrics.new_base_cycle_metric(lane, tile, cycle))
-
-    def set_base(self, *args):
-        return _py_interop_metrics.base_cycle_metric_set_base(self, *args)
-
-    def cycle(self):
-        return _py_interop_metrics.base_cycle_metric_cycle(self)
-
-    def id(self):
-        return _py_interop_metrics.base_cycle_metric_id(self)
-
-    def cycle_hash(self):
-        return _py_interop_metrics.base_cycle_metric_cycle_hash(self)
-
-    @staticmethod
-    def cycle_from_id(id):
-        return _py_interop_metrics.base_cycle_metric_cycle_from_id(id)
-
-    @staticmethod
-    def reserved_from_id(id):
-        return _py_interop_metrics.base_cycle_metric_reserved_from_id(id)
-
-    @staticmethod
-    def create_id(lane, tile, cycle):
-        return _py_interop_metrics.base_cycle_metric_create_id(lane, tile, cycle)
-
-    def __lt__(self, metric2):
-        return _py_interop_metrics.base_cycle_metric___lt__(self, metric2)
-    __swig_destroy__ = _py_interop_metrics.delete_base_cycle_metric
-
-# Register base_cycle_metric in _py_interop_metrics:
-_py_interop_metrics.base_cycle_metric_swigregister(base_cycle_metric)
-class base_read_metric_header(empty_header):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self):
-        _py_interop_metrics.base_read_metric_header_swiginit(self, _py_interop_metrics.new_base_read_metric_header())
-
-    @staticmethod
-    def default_header():
-        return _py_interop_metrics.base_read_metric_header_default_header()
-    __swig_destroy__ = _py_interop_metrics.delete_base_read_metric_header
-
-# Register base_read_metric_header in _py_interop_metrics:
-_py_interop_metrics.base_read_metric_header_swigregister(base_read_metric_header)
-class base_read_metric(base_metric):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, lane, tile, read):
-        _py_interop_metrics.base_read_metric_swiginit(self, _py_interop_metrics.new_base_read_metric(lane, tile, read))
-
-    def set_base(self, *args):
-        return _py_interop_metrics.base_read_metric_set_base(self, *args)
-
-    def read(self):
-        return _py_interop_metrics.base_read_metric_read(self)
-
-    def id(self):
-        return _py_interop_metrics.base_read_metric_id(self)
-
-    @staticmethod
-    def create_id(lane, tile, read):
-        return _py_interop_metrics.base_read_metric_create_id(lane, tile, read)
-
-    @staticmethod
-    def read_from_id(id):
-        return _py_interop_metrics.base_read_metric_read_from_id(id)
-
-    def __lt__(self, metric2):
-        return _py_interop_metrics.base_read_metric___lt__(self, metric2)
-    __swig_destroy__ = _py_interop_metrics.delete_base_read_metric
-
-# Register base_read_metric in _py_interop_metrics:
-_py_interop_metrics.base_read_metric_swigregister(base_read_metric)
-class point2d(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _py_interop_metrics.point2d_swiginit(self, _py_interop_metrics.new_point2d(*args))
-
-    def x(self):
-        return _py_interop_metrics.point2d_x(self)
-
-    def y(self):
-        return _py_interop_metrics.point2d_y(self)
-
-    def size_in_bytes(self):
-        return _py_interop_metrics.point2d_size_in_bytes(self)
-    __swig_destroy__ = _py_interop_metrics.delete_point2d
-
-# Register point2d in _py_interop_metrics:
-_py_interop_metrics.point2d_swigregister(point2d)
-class index_info_vector(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _py_interop_metrics.index_info_vector___nonzero__(self)
-
-    def __bool__(self):
-        return _py_interop_metrics.index_info_vector___bool__(self)
-
-    def __len__(self):
-        return _py_interop_metrics.index_info_vector___len__(self)
-
-    def __getslice__(self, i, j):
-        return _py_interop_metrics.index_info_vector___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _py_interop_metrics.index_info_vector___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _py_interop_metrics.index_info_vector___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _py_interop_metrics.index_info_vector___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _py_interop_metrics.index_info_vector___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _py_interop_metrics.index_info_vector___setitem__(self, *args)
-
-    def pop(self):
-        return _py_interop_metrics.index_info_vector_pop(self)
-
-    def append(self, x):
-        return _py_interop_metrics.index_info_vector_append(self, x)
-
-    def empty(self):
-        return _py_interop_metrics.index_info_vector_empty(self)
-
-    def size(self):
-        return _py_interop_metrics.index_info_vector_size(self)
-
-    def swap(self, v):
-        return _py_interop_metrics.index_info_vector_swap(self, v)
-
-    def rbegin(self):
-        return _py_interop_metrics.index_info_vector_rbegin(self)
-
-    def rend(self):
-        return _py_interop_metrics.index_info_vector_rend(self)
-
-    def clear(self):
-        return _py_interop_metrics.index_info_vector_clear(self)
-
-    def get_allocator(self):
-        return _py_interop_metrics.index_info_vector_get_allocator(self)
-
-    def pop_back(self):
-        return _py_interop_metrics.index_info_vector_pop_back(self)
-
-    def erase(self, *args):
-        return _py_interop_metrics.index_info_vector_erase(self, *args)
-
-    def __init__(self, *args):
-        _py_interop_metrics.index_info_vector_swiginit(self, _py_interop_metrics.new_index_info_vector(*args))
-
-    def push_back(self, x):
-        return _py_interop_metrics.index_info_vector_push_back(self, x)
-
-    def front(self):
-        return _py_interop_metrics.index_info_vector_front(self)
-
-    def back(self):
-        return _py_interop_metrics.index_info_vector_back(self)
-
-    def assign(self, n, x):
-        return _py_interop_metrics.index_info_vector_assign(self, n, x)
-
-    def resize(self, *args):
-        return _py_interop_metrics.index_info_vector_resize(self, *args)
-
-    def insert(self, *args):
-        return _py_interop_metrics.index_info_vector_insert(self, *args)
-
-    def reserve(self, n):
-        return _py_interop_metrics.index_info_vector_reserve(self, n)
-
-    def capacity(self):
-        return _py_interop_metrics.index_info_vector_capacity(self)
-    __swig_destroy__ = _py_interop_metrics.delete_index_info_vector
-
-# Register index_info_vector in _py_interop_metrics:
-_py_interop_metrics.index_info_vector_swigregister(index_info_vector)
-class tile_metric_map(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _py_interop_metrics.tile_metric_map___nonzero__(self)
-
-    def __bool__(self):
-        return _py_interop_metrics.tile_metric_map___bool__(self)
-
-    def __len__(self):
-        return _py_interop_metrics.tile_metric_map___len__(self)
-    def __iter__(self):
-        return self.key_iterator()
-    def iterkeys(self):
-        return self.key_iterator()
-    def itervalues(self):
-        return self.value_iterator()
-    def iteritems(self):
-        return self.iterator()
-
-    def __getitem__(self, key):
-        return _py_interop_metrics.tile_metric_map___getitem__(self, key)
-
-    def __delitem__(self, key):
-        return _py_interop_metrics.tile_metric_map___delitem__(self, key)
-
-    def has_key(self, key):
-        return _py_interop_metrics.tile_metric_map_has_key(self, key)
-
-    def keys(self):
-        return _py_interop_metrics.tile_metric_map_keys(self)
-
-    def values(self):
-        return _py_interop_metrics.tile_metric_map_values(self)
-
-    def items(self):
-        return _py_interop_metrics.tile_metric_map_items(self)
-
-    def __contains__(self, key):
-        return _py_interop_metrics.tile_metric_map___contains__(self, key)
-
-    def key_iterator(self):
-        return _py_interop_metrics.tile_metric_map_key_iterator(self)
-
-    def value_iterator(self):
-        return _py_interop_metrics.tile_metric_map_value_iterator(self)
-
-    def __setitem__(self, *args):
-        return _py_interop_metrics.tile_metric_map___setitem__(self, *args)
-
-    def asdict(self):
-        return _py_interop_metrics.tile_metric_map_asdict(self)
-
-    def __init__(self, *args):
-        _py_interop_metrics.tile_metric_map_swiginit(self, _py_interop_metrics.new_tile_metric_map(*args))
-
-    def empty(self):
-        return _py_interop_metrics.tile_metric_map_empty(self)
-
-    def size(self):
-        return _py_interop_metrics.tile_metric_map_size(self)
-
-    def swap(self, v):
-        return _py_interop_metrics.tile_metric_map_swap(self, v)
-
-    def rbegin(self):
-        return _py_interop_metrics.tile_metric_map_rbegin(self)
-
-    def rend(self):
-        return _py_interop_metrics.tile_metric_map_rend(self)
-
-    def clear(self):
-        return _py_interop_metrics.tile_metric_map_clear(self)
-
-    def get_allocator(self):
-        return _py_interop_metrics.tile_metric_map_get_allocator(self)
-
-    def count(self, x):
-        return _py_interop_metrics.tile_metric_map_count(self, x)
-
-    def erase(self, *args):
-        return _py_interop_metrics.tile_metric_map_erase(self, *args)
-
-    def find(self, x):
-        return _py_interop_metrics.tile_metric_map_find(self, x)
-
-    def lower_bound(self, x):
-        return _py_interop_metrics.tile_metric_map_lower_bound(self, x)
-
-    def upper_bound(self, x):
-        return _py_interop_metrics.tile_metric_map_upper_bound(self, x)
-    __swig_destroy__ = _py_interop_metrics.delete_tile_metric_map
-
-# Register tile_metric_map in _py_interop_metrics:
-_py_interop_metrics.tile_metric_map_swigregister(tile_metric_map)
-class cycle_metric_map(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _py_interop_metrics.cycle_metric_map___nonzero__(self)
-
-    def __bool__(self):
-        return _py_interop_metrics.cycle_metric_map___bool__(self)
-
-    def __len__(self):
-        return _py_interop_metrics.cycle_metric_map___len__(self)
-    def __iter__(self):
-        return self.key_iterator()
-    def iterkeys(self):
-        return self.key_iterator()
-    def itervalues(self):
-        return self.value_iterator()
-    def iteritems(self):
-        return self.iterator()
-
-    def __getitem__(self, key):
-        return _py_interop_metrics.cycle_metric_map___getitem__(self, key)
-
-    def __delitem__(self, key):
-        return _py_interop_metrics.cycle_metric_map___delitem__(self, key)
-
-    def has_key(self, key):
-        return _py_interop_metrics.cycle_metric_map_has_key(self, key)
-
-    def keys(self):
-        return _py_interop_metrics.cycle_metric_map_keys(self)
-
-    def values(self):
-        return _py_interop_metrics.cycle_metric_map_values(self)
-
-    def items(self):
-        return _py_interop_metrics.cycle_metric_map_items(self)
-
-    def __contains__(self, key):
-        return _py_interop_metrics.cycle_metric_map___contains__(self, key)
-
-    def key_iterator(self):
-        return _py_interop_metrics.cycle_metric_map_key_iterator(self)
-
-    def value_iterator(self):
-        return _py_interop_metrics.cycle_metric_map_value_iterator(self)
-
-    def __setitem__(self, *args):
-        return _py_interop_metrics.cycle_metric_map___setitem__(self, *args)
-
-    def asdict(self):
-        return _py_interop_metrics.cycle_metric_map_asdict(self)
-
-    def __init__(self, *args):
-        _py_interop_metrics.cycle_metric_map_swiginit(self, _py_interop_metrics.new_cycle_metric_map(*args))
-
-    def empty(self):
-        return _py_interop_metrics.cycle_metric_map_empty(self)
-
-    def size(self):
-        return _py_interop_metrics.cycle_metric_map_size(self)
-
-    def swap(self, v):
-        return _py_interop_metrics.cycle_metric_map_swap(self, v)
-
-    def rbegin(self):
-        return _py_interop_metrics.cycle_metric_map_rbegin(self)
-
-    def rend(self):
-        return _py_interop_metrics.cycle_metric_map_rend(self)
-
-    def clear(self):
-        return _py_interop_metrics.cycle_metric_map_clear(self)
-
-    def get_allocator(self):
-        return _py_interop_metrics.cycle_metric_map_get_allocator(self)
-
-    def count(self, x):
-        return _py_interop_metrics.cycle_metric_map_count(self, x)
-
-    def erase(self, *args):
-        return _py_interop_metrics.cycle_metric_map_erase(self, *args)
-
-    def find(self, x):
-        return _py_interop_metrics.cycle_metric_map_find(self, x)
-
-    def lower_bound(self, x):
-        return _py_interop_metrics.cycle_metric_map_lower_bound(self, x)
-
-    def upper_bound(self, x):
-        return _py_interop_metrics.cycle_metric_map_upper_bound(self, x)
-    __swig_destroy__ = _py_interop_metrics.delete_cycle_metric_map
-
-# Register cycle_metric_map in _py_interop_metrics:
-_py_interop_metrics.cycle_metric_map_swigregister(cycle_metric_map)
-class read_metric_vector(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _py_interop_metrics.read_metric_vector___nonzero__(self)
-
-    def __bool__(self):
-        return _py_interop_metrics.read_metric_vector___bool__(self)
-
-    def __len__(self):
-        return _py_interop_metrics.read_metric_vector___len__(self)
-
-    def __getslice__(self, i, j):
-        return _py_interop_metrics.read_metric_vector___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _py_interop_metrics.read_metric_vector___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _py_interop_metrics.read_metric_vector___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _py_interop_metrics.read_metric_vector___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _py_interop_metrics.read_metric_vector___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _py_interop_metrics.read_metric_vector___setitem__(self, *args)
-
-    def pop(self):
-        return _py_interop_metrics.read_metric_vector_pop(self)
-
-    def append(self, x):
-        return _py_interop_metrics.read_metric_vector_append(self, x)
-
-    def empty(self):
-        return _py_interop_metrics.read_metric_vector_empty(self)
-
-    def size(self):
-        return _py_interop_metrics.read_metric_vector_size(self)
-
-    def swap(self, v):
-        return _py_interop_metrics.read_metric_vector_swap(self, v)
-
-    def rbegin(self):
-        return _py_interop_metrics.read_metric_vector_rbegin(self)
-
-    def rend(self):
-        return _py_interop_metrics.read_metric_vector_rend(self)
-
-    def clear(self):
-        return _py_interop_metrics.read_metric_vector_clear(self)
-
-    def get_allocator(self):
-        return _py_interop_metrics.read_metric_vector_get_allocator(self)
-
-    def pop_back(self):
-        return _py_interop_metrics.read_metric_vector_pop_back(self)
-
-    def erase(self, *args):
-        return _py_interop_metrics.read_metric_vector_erase(self, *args)
-
-    def __init__(self, *args):
-        _py_interop_metrics.read_metric_vector_swiginit(self, _py_interop_metrics.new_read_metric_vector(*args))
-
-    def push_back(self, x):
-        return _py_interop_metrics.read_metric_vector_push_back(self, x)
-
-    def front(self):
-        return _py_interop_metrics.read_metric_vector_front(self)
-
-    def back(self):
-        return _py_interop_metrics.read_metric_vector_back(self)
-
-    def assign(self, n, x):
-        return _py_interop_metrics.read_metric_vector_assign(self, n, x)
-
-    def resize(self, *args):
-        return _py_interop_metrics.read_metric_vector_resize(self, *args)
-
-    def insert(self, *args):
-        return _py_interop_metrics.read_metric_vector_insert(self, *args)
-
-    def reserve(self, n):
-        return _py_interop_metrics.read_metric_vector_reserve(self, n)
-
-    def capacity(self):
-        return _py_interop_metrics.read_metric_vector_capacity(self)
-    __swig_destroy__ = _py_interop_metrics.delete_read_metric_vector
-
-# Register read_metric_vector in _py_interop_metrics:
-_py_interop_metrics.read_metric_vector_swigregister(read_metric_vector)
-class q_score_bin_vector(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _py_interop_metrics.q_score_bin_vector___nonzero__(self)
-
-    def __bool__(self):
-        return _py_interop_metrics.q_score_bin_vector___bool__(self)
-
-    def __len__(self):
-        return _py_interop_metrics.q_score_bin_vector___len__(self)
-
-    def __getslice__(self, i, j):
-        return _py_interop_metrics.q_score_bin_vector___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _py_interop_metrics.q_score_bin_vector___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _py_interop_metrics.q_score_bin_vector___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _py_interop_metrics.q_score_bin_vector___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _py_interop_metrics.q_score_bin_vector___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _py_interop_metrics.q_score_bin_vector___setitem__(self, *args)
-
-    def pop(self):
-        return _py_interop_metrics.q_score_bin_vector_pop(self)
-
-    def append(self, x):
-        return _py_interop_metrics.q_score_bin_vector_append(self, x)
-
-    def empty(self):
-        return _py_interop_metrics.q_score_bin_vector_empty(self)
-
-    def size(self):
-        return _py_interop_metrics.q_score_bin_vector_size(self)
-
-    def swap(self, v):
-        return _py_interop_metrics.q_score_bin_vector_swap(self, v)
-
-    def rbegin(self):
-        return _py_interop_metrics.q_score_bin_vector_rbegin(self)
-
-    def rend(self):
-        return _py_interop_metrics.q_score_bin_vector_rend(self)
-
-    def clear(self):
-        return _py_interop_metrics.q_score_bin_vector_clear(self)
-
-    def get_allocator(self):
-        return _py_interop_metrics.q_score_bin_vector_get_allocator(self)
-
-    def pop_back(self):
-        return _py_interop_metrics.q_score_bin_vector_pop_back(self)
-
-    def erase(self, *args):
-        return _py_interop_metrics.q_score_bin_vector_erase(self, *args)
-
-    def __init__(self, *args):
-        _py_interop_metrics.q_score_bin_vector_swiginit(self, _py_interop_metrics.new_q_score_bin_vector(*args))
-
-    def push_back(self, x):
-        return _py_interop_metrics.q_score_bin_vector_push_back(self, x)
-
-    def front(self):
-        return _py_interop_metrics.q_score_bin_vector_front(self)
-
-    def back(self):
-        return _py_interop_metrics.q_score_bin_vector_back(self)
-
-    def assign(self, n, x):
-        return _py_interop_metrics.q_score_bin_vector_assign(self, n, x)
-
-    def resize(self, *args):
-        return _py_interop_metrics.q_score_bin_vector_resize(self, *args)
-
-    def insert(self, *args):
-        return _py_interop_metrics.q_score_bin_vector_insert(self, *args)
-
-    def reserve(self, n):
-        return _py_interop_metrics.q_score_bin_vector_reserve(self, n)
-
-    def capacity(self):
-        return _py_interop_metrics.q_score_bin_vector_capacity(self)
-    __swig_destroy__ = _py_interop_metrics.delete_q_score_bin_vector
-
-# Register q_score_bin_vector in _py_interop_metrics:
-_py_interop_metrics.q_score_bin_vector_swigregister(q_score_bin_vector)
-class metric_type_name_pair(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _py_interop_metrics.metric_type_name_pair_swiginit(self, _py_interop_metrics.new_metric_type_name_pair(*args))
-    first = property(_py_interop_metrics.metric_type_name_pair_first_get, _py_interop_metrics.metric_type_name_pair_first_set)
-    second = property(_py_interop_metrics.metric_type_name_pair_second_get, _py_interop_metrics.metric_type_name_pair_second_set)
-    def __len__(self):
-        return 2
-    def __repr__(self):
-        return str((self.first, self.second))
-    def __getitem__(self, index): 
-        if not (index % 2):
-            return self.first
-        else:
-            return self.second
-    def __setitem__(self, index, val):
-        if not (index % 2):
-            self.first = val
-        else:
-            self.second = val
-    __swig_destroy__ = _py_interop_metrics.delete_metric_type_name_pair
-
-# Register metric_type_name_pair in _py_interop_metrics:
-_py_interop_metrics.metric_type_name_pair_swigregister(metric_type_name_pair)
-class metric_type_description(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _py_interop_metrics.metric_type_description_swiginit(self, _py_interop_metrics.new_metric_type_description(*args))
-
-    def value(self):
-        return _py_interop_metrics.metric_type_description_value(self)
-
-    def description(self):
-        return _py_interop_metrics.metric_type_description_description(self)
-    __swig_destroy__ = _py_interop_metrics.delete_metric_type_description
-
-# Register metric_type_description in _py_interop_metrics:
-_py_interop_metrics.metric_type_description_swigregister(metric_type_description)
-class metric_type_description_vector(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _py_interop_metrics.metric_type_description_vector___nonzero__(self)
-
-    def __bool__(self):
-        return _py_interop_metrics.metric_type_description_vector___bool__(self)
-
-    def __len__(self):
-        return _py_interop_metrics.metric_type_description_vector___len__(self)
-
-    def __getslice__(self, i, j):
-        return _py_interop_metrics.metric_type_description_vector___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _py_interop_metrics.metric_type_description_vector___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _py_interop_metrics.metric_type_description_vector___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _py_interop_metrics.metric_type_description_vector___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _py_interop_metrics.metric_type_description_vector___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _py_interop_metrics.metric_type_description_vector___setitem__(self, *args)
-
-    def pop(self):
-        return _py_interop_metrics.metric_type_description_vector_pop(self)
-
-    def append(self, x):
-        return _py_interop_metrics.metric_type_description_vector_append(self, x)
-
-    def empty(self):
-        return _py_interop_metrics.metric_type_description_vector_empty(self)
-
-    def size(self):
-        return _py_interop_metrics.metric_type_description_vector_size(self)
-
-    def swap(self, v):
-        return _py_interop_metrics.metric_type_description_vector_swap(self, v)
-
-    def rbegin(self):
-        return _py_interop_metrics.metric_type_description_vector_rbegin(self)
-
-    def rend(self):
-        return _py_interop_metrics.metric_type_description_vector_rend(self)
-
-    def clear(self):
-        return _py_interop_metrics.metric_type_description_vector_clear(self)
-
-    def get_allocator(self):
-        return _py_interop_metrics.metric_type_description_vector_get_allocator(self)
-
-    def pop_back(self):
-        return _py_interop_metrics.metric_type_description_vector_pop_back(self)
-
-    def erase(self, *args):
-        return _py_interop_metrics.metric_type_description_vector_erase(self, *args)
-
-    def __init__(self, *args):
-        _py_interop_metrics.metric_type_description_vector_swiginit(self, _py_interop_metrics.new_metric_type_description_vector(*args))
-
-    def push_back(self, x):
-        return _py_interop_metrics.metric_type_description_vector_push_back(self, x)
-
-    def front(self):
-        return _py_interop_metrics.metric_type_description_vector_front(self)
-
-    def back(self):
-        return _py_interop_metrics.metric_type_description_vector_back(self)
-
-    def assign(self, n, x):
-        return _py_interop_metrics.metric_type_description_vector_assign(self, n, x)
-
-    def resize(self, *args):
-        return _py_interop_metrics.metric_type_description_vector_resize(self, *args)
-
-    def insert(self, *args):
-        return _py_interop_metrics.metric_type_description_vector_insert(self, *args)
-
-    def reserve(self, n):
-        return _py_interop_metrics.metric_type_description_vector_reserve(self, n)
-
-    def capacity(self):
-        return _py_interop_metrics.metric_type_description_vector_capacity(self)
-    __swig_destroy__ = _py_interop_metrics.delete_metric_type_description_vector
-
-# Register metric_type_description_vector in _py_interop_metrics:
-_py_interop_metrics.metric_type_description_vector_swigregister(metric_type_description_vector)
-class metric_type_vector(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _py_interop_metrics.metric_type_vector___nonzero__(self)
-
-    def __bool__(self):
-        return _py_interop_metrics.metric_type_vector___bool__(self)
-
-    def __len__(self):
-        return _py_interop_metrics.metric_type_vector___len__(self)
-
-    def __getslice__(self, i, j):
-        return _py_interop_metrics.metric_type_vector___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _py_interop_metrics.metric_type_vector___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _py_interop_metrics.metric_type_vector___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _py_interop_metrics.metric_type_vector___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _py_interop_metrics.metric_type_vector___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _py_interop_metrics.metric_type_vector___setitem__(self, *args)
-
-    def pop(self):
-        return _py_interop_metrics.metric_type_vector_pop(self)
-
-    def append(self, x):
-        return _py_interop_metrics.metric_type_vector_append(self, x)
-
-    def empty(self):
-        return _py_interop_metrics.metric_type_vector_empty(self)
-
-    def size(self):
-        return _py_interop_metrics.metric_type_vector_size(self)
-
-    def swap(self, v):
-        return _py_interop_metrics.metric_type_vector_swap(self, v)
-
-    def rbegin(self):
-        return _py_interop_metrics.metric_type_vector_rbegin(self)
-
-    def rend(self):
-        return _py_interop_metrics.metric_type_vector_rend(self)
-
-    def clear(self):
-        return _py_interop_metrics.metric_type_vector_clear(self)
-
-    def get_allocator(self):
-        return _py_interop_metrics.metric_type_vector_get_allocator(self)
-
-    def pop_back(self):
-        return _py_interop_metrics.metric_type_vector_pop_back(self)
-
-    def erase(self, *args):
-        return _py_interop_metrics.metric_type_vector_erase(self, *args)
-
-    def __init__(self, *args):
-        _py_interop_metrics.metric_type_vector_swiginit(self, _py_interop_metrics.new_metric_type_vector(*args))
-
-    def push_back(self, x):
-        return _py_interop_metrics.metric_type_vector_push_back(self, x)
-
-    def front(self):
-        return _py_interop_metrics.metric_type_vector_front(self)
-
-    def back(self):
-        return _py_interop_metrics.metric_type_vector_back(self)
-
-    def assign(self, n, x):
-        return _py_interop_metrics.metric_type_vector_assign(self, n, x)
-
-    def resize(self, *args):
-        return _py_interop_metrics.metric_type_vector_resize(self, *args)
-
-    def insert(self, *args):
-        return _py_interop_metrics.metric_type_vector_insert(self, *args)
-
-    def reserve(self, n):
-        return _py_interop_metrics.metric_type_vector_reserve(self, n)
-
-    def capacity(self):
-        return _py_interop_metrics.metric_type_vector_capacity(self)
-    __swig_destroy__ = _py_interop_metrics.delete_metric_type_vector
-
-# Register metric_type_vector in _py_interop_metrics:
-_py_interop_metrics.metric_type_vector_swigregister(metric_type_vector)
-class metric_group_vector(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _py_interop_metrics.metric_group_vector___nonzero__(self)
-
-    def __bool__(self):
-        return _py_interop_metrics.metric_group_vector___bool__(self)
-
-    def __len__(self):
-        return _py_interop_metrics.metric_group_vector___len__(self)
-
-    def __getslice__(self, i, j):
-        return _py_interop_metrics.metric_group_vector___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _py_interop_metrics.metric_group_vector___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _py_interop_metrics.metric_group_vector___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _py_interop_metrics.metric_group_vector___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _py_interop_metrics.metric_group_vector___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _py_interop_metrics.metric_group_vector___setitem__(self, *args)
-
-    def pop(self):
-        return _py_interop_metrics.metric_group_vector_pop(self)
-
-    def append(self, x):
-        return _py_interop_metrics.metric_group_vector_append(self, x)
-
-    def empty(self):
-        return _py_interop_metrics.metric_group_vector_empty(self)
-
-    def size(self):
-        return _py_interop_metrics.metric_group_vector_size(self)
-
-    def swap(self, v):
-        return _py_interop_metrics.metric_group_vector_swap(self, v)
-
-    def rbegin(self):
-        return _py_interop_metrics.metric_group_vector_rbegin(self)
-
-    def rend(self):
-        return _py_interop_metrics.metric_group_vector_rend(self)
-
-    def clear(self):
-        return _py_interop_metrics.metric_group_vector_clear(self)
-
-    def get_allocator(self):
-        return _py_interop_metrics.metric_group_vector_get_allocator(self)
-
-    def pop_back(self):
-        return _py_interop_metrics.metric_group_vector_pop_back(self)
-
-    def erase(self, *args):
-        return _py_interop_metrics.metric_group_vector_erase(self, *args)
-
-    def __init__(self, *args):
-        _py_interop_metrics.metric_group_vector_swiginit(self, _py_interop_metrics.new_metric_group_vector(*args))
-
-    def push_back(self, x):
-        return _py_interop_metrics.metric_group_vector_push_back(self, x)
-
-    def front(self):
-        return _py_interop_metrics.metric_group_vector_front(self)
-
-    def back(self):
-        return _py_interop_metrics.metric_group_vector_back(self)
-
-    def assign(self, n, x):
-        return _py_interop_metrics.metric_group_vector_assign(self, n, x)
-
-    def resize(self, *args):
-        return _py_interop_metrics.metric_group_vector_resize(self, *args)
-
-    def insert(self, *args):
-        return _py_interop_metrics.metric_group_vector_insert(self, *args)
-
-    def reserve(self, n):
-        return _py_interop_metrics.metric_group_vector_reserve(self, n)
-
-    def capacity(self):
-        return _py_interop_metrics.metric_group_vector_capacity(self)
-    __swig_destroy__ = _py_interop_metrics.delete_metric_group_vector
-
-# Register metric_group_vector in _py_interop_metrics:
-_py_interop_metrics.metric_group_vector_swigregister(metric_group_vector)
-class corrected_intensity_metric(base_cycle_metric):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    TYPE = _py_interop_metrics.corrected_intensity_metric_TYPE
-    LATEST_VERSION = _py_interop_metrics.corrected_intensity_metric_LATEST_VERSION
-
-    def __init__(self, *args):
-        _py_interop_metrics.corrected_intensity_metric_swiginit(self, _py_interop_metrics.new_corrected_intensity_metric(*args))
-
-    def set(self, lane, tile, cycle, called_counts):
-        return _py_interop_metrics.corrected_intensity_metric_set(self, lane, tile, cycle, called_counts)
-
-    def average_cycle_intensity(self):
-        return _py_interop_metrics.corrected_intensity_metric_average_cycle_intensity(self)
-
-    def corrected_int_all(self, index):
-        return _py_interop_metrics.corrected_intensity_metric_corrected_int_all(self, index)
-
-    def corrected_int_all_float(self, index):
-        return _py_interop_metrics.corrected_intensity_metric_corrected_int_all_float(self, index)
-
-    def corrected_int_called(self, index):
-        return _py_interop_metrics.corrected_intensity_metric_corrected_int_called(self, index)
-
-    def called_counts_array(self):
-        return _py_interop_metrics.corrected_intensity_metric_called_counts_array(self)
-
-    def corrected_int_all_array(self):
-        return _py_interop_metrics.corrected_intensity_metric_corrected_int_all_array(self)
-
-    def called_counts(self, index):
-        return _py_interop_metrics.corrected_intensity_metric_called_counts(self, index)
-
-    def no_calls(self):
-        return _py_interop_metrics.corrected_intensity_metric_no_calls(self)
-
-    def signal_to_noise(self):
-        return _py_interop_metrics.corrected_intensity_metric_signal_to_noise(self)
-
-    def total_calls(self, nocalls=False):
-        return _py_interop_metrics.corrected_intensity_metric_total_calls(self, nocalls)
-
-    def total_intensity(self):
-        return _py_interop_metrics.corrected_intensity_metric_total_intensity(self)
-
-    def total_called_intensity(self):
-        return _py_interop_metrics.corrected_intensity_metric_total_called_intensity(self)
-
-    def percent_base(self, index):
-        return _py_interop_metrics.corrected_intensity_metric_percent_base(self, index)
-
-    def percent_bases(self):
-        return _py_interop_metrics.corrected_intensity_metric_percent_bases(self)
-
-    def percent_nocall(self):
-        return _py_interop_metrics.corrected_intensity_metric_percent_nocall(self)
-
-    def corrected_int_called_array(self, *args):
-        return _py_interop_metrics.corrected_intensity_metric_corrected_int_called_array(self, *args)
-
-    def any_valid_called_int(self):
-        return _py_interop_metrics.corrected_intensity_metric_any_valid_called_int(self)
-
-    def averageCycleIntensity(self):
-        return _py_interop_metrics.corrected_intensity_metric_averageCycleIntensity(self)
-
-    def correctedIntCalled(self, *args):
-        return _py_interop_metrics.corrected_intensity_metric_correctedIntCalled(self, *args)
-
-    def correctedIntAll(self, *args):
-        return _py_interop_metrics.corrected_intensity_metric_correctedIntAll(self, *args)
-
-    def noCalls(self):
-        return _py_interop_metrics.corrected_intensity_metric_noCalls(self)
-
-    def percentBase(self, index):
-        return _py_interop_metrics.corrected_intensity_metric_percentBase(self, index)
-
-    def calledCounts(self, *args):
-        return _py_interop_metrics.corrected_intensity_metric_calledCounts(self, *args)
-
-    def signalToNoise(self):
-        return _py_interop_metrics.corrected_intensity_metric_signalToNoise(self)
-
-    def totalCalls(self, nocalls=False):
-        return _py_interop_metrics.corrected_intensity_metric_totalCalls(self, nocalls)
-
-    def totalIntensity(self):
-        return _py_interop_metrics.corrected_intensity_metric_totalIntensity(self)
-
-    def totalCalledIntensity(self):
-        return _py_interop_metrics.corrected_intensity_metric_totalCalledIntensity(self)
-
-    def percentIntensity(self, index):
-        return _py_interop_metrics.corrected_intensity_metric_percentIntensity(self, index)
-
-    def percentCalledIntensity(self, index):
-        return _py_interop_metrics.corrected_intensity_metric_percentCalledIntensity(self, index)
-
-    @staticmethod
-    def prefix():
-        return _py_interop_metrics.corrected_intensity_metric_prefix()
-    __swig_destroy__ = _py_interop_metrics.delete_corrected_intensity_metric
-
-# Register corrected_intensity_metric in _py_interop_metrics:
-_py_interop_metrics.corrected_intensity_metric_swigregister(corrected_intensity_metric)
-class error_metric_header(base_cycle_metric_header):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _py_interop_metrics.error_metric_header_swiginit(self, _py_interop_metrics.new_error_metric_header(*args))
-
-    def number_adapters(self):
-        return _py_interop_metrics.error_metric_header_number_adapters(self)
-
-    def adapter_length(self):
-        return _py_interop_metrics.error_metric_header_adapter_length(self)
-
-    def adapter_sequences(self):
-        return _py_interop_metrics.error_metric_header_adapter_sequences(self)
-
-    def clear(self):
-        return _py_interop_metrics.error_metric_header_clear(self)
-
-    @staticmethod
-    def default_header():
-        return _py_interop_metrics.error_metric_header_default_header()
-    __swig_destroy__ = _py_interop_metrics.delete_error_metric_header
-
-# Register error_metric_header in _py_interop_metrics:
-_py_interop_metrics.error_metric_header_swigregister(error_metric_header)
-class error_metric(base_cycle_metric):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    MAX_MISMATCH = _py_interop_metrics.error_metric_MAX_MISMATCH
-    TYPE = _py_interop_metrics.error_metric_TYPE
-    LATEST_VERSION = _py_interop_metrics.error_metric_LATEST_VERSION
-
-    def __init__(self, *args):
-        _py_interop_metrics.error_metric_swiginit(self, _py_interop_metrics.new_error_metric(*args))
-
-    def error_rate(self):
-        return _py_interop_metrics.error_metric_error_rate(self)
-
-    def phix_adapter_rate(self):
-        return _py_interop_metrics.error_metric_phix_adapter_rate(self)
-
-    def phix_adapter_rates(self):
-        return _py_interop_metrics.error_metric_phix_adapter_rates(self)
-
-    def phix_adapter_rate_at(self, n):
-        return _py_interop_metrics.error_metric_phix_adapter_rate_at(self, n)
-
-    def phix_adapter_count(self):
-        return _py_interop_metrics.error_metric_phix_adapter_count(self)
-
-    def mismatch_cluster_count(self, n):
-        return _py_interop_metrics.error_metric_mismatch_cluster_count(self, n)
-
-    def mismatch_count(self):
-        return _py_interop_metrics.error_metric_mismatch_count(self)
-
-    def mismatch_cluster_counts(self):
-        return _py_interop_metrics.error_metric_mismatch_cluster_counts(self)
-
-    def errorRate(self):
-        return _py_interop_metrics.error_metric_errorRate(self)
-
-    @staticmethod
-    def prefix():
-        return _py_interop_metrics.error_metric_prefix()
-    __swig_destroy__ = _py_interop_metrics.delete_error_metric
-
-# Register error_metric in _py_interop_metrics:
-_py_interop_metrics.error_metric_swigregister(error_metric)
-class extended_tile_metric(base_metric):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    TYPE = _py_interop_metrics.extended_tile_metric_TYPE
-    LATEST_VERSION = _py_interop_metrics.extended_tile_metric_LATEST_VERSION
-
-    def __init__(self, *args):
-        _py_interop_metrics.extended_tile_metric_swiginit(self, _py_interop_metrics.new_extended_tile_metric(*args))
-
-    def set(self, *args):
-        return _py_interop_metrics.extended_tile_metric_set(self, *args)
-
-    def cluster_count_occupied(self):
-        return _py_interop_metrics.extended_tile_metric_cluster_count_occupied(self)
-
-    def cluster_count_occupied_k(self):
-        return _py_interop_metrics.extended_tile_metric_cluster_count_occupied_k(self)
-
-    def percent_occupied(self):
-        return _py_interop_metrics.extended_tile_metric_percent_occupied(self)
-
-    def upper_left(self):
-        return _py_interop_metrics.extended_tile_metric_upper_left(self)
-
-    def set_cluster_count_k(self, cluster_count_k):
-        return _py_interop_metrics.extended_tile_metric_set_cluster_count_k(self, cluster_count_k)
-
-    @staticmethod
-    def prefix():
-        return _py_interop_metrics.extended_tile_metric_prefix()
-    __swig_destroy__ = _py_interop_metrics.delete_extended_tile_metric
-
-# Register extended_tile_metric in _py_interop_metrics:
-_py_interop_metrics.extended_tile_metric_swigregister(extended_tile_metric)
-class extraction_metric_header(base_cycle_metric_header):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    MAX_CHANNELS = _py_interop_metrics.extraction_metric_header_MAX_CHANNELS
-
-    def __init__(self, channel_count):
-        _py_interop_metrics.extraction_metric_header_swiginit(self, _py_interop_metrics.new_extraction_metric_header(channel_count))
-
-    def channel_count(self, *args):
-        return _py_interop_metrics.extraction_metric_header_channel_count(self, *args)
-
-    @staticmethod
-    def default_header():
-        return _py_interop_metrics.extraction_metric_header_default_header()
-
-    def clear(self):
-        return _py_interop_metrics.extraction_metric_header_clear(self)
-    __swig_destroy__ = _py_interop_metrics.delete_extraction_metric_header
-
-# Register extraction_metric_header in _py_interop_metrics:
-_py_interop_metrics.extraction_metric_header_swigregister(extraction_metric_header)
-class extraction_metric(base_cycle_metric):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    MAX_CHANNELS = _py_interop_metrics.extraction_metric_MAX_CHANNELS
-    TYPE = _py_interop_metrics.extraction_metric_TYPE
-    LATEST_VERSION = _py_interop_metrics.extraction_metric_LATEST_VERSION
-
-    def __init__(self, *args):
-        _py_interop_metrics.extraction_metric_swiginit(self, _py_interop_metrics.new_extraction_metric(*args))
-
-    def set(self, *args):
-        return _py_interop_metrics.extraction_metric_set(self, *args)
-
-    def date_time_csharp(self):
-        return _py_interop_metrics.extraction_metric_date_time_csharp(self)
-
-    def date_time_csharp_raw(self):
-        return _py_interop_metrics.extraction_metric_date_time_csharp_raw(self)
-
-    def max_intensity(self, channel):
-        return _py_interop_metrics.extraction_metric_max_intensity(self, channel)
-
-    def focus_score(self, channel):
-        return _py_interop_metrics.extraction_metric_focus_score(self, channel)
-
-    def max_intensity_values(self):
-        return _py_interop_metrics.extraction_metric_max_intensity_values(self)
-
-    def focus_scores(self):
-        return _py_interop_metrics.extraction_metric_focus_scores(self)
-
-    def channel_count(self):
-        return _py_interop_metrics.extraction_metric_channel_count(self)
-
-    def trim(self, channel_count):
-        return _py_interop_metrics.extraction_metric_trim(self, channel_count)
-
-    def focusScore(self, channel):
-        return _py_interop_metrics.extraction_metric_focusScore(self, channel)
-
-    def dateTime(self):
-        return _py_interop_metrics.extraction_metric_dateTime(self)
-
-    def focusScores(self):
-        return _py_interop_metrics.extraction_metric_focusScores(self)
-
-    def date_time(self, *args):
-        return _py_interop_metrics.extraction_metric_date_time(self, *args)
-
-    def is_any_p90_zero(self):
-        return _py_interop_metrics.extraction_metric_is_any_p90_zero(self)
-
-    @staticmethod
-    def prefix():
-        return _py_interop_metrics.extraction_metric_prefix()
-    __swig_destroy__ = _py_interop_metrics.delete_extraction_metric
-
-# Register extraction_metric in _py_interop_metrics:
-_py_interop_metrics.extraction_metric_swigregister(extraction_metric)
-class image_metric_header(base_cycle_metric_header):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    MAX_CHANNELS = _py_interop_metrics.image_metric_header_MAX_CHANNELS
-
-    def __init__(self, channel_count):
-        _py_interop_metrics.image_metric_header_swiginit(self, _py_interop_metrics.new_image_metric_header(channel_count))
-
-    def channelCount(self):
-        return _py_interop_metrics.image_metric_header_channelCount(self)
-
-    def channel_count(self, *args):
-        return _py_interop_metrics.image_metric_header_channel_count(self, *args)
-
-    @staticmethod
-    def default_header():
-        return _py_interop_metrics.image_metric_header_default_header()
-
-    def clear(self):
-        return _py_interop_metrics.image_metric_header_clear(self)
-    __swig_destroy__ = _py_interop_metrics.delete_image_metric_header
-
-# Register image_metric_header in _py_interop_metrics:
-_py_interop_metrics.image_metric_header_swigregister(image_metric_header)
-class image_metric(base_cycle_metric):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    MAX_CHANNELS = _py_interop_metrics.image_metric_MAX_CHANNELS
-    TYPE = _py_interop_metrics.image_metric_TYPE
-    LATEST_VERSION = _py_interop_metrics.image_metric_LATEST_VERSION
-
-    def __init__(self, *args):
-        _py_interop_metrics.image_metric_swiginit(self, _py_interop_metrics.new_image_metric(*args))
-
-    def min_contrast(self, channel):
-        return _py_interop_metrics.image_metric_min_contrast(self, channel)
-
-    def max_contrast(self, channel):
-        return _py_interop_metrics.image_metric_max_contrast(self, channel)
-
-    def min_contrast_array(self):
-        return _py_interop_metrics.image_metric_min_contrast_array(self)
-
-    def max_contrast_array(self):
-        return _py_interop_metrics.image_metric_max_contrast_array(self)
-
-    def channel_count(self):
-        return _py_interop_metrics.image_metric_channel_count(self)
-
-    def is_any_channel_blank(self):
-        return _py_interop_metrics.image_metric_is_any_channel_blank(self)
-
-    def trim(self, channel_count):
-        return _py_interop_metrics.image_metric_trim(self, channel_count)
-
-    def minContrast(self, *args):
-        return _py_interop_metrics.image_metric_minContrast(self, *args)
-
-    def maxContrast(self, *args):
-        return _py_interop_metrics.image_metric_maxContrast(self, *args)
-
-    def channelCount(self):
-        return _py_interop_metrics.image_metric_channelCount(self)
-
-    @staticmethod
-    def prefix():
-        return _py_interop_metrics.image_metric_prefix()
-    __swig_destroy__ = _py_interop_metrics.delete_image_metric
-
-# Register image_metric in _py_interop_metrics:
-_py_interop_metrics.image_metric_swigregister(image_metric)
-class q_score_bin(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, lower=0, upper=0, value=0):
-        _py_interop_metrics.q_score_bin_swiginit(self, _py_interop_metrics.new_q_score_bin(lower, upper, value))
-
-    def lower(self):
-        return _py_interop_metrics.q_score_bin_lower(self)
-
-    def upper(self):
-        return _py_interop_metrics.q_score_bin_upper(self)
-
-    def value(self):
-        return _py_interop_metrics.q_score_bin_value(self)
-    __swig_destroy__ = _py_interop_metrics.delete_q_score_bin
-
-# Register q_score_bin in _py_interop_metrics:
-_py_interop_metrics.q_score_bin_swigregister(q_score_bin)
-class q_score_header(base_cycle_metric_header):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    MAX_Q_BINS = _py_interop_metrics.q_score_header_MAX_Q_BINS
-
-    def __init__(self, *args):
-        _py_interop_metrics.q_score_header_swiginit(self, _py_interop_metrics.new_q_score_header(*args))
-
-    def bin_at(self, n):
-        return _py_interop_metrics.q_score_header_bin_at(self, n)
-
-    def get_bins(self):
-        return _py_interop_metrics.q_score_header_get_bins(self)
-
-    def bins(self):
-        return _py_interop_metrics.q_score_header_bins(self)
-
-    def bin_count(self):
-        return _py_interop_metrics.q_score_header_bin_count(self)
-
-    def q_val_count(self):
-        return _py_interop_metrics.q_score_header_q_val_count(self)
-
-    def index_for_q_value(self, qval):
-        return _py_interop_metrics.q_score_header_index_for_q_value(self, qval)
-
-    def binCount(self):
-        return _py_interop_metrics.q_score_header_binCount(self)
-
-    @staticmethod
-    def default_header():
-        return _py_interop_metrics.q_score_header_default_header()
-
-    def binAt(self, n):
-        return _py_interop_metrics.q_score_header_binAt(self, n)
-
-    def clear(self):
-        return _py_interop_metrics.q_score_header_clear(self)
-    __swig_destroy__ = _py_interop_metrics.delete_q_score_header
-
-# Register q_score_header in _py_interop_metrics:
-_py_interop_metrics.q_score_header_swigregister(q_score_header)
-class q_metric(base_cycle_metric):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    TYPE = _py_interop_metrics.q_metric_TYPE
-    LATEST_VERSION = _py_interop_metrics.q_metric_LATEST_VERSION
-    MAX_Q_BINS = _py_interop_metrics.q_metric_MAX_Q_BINS
-
-    def __init__(self, *args):
-        _py_interop_metrics.q_metric_swiginit(self, _py_interop_metrics.new_q_metric(*args))
-
-    def set(self, lane, tile, cycle, qscore_hist):
-        return _py_interop_metrics.q_metric_set(self, lane, tile, cycle, qscore_hist)
-
-    def qscore_hist(self, *args):
-        return _py_interop_metrics.q_metric_qscore_hist(self, *args)
-
-    def size(self):
-        return _py_interop_metrics.q_metric_size(self)
-
-    def sum_qscore(self):
-        return _py_interop_metrics.q_metric_sum_qscore(self)
-
-    def sum_qscore_cumulative(self):
-        return _py_interop_metrics.q_metric_sum_qscore_cumulative(self)
-
-    def total_over_qscore(self, *args):
-        return _py_interop_metrics.q_metric_total_over_qscore(self, *args)
-
-    def total_over_qscore_cumulative(self, *args):
-        return _py_interop_metrics.q_metric_total_over_qscore_cumulative(self, *args)
-
-    def percent_over_qscore(self, *args):
-        return _py_interop_metrics.q_metric_percent_over_qscore(self, *args)
-
-    def percent_over_qscore_cumulative(self, *args):
-        return _py_interop_metrics.q_metric_percent_over_qscore_cumulative(self, *args)
-
-    def median(self, *args):
-        return _py_interop_metrics.q_metric_median(self, *args)
-
-    def is_cumulative_empty(self):
-        return _py_interop_metrics.q_metric_is_cumulative_empty(self)
-
-    def accumulate(self, metric):
-        return _py_interop_metrics.q_metric_accumulate(self, metric)
-
-    def compress(self, header):
-        return _py_interop_metrics.q_metric_compress(self, header)
-
-    def qscoreHist(self, *args):
-        return _py_interop_metrics.q_metric_qscoreHist(self, *args)
-
-    @staticmethod
-    def prefix():
-        return _py_interop_metrics.q_metric_prefix()
-    __swig_destroy__ = _py_interop_metrics.delete_q_metric
-
-# Register q_metric in _py_interop_metrics:
-_py_interop_metrics.q_metric_swigregister(q_metric)
-class tile_metric_header(base_metric_header):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, density):
-        _py_interop_metrics.tile_metric_header_swiginit(self, _py_interop_metrics.new_tile_metric_header(density))
-
-    def density(self):
-        return _py_interop_metrics.tile_metric_header_density(self)
-
-    @staticmethod
-    def default_header():
-        return _py_interop_metrics.tile_metric_header_default_header()
-
-    def clear(self):
-        return _py_interop_metrics.tile_metric_header_clear(self)
-    __swig_destroy__ = _py_interop_metrics.delete_tile_metric_header
-
-# Register tile_metric_header in _py_interop_metrics:
-_py_interop_metrics.tile_metric_header_swigregister(tile_metric_header)
-class read_metric(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _py_interop_metrics.read_metric_swiginit(self, _py_interop_metrics.new_read_metric(*args))
-
-    def read(self):
-        return _py_interop_metrics.read_metric_read(self)
-
-    def percent_aligned(self, *args):
-        return _py_interop_metrics.read_metric_percent_aligned(self, *args)
-
-    def percent_phasing(self, *args):
-        return _py_interop_metrics.read_metric_percent_phasing(self, *args)
-
-    def percent_prephasing(self, *args):
-        return _py_interop_metrics.read_metric_percent_prephasing(self, *args)
-    __swig_destroy__ = _py_interop_metrics.delete_read_metric
-
-# Register read_metric in _py_interop_metrics:
-_py_interop_metrics.read_metric_swigregister(read_metric)
-class tile_metric(base_metric):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    TYPE = _py_interop_metrics.tile_metric_TYPE
-    LATEST_VERSION = _py_interop_metrics.tile_metric_LATEST_VERSION
-
-    def __init__(self, *args):
-        _py_interop_metrics.tile_metric_swiginit(self, _py_interop_metrics.new_tile_metric(*args))
-
-    def cluster_density(self):
-        return _py_interop_metrics.tile_metric_cluster_density(self)
-
-    def cluster_density_k(self):
-        return _py_interop_metrics.tile_metric_cluster_density_k(self)
-
-    def cluster_density_pf(self):
-        return _py_interop_metrics.tile_metric_cluster_density_pf(self)
-
-    def cluster_density_pf_k(self):
-        return _py_interop_metrics.tile_metric_cluster_density_pf_k(self)
-
-    def cluster_count(self):
-        return _py_interop_metrics.tile_metric_cluster_count(self)
-
-    def cluster_count_k(self):
-        return _py_interop_metrics.tile_metric_cluster_count_k(self)
-
-    def cluster_count_m(self):
-        return _py_interop_metrics.tile_metric_cluster_count_m(self)
-
-    def cluster_count_pf(self):
-        return _py_interop_metrics.tile_metric_cluster_count_pf(self)
-
-    def cluster_count_pf_k(self):
-        return _py_interop_metrics.tile_metric_cluster_count_pf_k(self)
-
-    def cluster_count_pf_m(self):
-        return _py_interop_metrics.tile_metric_cluster_count_pf_m(self)
-
-    def percent_pf(self):
-        return _py_interop_metrics.tile_metric_percent_pf(self)
-
-    def read_metrics(self):
-        return _py_interop_metrics.tile_metric_read_metrics(self)
-
-    def percent_aligned(self, n):
-        return _py_interop_metrics.tile_metric_percent_aligned(self, n)
-
-    def percent_phasing(self, n):
-        return _py_interop_metrics.tile_metric_percent_phasing(self, n)
-
-    def percent_prephasing(self, n):
-        return _py_interop_metrics.tile_metric_percent_prephasing(self, n)
-
-    def percent_aligned_at(self, number):
-        return _py_interop_metrics.tile_metric_percent_aligned_at(self, number)
-
-    def percent_phasing_at(self, number):
-        return _py_interop_metrics.tile_metric_percent_phasing_at(self, number)
-
-    def percent_prephasing_at(self, number):
-        return _py_interop_metrics.tile_metric_percent_prephasing_at(self, number)
-
-    def read_count(self):
-        return _py_interop_metrics.tile_metric_read_count(self)
-
-    def is_dead_tile(self):
-        return _py_interop_metrics.tile_metric_is_dead_tile(self)
-
-    def update_phasing_if_missing(self, number, phasing, prephasing):
-        return _py_interop_metrics.tile_metric_update_phasing_if_missing(self, number, phasing, prephasing)
-
-    def clusterDensity(self):
-        return _py_interop_metrics.tile_metric_clusterDensity(self)
-
-    def clusterDensityPf(self):
-        return _py_interop_metrics.tile_metric_clusterDensityPf(self)
-
-    def clusterCount(self):
-        return _py_interop_metrics.tile_metric_clusterCount(self)
-
-    def clusterCountPf(self):
-        return _py_interop_metrics.tile_metric_clusterCountPf(self)
-
-    @staticmethod
-    def prefix():
-        return _py_interop_metrics.tile_metric_prefix()
-    __swig_destroy__ = _py_interop_metrics.delete_tile_metric
-
-# Register tile_metric in _py_interop_metrics:
-_py_interop_metrics.tile_metric_swigregister(tile_metric)
-class index_info(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _py_interop_metrics.index_info_swiginit(self, _py_interop_metrics.new_index_info(*args))
-
-    def index_seq(self):
-        return _py_interop_metrics.index_info_index_seq(self)
-
-    def sample_id(self):
-        return _py_interop_metrics.index_info_sample_id(self)
-
-    def sample_proj(self):
-        return _py_interop_metrics.index_info_sample_proj(self)
-
-    def cluster_count(self):
-        return _py_interop_metrics.index_info_cluster_count(self)
-
-    def is_dual(self):
-        return _py_interop_metrics.index_info_is_dual(self)
-
-    def index1(self):
-        return _py_interop_metrics.index_info_index1(self)
-
-    def index2(self):
-        return _py_interop_metrics.index_info_index2(self)
-
-    def unique_id(self):
-        return _py_interop_metrics.index_info_unique_id(self)
-    __swig_destroy__ = _py_interop_metrics.delete_index_info
-
-# Register index_info in _py_interop_metrics:
-_py_interop_metrics.index_info_swigregister(index_info)
-class index_metric_header(base_read_metric_header):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self):
-        _py_interop_metrics.index_metric_header_swiginit(self, _py_interop_metrics.new_index_metric_header())
-
-    def index_order(self, *args):
-        return _py_interop_metrics.index_metric_header_index_order(self, *args)
-
-    @staticmethod
-    def default_header():
-        return _py_interop_metrics.index_metric_header_default_header()
-
-    def clear(self):
-        return _py_interop_metrics.index_metric_header_clear(self)
-    __swig_destroy__ = _py_interop_metrics.delete_index_metric_header
-
-# Register index_metric_header in _py_interop_metrics:
-_py_interop_metrics.index_metric_header_swigregister(index_metric_header)
-class index_metric(base_read_metric):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    TYPE = _py_interop_metrics.index_metric_TYPE
-    LATEST_VERSION = _py_interop_metrics.index_metric_LATEST_VERSION
-
-    def __init__(self, *args):
-        _py_interop_metrics.index_metric_swiginit(self, _py_interop_metrics.new_index_metric(*args))
-
-    def size(self):
-        return _py_interop_metrics.index_metric_size(self)
-
-    def indices(self, *args):
-        return _py_interop_metrics.index_metric_indices(self, *args)
-
-    def cluster_count(self):
-        return _py_interop_metrics.index_metric_cluster_count(self)
-
-    def cluster_count_pf(self):
-        return _py_interop_metrics.index_metric_cluster_count_pf(self)
-
-    def set_cluster_counts(self, cluster_count, cluster_count_pf):
-        return _py_interop_metrics.index_metric_set_cluster_counts(self, cluster_count, cluster_count_pf)
-
-    @staticmethod
-    def prefix():
-        return _py_interop_metrics.index_metric_prefix()
-
-    def percent_demultiplexed(self, sample_id):
-        return _py_interop_metrics.index_metric_percent_demultiplexed(self, sample_id)
-    __swig_destroy__ = _py_interop_metrics.delete_index_metric
-
-# Register index_metric in _py_interop_metrics:
-_py_interop_metrics.index_metric_swigregister(index_metric)
-class q_collapsed_header(q_score_header):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _py_interop_metrics.q_collapsed_header_swiginit(self, _py_interop_metrics.new_q_collapsed_header(*args))
-
-    @staticmethod
-    def default_header():
-        return _py_interop_metrics.q_collapsed_header_default_header()
-
-    def clear(self):
-        return _py_interop_metrics.q_collapsed_header_clear(self)
-    __swig_destroy__ = _py_interop_metrics.delete_q_collapsed_header
-
-# Register q_collapsed_header in _py_interop_metrics:
-_py_interop_metrics.q_collapsed_header_swigregister(q_collapsed_header)
-class q_collapsed_metric(base_cycle_metric):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    TYPE = _py_interop_metrics.q_collapsed_metric_TYPE
-    LATEST_VERSION = _py_interop_metrics.q_collapsed_metric_LATEST_VERSION
-
-    def __init__(self, *args):
-        _py_interop_metrics.q_collapsed_metric_swiginit(self, _py_interop_metrics.new_q_collapsed_metric(*args))
-
-    def q20(self):
-        return _py_interop_metrics.q_collapsed_metric_q20(self)
-
-    def q30(self):
-        return _py_interop_metrics.q_collapsed_metric_q30(self)
-
-    def total(self):
-        return _py_interop_metrics.q_collapsed_metric_total(self)
-
-    def median_qscore(self):
-        return _py_interop_metrics.q_collapsed_metric_median_qscore(self)
-
-    def median_qscore_flt(self):
-        return _py_interop_metrics.q_collapsed_metric_median_qscore_flt(self)
-
-    def cumulative_q20(self):
-        return _py_interop_metrics.q_collapsed_metric_cumulative_q20(self)
-
-    def cumulative_q30(self):
-        return _py_interop_metrics.q_collapsed_metric_cumulative_q30(self)
-
-    def cumulative_total(self):
-        return _py_interop_metrics.q_collapsed_metric_cumulative_total(self)
-
-    def percent_over_q20(self):
-        return _py_interop_metrics.q_collapsed_metric_percent_over_q20(self)
-
-    def percent_over_q30(self):
-        return _py_interop_metrics.q_collapsed_metric_percent_over_q30(self)
-
-    def cumulative_percent_over_q20(self):
-        return _py_interop_metrics.q_collapsed_metric_cumulative_percent_over_q20(self)
-
-    def cumulative_percent_over_q30(self):
-        return _py_interop_metrics.q_collapsed_metric_cumulative_percent_over_q30(self)
-
-    def accumulate(self, metric):
-        return _py_interop_metrics.q_collapsed_metric_accumulate(self, metric)
-
-    @staticmethod
-    def prefix():
-        return _py_interop_metrics.q_collapsed_metric_prefix()
-
-    @staticmethod
-    def suffix():
-        return _py_interop_metrics.q_collapsed_metric_suffix()
-    __swig_destroy__ = _py_interop_metrics.delete_q_collapsed_metric
-
-# Register q_collapsed_metric in _py_interop_metrics:
-_py_interop_metrics.q_collapsed_metric_swigregister(q_collapsed_metric)
-class q_by_lane_metric(q_metric):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    TYPE = _py_interop_metrics.q_by_lane_metric_TYPE
-    LATEST_VERSION = _py_interop_metrics.q_by_lane_metric_LATEST_VERSION
-
-    def __init__(self, *args):
-        _py_interop_metrics.q_by_lane_metric_swiginit(self, _py_interop_metrics.new_q_by_lane_metric(*args))
-
-    def accumulate_by_lane(self, metric):
-        return _py_interop_metrics.q_by_lane_metric_accumulate_by_lane(self, metric)
-
-    @staticmethod
-    def suffix():
-        return _py_interop_metrics.q_by_lane_metric_suffix()
-    __swig_destroy__ = _py_interop_metrics.delete_q_by_lane_metric
-
-# Register q_by_lane_metric in _py_interop_metrics:
-_py_interop_metrics.q_by_lane_metric_swigregister(q_by_lane_metric)
-class summary_run_metric(empty_metric):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    TYPE = _py_interop_metrics.summary_run_metric_TYPE
-    LATEST_VERSION = _py_interop_metrics.summary_run_metric_LATEST_VERSION
-
-    def __init__(self, *args):
-        _py_interop_metrics.summary_run_metric_swiginit(self, _py_interop_metrics.new_summary_run_metric(*args))
-
-    def set(self, occupancy_proxy_cluster_count, raw_cluster_count, occupied_cluster_count, pf_cluster_count):
-        return _py_interop_metrics.summary_run_metric_set(self, occupancy_proxy_cluster_count, raw_cluster_count, occupied_cluster_count, pf_cluster_count)
-
-    def raw_cluster_count(self):
-        return _py_interop_metrics.summary_run_metric_raw_cluster_count(self)
-
-    def occupied_cluster_count(self):
-        return _py_interop_metrics.summary_run_metric_occupied_cluster_count(self)
-
-    def pf_cluster_count(self):
-        return _py_interop_metrics.summary_run_metric_pf_cluster_count(self)
-
-    def occupancy_proxy_cluster_count(self):
-        return _py_interop_metrics.summary_run_metric_occupancy_proxy_cluster_count(self)
-
-    def percent_occupancy_proxy(self):
-        return _py_interop_metrics.summary_run_metric_percent_occupancy_proxy(self)
-
-    def percent_pf(self):
-        return _py_interop_metrics.summary_run_metric_percent_pf(self)
-
-    def percent_occupied(self):
-        return _py_interop_metrics.summary_run_metric_percent_occupied(self)
-
-    def id(self):
-        return _py_interop_metrics.summary_run_metric_id(self)
-
-    @staticmethod
-    def prefix():
-        return _py_interop_metrics.summary_run_metric_prefix()
-
-    @staticmethod
-    def missing():
-        return _py_interop_metrics.summary_run_metric_missing()
-    __swig_destroy__ = _py_interop_metrics.delete_summary_run_metric
-
-# Register summary_run_metric in _py_interop_metrics:
-_py_interop_metrics.summary_run_metric_swigregister(summary_run_metric)
-class base_corrected_intensity_metrics(base_cycle_metric_header):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    TYPE = _py_interop_metrics.base_corrected_intensity_metrics_TYPE
-    LATEST_VERSION = _py_interop_metrics.base_corrected_intensity_metrics_LATEST_VERSION
-
-    def __init__(self, *args):
-        _py_interop_metrics.base_corrected_intensity_metrics_swiginit(self, _py_interop_metrics.new_base_corrected_intensity_metrics(*args))
-
-    def copy_by_tile(self, origin, tile_id):
-        return _py_interop_metrics.base_corrected_intensity_metrics_copy_by_tile(self, origin, tile_id)
-
-    def append_tiles(self, origin, tile_id):
-        return _py_interop_metrics.base_corrected_intensity_metrics_append_tiles(self, origin, tile_id)
-
-    def data_source_exists(self, *args):
-        return _py_interop_metrics.base_corrected_intensity_metrics_data_source_exists(self, *args)
-
-    def sort(self):
-        return _py_interop_metrics.base_corrected_intensity_metrics_sort(self)
-
-    def rebuild_index(self, update_ids=False):
-        return _py_interop_metrics.base_corrected_intensity_metrics_rebuild_index(self, update_ids)
-
-    def resize(self, n):
-        return _py_interop_metrics.base_corrected_intensity_metrics_resize(self, n)
-
-    def reserve(self, n):
-        return _py_interop_metrics.base_corrected_intensity_metrics_reserve(self, n)
-
-    def trim(self, n):
-        return _py_interop_metrics.base_corrected_intensity_metrics_trim(self, n)
-
-    def insert(self, *args):
-        return _py_interop_metrics.base_corrected_intensity_metrics_insert(self, *args)
-
-    def at(self, n):
-        return _py_interop_metrics.base_corrected_intensity_metrics_at(self, n)
-
-    def set_version(self, version):
-        return _py_interop_metrics.base_corrected_intensity_metrics_set_version(self, version)
-
-    def keys(self):
-        return _py_interop_metrics.base_corrected_intensity_metrics_keys(self)
-
-    def lanes(self):
-        return _py_interop_metrics.base_corrected_intensity_metrics_lanes(self)
-
-    def lane_count(self):
-        return _py_interop_metrics.base_corrected_intensity_metrics_lane_count(self)
-
-    def max_lane(self):
-        return _py_interop_metrics.base_corrected_intensity_metrics_max_lane(self)
-
-    def tile_numbers_for_lane(self, lane):
-        return _py_interop_metrics.base_corrected_intensity_metrics_tile_numbers_for_lane(self, lane)
-
-    def tile_numbers(self):
-        return _py_interop_metrics.base_corrected_intensity_metrics_tile_numbers(self)
-
-    def metrics_for_lane(self, *args):
-        return _py_interop_metrics.base_corrected_intensity_metrics_metrics_for_lane(self, *args)
-
-    def cycles(self):
-        return _py_interop_metrics.base_corrected_intensity_metrics_cycles(self)
-
-    def metrics_for_cycle(self, cycle):
-        return _py_interop_metrics.base_corrected_intensity_metrics_metrics_for_cycle(self, cycle)
-
-    def size(self):
-        return _py_interop_metrics.base_corrected_intensity_metrics_size(self)
-
-    def empty(self):
-        return _py_interop_metrics.base_corrected_intensity_metrics_empty(self)
-
-    def version(self):
-        return _py_interop_metrics.base_corrected_intensity_metrics_version(self)
-
-    def clear(self):
-        return _py_interop_metrics.base_corrected_intensity_metrics_clear(self)
-
-    def metrics(self):
-        return _py_interop_metrics.base_corrected_intensity_metrics_metrics(self)
-
-    @staticmethod
-    def prefix():
-        return _py_interop_metrics.base_corrected_intensity_metrics_prefix()
-
-    @staticmethod
-    def suffix():
-        return _py_interop_metrics.base_corrected_intensity_metrics_suffix()
-
-    def get_metric_ref(self, *args):
-        return _py_interop_metrics.base_corrected_intensity_metrics_get_metric_ref(self, *args)
-
-    def find(self, *args):
-        return _py_interop_metrics.base_corrected_intensity_metrics_find(self, *args)
-
-    def get_metric(self, *args):
-        return _py_interop_metrics.base_corrected_intensity_metrics_get_metric(self, *args)
-
-    def has_metric(self, *args):
-        return _py_interop_metrics.base_corrected_intensity_metrics_has_metric(self, *args)
-
-    def clear_lookup(self):
-        return _py_interop_metrics.base_corrected_intensity_metrics_clear_lookup(self)
-    __swig_destroy__ = _py_interop_metrics.delete_base_corrected_intensity_metrics
-
-# Register base_corrected_intensity_metrics in _py_interop_metrics:
-_py_interop_metrics.base_corrected_intensity_metrics_swigregister(base_corrected_intensity_metrics)
-class vector_corrected_intensity_metrics(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _py_interop_metrics.vector_corrected_intensity_metrics___nonzero__(self)
-
-    def __bool__(self):
-        return _py_interop_metrics.vector_corrected_intensity_metrics___bool__(self)
-
-    def __len__(self):
-        return _py_interop_metrics.vector_corrected_intensity_metrics___len__(self)
-
-    def __getslice__(self, i, j):
-        return _py_interop_metrics.vector_corrected_intensity_metrics___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _py_interop_metrics.vector_corrected_intensity_metrics___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _py_interop_metrics.vector_corrected_intensity_metrics___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _py_interop_metrics.vector_corrected_intensity_metrics___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _py_interop_metrics.vector_corrected_intensity_metrics___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _py_interop_metrics.vector_corrected_intensity_metrics___setitem__(self, *args)
-
-    def pop(self):
-        return _py_interop_metrics.vector_corrected_intensity_metrics_pop(self)
-
-    def append(self, x):
-        return _py_interop_metrics.vector_corrected_intensity_metrics_append(self, x)
-
-    def empty(self):
-        return _py_interop_metrics.vector_corrected_intensity_metrics_empty(self)
-
-    def size(self):
-        return _py_interop_metrics.vector_corrected_intensity_metrics_size(self)
-
-    def swap(self, v):
-        return _py_interop_metrics.vector_corrected_intensity_metrics_swap(self, v)
-
-    def rbegin(self):
-        return _py_interop_metrics.vector_corrected_intensity_metrics_rbegin(self)
-
-    def rend(self):
-        return _py_interop_metrics.vector_corrected_intensity_metrics_rend(self)
-
-    def clear(self):
-        return _py_interop_metrics.vector_corrected_intensity_metrics_clear(self)
-
-    def get_allocator(self):
-        return _py_interop_metrics.vector_corrected_intensity_metrics_get_allocator(self)
-
-    def pop_back(self):
-        return _py_interop_metrics.vector_corrected_intensity_metrics_pop_back(self)
-
-    def erase(self, *args):
-        return _py_interop_metrics.vector_corrected_intensity_metrics_erase(self, *args)
-
-    def __init__(self, *args):
-        _py_interop_metrics.vector_corrected_intensity_metrics_swiginit(self, _py_interop_metrics.new_vector_corrected_intensity_metrics(*args))
-
-    def push_back(self, x):
-        return _py_interop_metrics.vector_corrected_intensity_metrics_push_back(self, x)
-
-    def front(self):
-        return _py_interop_metrics.vector_corrected_intensity_metrics_front(self)
-
-    def back(self):
-        return _py_interop_metrics.vector_corrected_intensity_metrics_back(self)
-
-    def assign(self, n, x):
-        return _py_interop_metrics.vector_corrected_intensity_metrics_assign(self, n, x)
-
-    def resize(self, *args):
-        return _py_interop_metrics.vector_corrected_intensity_metrics_resize(self, *args)
-
-    def insert(self, *args):
-        return _py_interop_metrics.vector_corrected_intensity_metrics_insert(self, *args)
-
-    def reserve(self, n):
-        return _py_interop_metrics.vector_corrected_intensity_metrics_reserve(self, n)
-
-    def capacity(self):
-        return _py_interop_metrics.vector_corrected_intensity_metrics_capacity(self)
-    __swig_destroy__ = _py_interop_metrics.delete_vector_corrected_intensity_metrics
-
-# Register vector_corrected_intensity_metrics in _py_interop_metrics:
-_py_interop_metrics.vector_corrected_intensity_metrics_swigregister(vector_corrected_intensity_metrics)
-class base_error_metrics(error_metric_header):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    TYPE = _py_interop_metrics.base_error_metrics_TYPE
-    LATEST_VERSION = _py_interop_metrics.base_error_metrics_LATEST_VERSION
-
-    def __init__(self, *args):
-        _py_interop_metrics.base_error_metrics_swiginit(self, _py_interop_metrics.new_base_error_metrics(*args))
-
-    def copy_by_tile(self, origin, tile_id):
-        return _py_interop_metrics.base_error_metrics_copy_by_tile(self, origin, tile_id)
-
-    def append_tiles(self, origin, tile_id):
-        return _py_interop_metrics.base_error_metrics_append_tiles(self, origin, tile_id)
-
-    def data_source_exists(self, *args):
-        return _py_interop_metrics.base_error_metrics_data_source_exists(self, *args)
-
-    def sort(self):
-        return _py_interop_metrics.base_error_metrics_sort(self)
-
-    def rebuild_index(self, update_ids=False):
-        return _py_interop_metrics.base_error_metrics_rebuild_index(self, update_ids)
-
-    def resize(self, n):
-        return _py_interop_metrics.base_error_metrics_resize(self, n)
-
-    def reserve(self, n):
-        return _py_interop_metrics.base_error_metrics_reserve(self, n)
-
-    def trim(self, n):
-        return _py_interop_metrics.base_error_metrics_trim(self, n)
-
-    def insert(self, *args):
-        return _py_interop_metrics.base_error_metrics_insert(self, *args)
-
-    def at(self, n):
-        return _py_interop_metrics.base_error_metrics_at(self, n)
-
-    def set_version(self, version):
-        return _py_interop_metrics.base_error_metrics_set_version(self, version)
-
-    def keys(self):
-        return _py_interop_metrics.base_error_metrics_keys(self)
-
-    def lanes(self):
-        return _py_interop_metrics.base_error_metrics_lanes(self)
-
-    def lane_count(self):
-        return _py_interop_metrics.base_error_metrics_lane_count(self)
-
-    def max_lane(self):
-        return _py_interop_metrics.base_error_metrics_max_lane(self)
-
-    def tile_numbers_for_lane(self, lane):
-        return _py_interop_metrics.base_error_metrics_tile_numbers_for_lane(self, lane)
-
-    def tile_numbers(self):
-        return _py_interop_metrics.base_error_metrics_tile_numbers(self)
-
-    def metrics_for_lane(self, *args):
-        return _py_interop_metrics.base_error_metrics_metrics_for_lane(self, *args)
-
-    def cycles(self):
-        return _py_interop_metrics.base_error_metrics_cycles(self)
-
-    def metrics_for_cycle(self, cycle):
-        return _py_interop_metrics.base_error_metrics_metrics_for_cycle(self, cycle)
-
-    def size(self):
-        return _py_interop_metrics.base_error_metrics_size(self)
-
-    def empty(self):
-        return _py_interop_metrics.base_error_metrics_empty(self)
-
-    def version(self):
-        return _py_interop_metrics.base_error_metrics_version(self)
-
-    def clear(self):
-        return _py_interop_metrics.base_error_metrics_clear(self)
-
-    def metrics(self):
-        return _py_interop_metrics.base_error_metrics_metrics(self)
-
-    @staticmethod
-    def prefix():
-        return _py_interop_metrics.base_error_metrics_prefix()
-
-    @staticmethod
-    def suffix():
-        return _py_interop_metrics.base_error_metrics_suffix()
-
-    def get_metric_ref(self, *args):
-        return _py_interop_metrics.base_error_metrics_get_metric_ref(self, *args)
-
-    def find(self, *args):
-        return _py_interop_metrics.base_error_metrics_find(self, *args)
-
-    def get_metric(self, *args):
-        return _py_interop_metrics.base_error_metrics_get_metric(self, *args)
-
-    def has_metric(self, *args):
-        return _py_interop_metrics.base_error_metrics_has_metric(self, *args)
-
-    def clear_lookup(self):
-        return _py_interop_metrics.base_error_metrics_clear_lookup(self)
-    __swig_destroy__ = _py_interop_metrics.delete_base_error_metrics
-
-# Register base_error_metrics in _py_interop_metrics:
-_py_interop_metrics.base_error_metrics_swigregister(base_error_metrics)
-class vector_error_metrics(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _py_interop_metrics.vector_error_metrics___nonzero__(self)
-
-    def __bool__(self):
-        return _py_interop_metrics.vector_error_metrics___bool__(self)
-
-    def __len__(self):
-        return _py_interop_metrics.vector_error_metrics___len__(self)
-
-    def __getslice__(self, i, j):
-        return _py_interop_metrics.vector_error_metrics___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _py_interop_metrics.vector_error_metrics___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _py_interop_metrics.vector_error_metrics___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _py_interop_metrics.vector_error_metrics___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _py_interop_metrics.vector_error_metrics___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _py_interop_metrics.vector_error_metrics___setitem__(self, *args)
-
-    def pop(self):
-        return _py_interop_metrics.vector_error_metrics_pop(self)
-
-    def append(self, x):
-        return _py_interop_metrics.vector_error_metrics_append(self, x)
-
-    def empty(self):
-        return _py_interop_metrics.vector_error_metrics_empty(self)
-
-    def size(self):
-        return _py_interop_metrics.vector_error_metrics_size(self)
-
-    def swap(self, v):
-        return _py_interop_metrics.vector_error_metrics_swap(self, v)
-
-    def rbegin(self):
-        return _py_interop_metrics.vector_error_metrics_rbegin(self)
-
-    def rend(self):
-        return _py_interop_metrics.vector_error_metrics_rend(self)
-
-    def clear(self):
-        return _py_interop_metrics.vector_error_metrics_clear(self)
-
-    def get_allocator(self):
-        return _py_interop_metrics.vector_error_metrics_get_allocator(self)
-
-    def pop_back(self):
-        return _py_interop_metrics.vector_error_metrics_pop_back(self)
-
-    def erase(self, *args):
-        return _py_interop_metrics.vector_error_metrics_erase(self, *args)
-
-    def __init__(self, *args):
-        _py_interop_metrics.vector_error_metrics_swiginit(self, _py_interop_metrics.new_vector_error_metrics(*args))
-
-    def push_back(self, x):
-        return _py_interop_metrics.vector_error_metrics_push_back(self, x)
-
-    def front(self):
-        return _py_interop_metrics.vector_error_metrics_front(self)
-
-    def back(self):
-        return _py_interop_metrics.vector_error_metrics_back(self)
-
-    def assign(self, n, x):
-        return _py_interop_metrics.vector_error_metrics_assign(self, n, x)
-
-    def resize(self, *args):
-        return _py_interop_metrics.vector_error_metrics_resize(self, *args)
-
-    def insert(self, *args):
-        return _py_interop_metrics.vector_error_metrics_insert(self, *args)
-
-    def reserve(self, n):
-        return _py_interop_metrics.vector_error_metrics_reserve(self, n)
-
-    def capacity(self):
-        return _py_interop_metrics.vector_error_metrics_capacity(self)
-    __swig_destroy__ = _py_interop_metrics.delete_vector_error_metrics
-
-# Register vector_error_metrics in _py_interop_metrics:
-_py_interop_metrics.vector_error_metrics_swigregister(vector_error_metrics)
-class base_extended_tile_metrics(base_metric_header):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    TYPE = _py_interop_metrics.base_extended_tile_metrics_TYPE
-    LATEST_VERSION = _py_interop_metrics.base_extended_tile_metrics_LATEST_VERSION
-
-    def __init__(self, *args):
-        _py_interop_metrics.base_extended_tile_metrics_swiginit(self, _py_interop_metrics.new_base_extended_tile_metrics(*args))
-
-    def copy_by_tile(self, origin, tile_id):
-        return _py_interop_metrics.base_extended_tile_metrics_copy_by_tile(self, origin, tile_id)
-
-    def append_tiles(self, origin, tile_id):
-        return _py_interop_metrics.base_extended_tile_metrics_append_tiles(self, origin, tile_id)
-
-    def data_source_exists(self, *args):
-        return _py_interop_metrics.base_extended_tile_metrics_data_source_exists(self, *args)
-
-    def sort(self):
-        return _py_interop_metrics.base_extended_tile_metrics_sort(self)
-
-    def rebuild_index(self, update_ids=False):
-        return _py_interop_metrics.base_extended_tile_metrics_rebuild_index(self, update_ids)
-
-    def resize(self, n):
-        return _py_interop_metrics.base_extended_tile_metrics_resize(self, n)
-
-    def reserve(self, n):
-        return _py_interop_metrics.base_extended_tile_metrics_reserve(self, n)
-
-    def trim(self, n):
-        return _py_interop_metrics.base_extended_tile_metrics_trim(self, n)
-
-    def insert(self, *args):
-        return _py_interop_metrics.base_extended_tile_metrics_insert(self, *args)
-
-    def at(self, n):
-        return _py_interop_metrics.base_extended_tile_metrics_at(self, n)
-
-    def set_version(self, version):
-        return _py_interop_metrics.base_extended_tile_metrics_set_version(self, version)
-
-    def keys(self):
-        return _py_interop_metrics.base_extended_tile_metrics_keys(self)
-
-    def lanes(self):
-        return _py_interop_metrics.base_extended_tile_metrics_lanes(self)
-
-    def lane_count(self):
-        return _py_interop_metrics.base_extended_tile_metrics_lane_count(self)
-
-    def max_lane(self):
-        return _py_interop_metrics.base_extended_tile_metrics_max_lane(self)
-
-    def tile_numbers_for_lane(self, lane):
-        return _py_interop_metrics.base_extended_tile_metrics_tile_numbers_for_lane(self, lane)
-
-    def tile_numbers(self):
-        return _py_interop_metrics.base_extended_tile_metrics_tile_numbers(self)
-
-    def metrics_for_lane(self, *args):
-        return _py_interop_metrics.base_extended_tile_metrics_metrics_for_lane(self, *args)
-
-    def cycles(self):
-        return _py_interop_metrics.base_extended_tile_metrics_cycles(self)
-
-    def metrics_for_cycle(self, cycle):
-        return _py_interop_metrics.base_extended_tile_metrics_metrics_for_cycle(self, cycle)
-
-    def size(self):
-        return _py_interop_metrics.base_extended_tile_metrics_size(self)
-
-    def empty(self):
-        return _py_interop_metrics.base_extended_tile_metrics_empty(self)
-
-    def version(self):
-        return _py_interop_metrics.base_extended_tile_metrics_version(self)
-
-    def clear(self):
-        return _py_interop_metrics.base_extended_tile_metrics_clear(self)
-
-    def metrics(self):
-        return _py_interop_metrics.base_extended_tile_metrics_metrics(self)
-
-    @staticmethod
-    def prefix():
-        return _py_interop_metrics.base_extended_tile_metrics_prefix()
-
-    @staticmethod
-    def suffix():
-        return _py_interop_metrics.base_extended_tile_metrics_suffix()
-
-    def get_metric_ref(self, *args):
-        return _py_interop_metrics.base_extended_tile_metrics_get_metric_ref(self, *args)
-
-    def find(self, *args):
-        return _py_interop_metrics.base_extended_tile_metrics_find(self, *args)
-
-    def get_metric(self, *args):
-        return _py_interop_metrics.base_extended_tile_metrics_get_metric(self, *args)
-
-    def has_metric(self, *args):
-        return _py_interop_metrics.base_extended_tile_metrics_has_metric(self, *args)
-
-    def clear_lookup(self):
-        return _py_interop_metrics.base_extended_tile_metrics_clear_lookup(self)
-    __swig_destroy__ = _py_interop_metrics.delete_base_extended_tile_metrics
-
-# Register base_extended_tile_metrics in _py_interop_metrics:
-_py_interop_metrics.base_extended_tile_metrics_swigregister(base_extended_tile_metrics)
-class vector_extended_tile_metrics(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _py_interop_metrics.vector_extended_tile_metrics___nonzero__(self)
-
-    def __bool__(self):
-        return _py_interop_metrics.vector_extended_tile_metrics___bool__(self)
-
-    def __len__(self):
-        return _py_interop_metrics.vector_extended_tile_metrics___len__(self)
-
-    def __getslice__(self, i, j):
-        return _py_interop_metrics.vector_extended_tile_metrics___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _py_interop_metrics.vector_extended_tile_metrics___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _py_interop_metrics.vector_extended_tile_metrics___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _py_interop_metrics.vector_extended_tile_metrics___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _py_interop_metrics.vector_extended_tile_metrics___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _py_interop_metrics.vector_extended_tile_metrics___setitem__(self, *args)
-
-    def pop(self):
-        return _py_interop_metrics.vector_extended_tile_metrics_pop(self)
-
-    def append(self, x):
-        return _py_interop_metrics.vector_extended_tile_metrics_append(self, x)
-
-    def empty(self):
-        return _py_interop_metrics.vector_extended_tile_metrics_empty(self)
-
-    def size(self):
-        return _py_interop_metrics.vector_extended_tile_metrics_size(self)
-
-    def swap(self, v):
-        return _py_interop_metrics.vector_extended_tile_metrics_swap(self, v)
-
-    def rbegin(self):
-        return _py_interop_metrics.vector_extended_tile_metrics_rbegin(self)
-
-    def rend(self):
-        return _py_interop_metrics.vector_extended_tile_metrics_rend(self)
-
-    def clear(self):
-        return _py_interop_metrics.vector_extended_tile_metrics_clear(self)
-
-    def get_allocator(self):
-        return _py_interop_metrics.vector_extended_tile_metrics_get_allocator(self)
-
-    def pop_back(self):
-        return _py_interop_metrics.vector_extended_tile_metrics_pop_back(self)
-
-    def erase(self, *args):
-        return _py_interop_metrics.vector_extended_tile_metrics_erase(self, *args)
-
-    def __init__(self, *args):
-        _py_interop_metrics.vector_extended_tile_metrics_swiginit(self, _py_interop_metrics.new_vector_extended_tile_metrics(*args))
-
-    def push_back(self, x):
-        return _py_interop_metrics.vector_extended_tile_metrics_push_back(self, x)
-
-    def front(self):
-        return _py_interop_metrics.vector_extended_tile_metrics_front(self)
-
-    def back(self):
-        return _py_interop_metrics.vector_extended_tile_metrics_back(self)
-
-    def assign(self, n, x):
-        return _py_interop_metrics.vector_extended_tile_metrics_assign(self, n, x)
-
-    def resize(self, *args):
-        return _py_interop_metrics.vector_extended_tile_metrics_resize(self, *args)
-
-    def insert(self, *args):
-        return _py_interop_metrics.vector_extended_tile_metrics_insert(self, *args)
-
-    def reserve(self, n):
-        return _py_interop_metrics.vector_extended_tile_metrics_reserve(self, n)
-
-    def capacity(self):
-        return _py_interop_metrics.vector_extended_tile_metrics_capacity(self)
-    __swig_destroy__ = _py_interop_metrics.delete_vector_extended_tile_metrics
-
-# Register vector_extended_tile_metrics in _py_interop_metrics:
-_py_interop_metrics.vector_extended_tile_metrics_swigregister(vector_extended_tile_metrics)
-class base_extraction_metrics(extraction_metric_header):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    TYPE = _py_interop_metrics.base_extraction_metrics_TYPE
-    LATEST_VERSION = _py_interop_metrics.base_extraction_metrics_LATEST_VERSION
-
-    def __init__(self, *args):
-        _py_interop_metrics.base_extraction_metrics_swiginit(self, _py_interop_metrics.new_base_extraction_metrics(*args))
-
-    def copy_by_tile(self, origin, tile_id):
-        return _py_interop_metrics.base_extraction_metrics_copy_by_tile(self, origin, tile_id)
-
-    def append_tiles(self, origin, tile_id):
-        return _py_interop_metrics.base_extraction_metrics_append_tiles(self, origin, tile_id)
-
-    def data_source_exists(self, *args):
-        return _py_interop_metrics.base_extraction_metrics_data_source_exists(self, *args)
-
-    def sort(self):
-        return _py_interop_metrics.base_extraction_metrics_sort(self)
-
-    def rebuild_index(self, update_ids=False):
-        return _py_interop_metrics.base_extraction_metrics_rebuild_index(self, update_ids)
-
-    def resize(self, n):
-        return _py_interop_metrics.base_extraction_metrics_resize(self, n)
-
-    def reserve(self, n):
-        return _py_interop_metrics.base_extraction_metrics_reserve(self, n)
-
-    def trim(self, n):
-        return _py_interop_metrics.base_extraction_metrics_trim(self, n)
-
-    def insert(self, *args):
-        return _py_interop_metrics.base_extraction_metrics_insert(self, *args)
-
-    def at(self, n):
-        return _py_interop_metrics.base_extraction_metrics_at(self, n)
-
-    def set_version(self, version):
-        return _py_interop_metrics.base_extraction_metrics_set_version(self, version)
-
-    def keys(self):
-        return _py_interop_metrics.base_extraction_metrics_keys(self)
-
-    def lanes(self):
-        return _py_interop_metrics.base_extraction_metrics_lanes(self)
-
-    def lane_count(self):
-        return _py_interop_metrics.base_extraction_metrics_lane_count(self)
-
-    def max_lane(self):
-        return _py_interop_metrics.base_extraction_metrics_max_lane(self)
-
-    def tile_numbers_for_lane(self, lane):
-        return _py_interop_metrics.base_extraction_metrics_tile_numbers_for_lane(self, lane)
-
-    def tile_numbers(self):
-        return _py_interop_metrics.base_extraction_metrics_tile_numbers(self)
-
-    def metrics_for_lane(self, *args):
-        return _py_interop_metrics.base_extraction_metrics_metrics_for_lane(self, *args)
-
-    def cycles(self):
-        return _py_interop_metrics.base_extraction_metrics_cycles(self)
-
-    def metrics_for_cycle(self, cycle):
-        return _py_interop_metrics.base_extraction_metrics_metrics_for_cycle(self, cycle)
-
-    def size(self):
-        return _py_interop_metrics.base_extraction_metrics_size(self)
-
-    def empty(self):
-        return _py_interop_metrics.base_extraction_metrics_empty(self)
-
-    def version(self):
-        return _py_interop_metrics.base_extraction_metrics_version(self)
-
-    def clear(self):
-        return _py_interop_metrics.base_extraction_metrics_clear(self)
-
-    def metrics(self):
-        return _py_interop_metrics.base_extraction_metrics_metrics(self)
-
-    @staticmethod
-    def prefix():
-        return _py_interop_metrics.base_extraction_metrics_prefix()
-
-    @staticmethod
-    def suffix():
-        return _py_interop_metrics.base_extraction_metrics_suffix()
-
-    def get_metric_ref(self, *args):
-        return _py_interop_metrics.base_extraction_metrics_get_metric_ref(self, *args)
-
-    def find(self, *args):
-        return _py_interop_metrics.base_extraction_metrics_find(self, *args)
-
-    def get_metric(self, *args):
-        return _py_interop_metrics.base_extraction_metrics_get_metric(self, *args)
-
-    def has_metric(self, *args):
-        return _py_interop_metrics.base_extraction_metrics_has_metric(self, *args)
-
-    def clear_lookup(self):
-        return _py_interop_metrics.base_extraction_metrics_clear_lookup(self)
-    __swig_destroy__ = _py_interop_metrics.delete_base_extraction_metrics
-
-# Register base_extraction_metrics in _py_interop_metrics:
-_py_interop_metrics.base_extraction_metrics_swigregister(base_extraction_metrics)
-class vector_extraction_metrics(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _py_interop_metrics.vector_extraction_metrics___nonzero__(self)
-
-    def __bool__(self):
-        return _py_interop_metrics.vector_extraction_metrics___bool__(self)
-
-    def __len__(self):
-        return _py_interop_metrics.vector_extraction_metrics___len__(self)
-
-    def __getslice__(self, i, j):
-        return _py_interop_metrics.vector_extraction_metrics___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _py_interop_metrics.vector_extraction_metrics___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _py_interop_metrics.vector_extraction_metrics___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _py_interop_metrics.vector_extraction_metrics___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _py_interop_metrics.vector_extraction_metrics___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _py_interop_metrics.vector_extraction_metrics___setitem__(self, *args)
-
-    def pop(self):
-        return _py_interop_metrics.vector_extraction_metrics_pop(self)
-
-    def append(self, x):
-        return _py_interop_metrics.vector_extraction_metrics_append(self, x)
-
-    def empty(self):
-        return _py_interop_metrics.vector_extraction_metrics_empty(self)
-
-    def size(self):
-        return _py_interop_metrics.vector_extraction_metrics_size(self)
-
-    def swap(self, v):
-        return _py_interop_metrics.vector_extraction_metrics_swap(self, v)
-
-    def rbegin(self):
-        return _py_interop_metrics.vector_extraction_metrics_rbegin(self)
-
-    def rend(self):
-        return _py_interop_metrics.vector_extraction_metrics_rend(self)
-
-    def clear(self):
-        return _py_interop_metrics.vector_extraction_metrics_clear(self)
-
-    def get_allocator(self):
-        return _py_interop_metrics.vector_extraction_metrics_get_allocator(self)
-
-    def pop_back(self):
-        return _py_interop_metrics.vector_extraction_metrics_pop_back(self)
-
-    def erase(self, *args):
-        return _py_interop_metrics.vector_extraction_metrics_erase(self, *args)
-
-    def __init__(self, *args):
-        _py_interop_metrics.vector_extraction_metrics_swiginit(self, _py_interop_metrics.new_vector_extraction_metrics(*args))
-
-    def push_back(self, x):
-        return _py_interop_metrics.vector_extraction_metrics_push_back(self, x)
-
-    def front(self):
-        return _py_interop_metrics.vector_extraction_metrics_front(self)
-
-    def back(self):
-        return _py_interop_metrics.vector_extraction_metrics_back(self)
-
-    def assign(self, n, x):
-        return _py_interop_metrics.vector_extraction_metrics_assign(self, n, x)
-
-    def resize(self, *args):
-        return _py_interop_metrics.vector_extraction_metrics_resize(self, *args)
-
-    def insert(self, *args):
-        return _py_interop_metrics.vector_extraction_metrics_insert(self, *args)
-
-    def reserve(self, n):
-        return _py_interop_metrics.vector_extraction_metrics_reserve(self, n)
-
-    def capacity(self):
-        return _py_interop_metrics.vector_extraction_metrics_capacity(self)
-    __swig_destroy__ = _py_interop_metrics.delete_vector_extraction_metrics
-
-# Register vector_extraction_metrics in _py_interop_metrics:
-_py_interop_metrics.vector_extraction_metrics_swigregister(vector_extraction_metrics)
-class base_image_metrics(image_metric_header):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    TYPE = _py_interop_metrics.base_image_metrics_TYPE
-    LATEST_VERSION = _py_interop_metrics.base_image_metrics_LATEST_VERSION
-
-    def __init__(self, *args):
-        _py_interop_metrics.base_image_metrics_swiginit(self, _py_interop_metrics.new_base_image_metrics(*args))
-
-    def copy_by_tile(self, origin, tile_id):
-        return _py_interop_metrics.base_image_metrics_copy_by_tile(self, origin, tile_id)
-
-    def append_tiles(self, origin, tile_id):
-        return _py_interop_metrics.base_image_metrics_append_tiles(self, origin, tile_id)
-
-    def data_source_exists(self, *args):
-        return _py_interop_metrics.base_image_metrics_data_source_exists(self, *args)
-
-    def sort(self):
-        return _py_interop_metrics.base_image_metrics_sort(self)
-
-    def rebuild_index(self, update_ids=False):
-        return _py_interop_metrics.base_image_metrics_rebuild_index(self, update_ids)
-
-    def resize(self, n):
-        return _py_interop_metrics.base_image_metrics_resize(self, n)
-
-    def reserve(self, n):
-        return _py_interop_metrics.base_image_metrics_reserve(self, n)
-
-    def trim(self, n):
-        return _py_interop_metrics.base_image_metrics_trim(self, n)
-
-    def insert(self, *args):
-        return _py_interop_metrics.base_image_metrics_insert(self, *args)
-
-    def at(self, n):
-        return _py_interop_metrics.base_image_metrics_at(self, n)
-
-    def set_version(self, version):
-        return _py_interop_metrics.base_image_metrics_set_version(self, version)
-
-    def keys(self):
-        return _py_interop_metrics.base_image_metrics_keys(self)
-
-    def lanes(self):
-        return _py_interop_metrics.base_image_metrics_lanes(self)
-
-    def lane_count(self):
-        return _py_interop_metrics.base_image_metrics_lane_count(self)
-
-    def max_lane(self):
-        return _py_interop_metrics.base_image_metrics_max_lane(self)
-
-    def tile_numbers_for_lane(self, lane):
-        return _py_interop_metrics.base_image_metrics_tile_numbers_for_lane(self, lane)
-
-    def tile_numbers(self):
-        return _py_interop_metrics.base_image_metrics_tile_numbers(self)
-
-    def metrics_for_lane(self, *args):
-        return _py_interop_metrics.base_image_metrics_metrics_for_lane(self, *args)
-
-    def cycles(self):
-        return _py_interop_metrics.base_image_metrics_cycles(self)
-
-    def metrics_for_cycle(self, cycle):
-        return _py_interop_metrics.base_image_metrics_metrics_for_cycle(self, cycle)
-
-    def size(self):
-        return _py_interop_metrics.base_image_metrics_size(self)
-
-    def empty(self):
-        return _py_interop_metrics.base_image_metrics_empty(self)
-
-    def version(self):
-        return _py_interop_metrics.base_image_metrics_version(self)
-
-    def clear(self):
-        return _py_interop_metrics.base_image_metrics_clear(self)
-
-    def metrics(self):
-        return _py_interop_metrics.base_image_metrics_metrics(self)
-
-    @staticmethod
-    def prefix():
-        return _py_interop_metrics.base_image_metrics_prefix()
-
-    @staticmethod
-    def suffix():
-        return _py_interop_metrics.base_image_metrics_suffix()
-
-    def get_metric_ref(self, *args):
-        return _py_interop_metrics.base_image_metrics_get_metric_ref(self, *args)
-
-    def find(self, *args):
-        return _py_interop_metrics.base_image_metrics_find(self, *args)
-
-    def get_metric(self, *args):
-        return _py_interop_metrics.base_image_metrics_get_metric(self, *args)
-
-    def has_metric(self, *args):
-        return _py_interop_metrics.base_image_metrics_has_metric(self, *args)
-
-    def clear_lookup(self):
-        return _py_interop_metrics.base_image_metrics_clear_lookup(self)
-    __swig_destroy__ = _py_interop_metrics.delete_base_image_metrics
-
-# Register base_image_metrics in _py_interop_metrics:
-_py_interop_metrics.base_image_metrics_swigregister(base_image_metrics)
-class vector_image_metrics(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _py_interop_metrics.vector_image_metrics___nonzero__(self)
-
-    def __bool__(self):
-        return _py_interop_metrics.vector_image_metrics___bool__(self)
-
-    def __len__(self):
-        return _py_interop_metrics.vector_image_metrics___len__(self)
-
-    def __getslice__(self, i, j):
-        return _py_interop_metrics.vector_image_metrics___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _py_interop_metrics.vector_image_metrics___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _py_interop_metrics.vector_image_metrics___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _py_interop_metrics.vector_image_metrics___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _py_interop_metrics.vector_image_metrics___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _py_interop_metrics.vector_image_metrics___setitem__(self, *args)
-
-    def pop(self):
-        return _py_interop_metrics.vector_image_metrics_pop(self)
-
-    def append(self, x):
-        return _py_interop_metrics.vector_image_metrics_append(self, x)
-
-    def empty(self):
-        return _py_interop_metrics.vector_image_metrics_empty(self)
-
-    def size(self):
-        return _py_interop_metrics.vector_image_metrics_size(self)
-
-    def swap(self, v):
-        return _py_interop_metrics.vector_image_metrics_swap(self, v)
-
-    def rbegin(self):
-        return _py_interop_metrics.vector_image_metrics_rbegin(self)
-
-    def rend(self):
-        return _py_interop_metrics.vector_image_metrics_rend(self)
-
-    def clear(self):
-        return _py_interop_metrics.vector_image_metrics_clear(self)
-
-    def get_allocator(self):
-        return _py_interop_metrics.vector_image_metrics_get_allocator(self)
-
-    def pop_back(self):
-        return _py_interop_metrics.vector_image_metrics_pop_back(self)
-
-    def erase(self, *args):
-        return _py_interop_metrics.vector_image_metrics_erase(self, *args)
-
-    def __init__(self, *args):
-        _py_interop_metrics.vector_image_metrics_swiginit(self, _py_interop_metrics.new_vector_image_metrics(*args))
-
-    def push_back(self, x):
-        return _py_interop_metrics.vector_image_metrics_push_back(self, x)
-
-    def front(self):
-        return _py_interop_metrics.vector_image_metrics_front(self)
-
-    def back(self):
-        return _py_interop_metrics.vector_image_metrics_back(self)
-
-    def assign(self, n, x):
-        return _py_interop_metrics.vector_image_metrics_assign(self, n, x)
-
-    def resize(self, *args):
-        return _py_interop_metrics.vector_image_metrics_resize(self, *args)
-
-    def insert(self, *args):
-        return _py_interop_metrics.vector_image_metrics_insert(self, *args)
-
-    def reserve(self, n):
-        return _py_interop_metrics.vector_image_metrics_reserve(self, n)
-
-    def capacity(self):
-        return _py_interop_metrics.vector_image_metrics_capacity(self)
-    __swig_destroy__ = _py_interop_metrics.delete_vector_image_metrics
-
-# Register vector_image_metrics in _py_interop_metrics:
-_py_interop_metrics.vector_image_metrics_swigregister(vector_image_metrics)
-class base_q_metrics(q_score_header):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    TYPE = _py_interop_metrics.base_q_metrics_TYPE
-    LATEST_VERSION = _py_interop_metrics.base_q_metrics_LATEST_VERSION
-
-    def __init__(self, *args):
-        _py_interop_metrics.base_q_metrics_swiginit(self, _py_interop_metrics.new_base_q_metrics(*args))
-
-    def copy_by_tile(self, origin, tile_id):
-        return _py_interop_metrics.base_q_metrics_copy_by_tile(self, origin, tile_id)
-
-    def append_tiles(self, origin, tile_id):
-        return _py_interop_metrics.base_q_metrics_append_tiles(self, origin, tile_id)
-
-    def data_source_exists(self, *args):
-        return _py_interop_metrics.base_q_metrics_data_source_exists(self, *args)
-
-    def sort(self):
-        return _py_interop_metrics.base_q_metrics_sort(self)
-
-    def rebuild_index(self, update_ids=False):
-        return _py_interop_metrics.base_q_metrics_rebuild_index(self, update_ids)
-
-    def resize(self, n):
-        return _py_interop_metrics.base_q_metrics_resize(self, n)
-
-    def reserve(self, n):
-        return _py_interop_metrics.base_q_metrics_reserve(self, n)
-
-    def trim(self, n):
-        return _py_interop_metrics.base_q_metrics_trim(self, n)
-
-    def insert(self, *args):
-        return _py_interop_metrics.base_q_metrics_insert(self, *args)
-
-    def at(self, n):
-        return _py_interop_metrics.base_q_metrics_at(self, n)
-
-    def set_version(self, version):
-        return _py_interop_metrics.base_q_metrics_set_version(self, version)
-
-    def keys(self):
-        return _py_interop_metrics.base_q_metrics_keys(self)
-
-    def lanes(self):
-        return _py_interop_metrics.base_q_metrics_lanes(self)
-
-    def lane_count(self):
-        return _py_interop_metrics.base_q_metrics_lane_count(self)
-
-    def max_lane(self):
-        return _py_interop_metrics.base_q_metrics_max_lane(self)
-
-    def tile_numbers_for_lane(self, lane):
-        return _py_interop_metrics.base_q_metrics_tile_numbers_for_lane(self, lane)
-
-    def tile_numbers(self):
-        return _py_interop_metrics.base_q_metrics_tile_numbers(self)
-
-    def metrics_for_lane(self, *args):
-        return _py_interop_metrics.base_q_metrics_metrics_for_lane(self, *args)
-
-    def cycles(self):
-        return _py_interop_metrics.base_q_metrics_cycles(self)
-
-    def metrics_for_cycle(self, cycle):
-        return _py_interop_metrics.base_q_metrics_metrics_for_cycle(self, cycle)
-
-    def size(self):
-        return _py_interop_metrics.base_q_metrics_size(self)
-
-    def empty(self):
-        return _py_interop_metrics.base_q_metrics_empty(self)
-
-    def version(self):
-        return _py_interop_metrics.base_q_metrics_version(self)
-
-    def clear(self):
-        return _py_interop_metrics.base_q_metrics_clear(self)
-
-    def metrics(self):
-        return _py_interop_metrics.base_q_metrics_metrics(self)
-
-    @staticmethod
-    def prefix():
-        return _py_interop_metrics.base_q_metrics_prefix()
-
-    @staticmethod
-    def suffix():
-        return _py_interop_metrics.base_q_metrics_suffix()
-
-    def get_metric_ref(self, *args):
-        return _py_interop_metrics.base_q_metrics_get_metric_ref(self, *args)
-
-    def find(self, *args):
-        return _py_interop_metrics.base_q_metrics_find(self, *args)
-
-    def get_metric(self, *args):
-        return _py_interop_metrics.base_q_metrics_get_metric(self, *args)
-
-    def has_metric(self, *args):
-        return _py_interop_metrics.base_q_metrics_has_metric(self, *args)
-
-    def clear_lookup(self):
-        return _py_interop_metrics.base_q_metrics_clear_lookup(self)
-    __swig_destroy__ = _py_interop_metrics.delete_base_q_metrics
-
-# Register base_q_metrics in _py_interop_metrics:
-_py_interop_metrics.base_q_metrics_swigregister(base_q_metrics)
-class vector_q_metrics(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _py_interop_metrics.vector_q_metrics___nonzero__(self)
-
-    def __bool__(self):
-        return _py_interop_metrics.vector_q_metrics___bool__(self)
-
-    def __len__(self):
-        return _py_interop_metrics.vector_q_metrics___len__(self)
-
-    def __getslice__(self, i, j):
-        return _py_interop_metrics.vector_q_metrics___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _py_interop_metrics.vector_q_metrics___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _py_interop_metrics.vector_q_metrics___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _py_interop_metrics.vector_q_metrics___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _py_interop_metrics.vector_q_metrics___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _py_interop_metrics.vector_q_metrics___setitem__(self, *args)
-
-    def pop(self):
-        return _py_interop_metrics.vector_q_metrics_pop(self)
-
-    def append(self, x):
-        return _py_interop_metrics.vector_q_metrics_append(self, x)
-
-    def empty(self):
-        return _py_interop_metrics.vector_q_metrics_empty(self)
-
-    def size(self):
-        return _py_interop_metrics.vector_q_metrics_size(self)
-
-    def swap(self, v):
-        return _py_interop_metrics.vector_q_metrics_swap(self, v)
-
-    def rbegin(self):
-        return _py_interop_metrics.vector_q_metrics_rbegin(self)
-
-    def rend(self):
-        return _py_interop_metrics.vector_q_metrics_rend(self)
-
-    def clear(self):
-        return _py_interop_metrics.vector_q_metrics_clear(self)
-
-    def get_allocator(self):
-        return _py_interop_metrics.vector_q_metrics_get_allocator(self)
-
-    def pop_back(self):
-        return _py_interop_metrics.vector_q_metrics_pop_back(self)
-
-    def erase(self, *args):
-        return _py_interop_metrics.vector_q_metrics_erase(self, *args)
-
-    def __init__(self, *args):
-        _py_interop_metrics.vector_q_metrics_swiginit(self, _py_interop_metrics.new_vector_q_metrics(*args))
-
-    def push_back(self, x):
-        return _py_interop_metrics.vector_q_metrics_push_back(self, x)
-
-    def front(self):
-        return _py_interop_metrics.vector_q_metrics_front(self)
-
-    def back(self):
-        return _py_interop_metrics.vector_q_metrics_back(self)
-
-    def assign(self, n, x):
-        return _py_interop_metrics.vector_q_metrics_assign(self, n, x)
-
-    def resize(self, *args):
-        return _py_interop_metrics.vector_q_metrics_resize(self, *args)
-
-    def insert(self, *args):
-        return _py_interop_metrics.vector_q_metrics_insert(self, *args)
-
-    def reserve(self, n):
-        return _py_interop_metrics.vector_q_metrics_reserve(self, n)
-
-    def capacity(self):
-        return _py_interop_metrics.vector_q_metrics_capacity(self)
-    __swig_destroy__ = _py_interop_metrics.delete_vector_q_metrics
-
-# Register vector_q_metrics in _py_interop_metrics:
-_py_interop_metrics.vector_q_metrics_swigregister(vector_q_metrics)
-class base_tile_metrics(tile_metric_header):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    TYPE = _py_interop_metrics.base_tile_metrics_TYPE
-    LATEST_VERSION = _py_interop_metrics.base_tile_metrics_LATEST_VERSION
-
-    def __init__(self, *args):
-        _py_interop_metrics.base_tile_metrics_swiginit(self, _py_interop_metrics.new_base_tile_metrics(*args))
-
-    def copy_by_tile(self, origin, tile_id):
-        return _py_interop_metrics.base_tile_metrics_copy_by_tile(self, origin, tile_id)
-
-    def append_tiles(self, origin, tile_id):
-        return _py_interop_metrics.base_tile_metrics_append_tiles(self, origin, tile_id)
-
-    def data_source_exists(self, *args):
-        return _py_interop_metrics.base_tile_metrics_data_source_exists(self, *args)
-
-    def sort(self):
-        return _py_interop_metrics.base_tile_metrics_sort(self)
-
-    def rebuild_index(self, update_ids=False):
-        return _py_interop_metrics.base_tile_metrics_rebuild_index(self, update_ids)
-
-    def resize(self, n):
-        return _py_interop_metrics.base_tile_metrics_resize(self, n)
-
-    def reserve(self, n):
-        return _py_interop_metrics.base_tile_metrics_reserve(self, n)
-
-    def trim(self, n):
-        return _py_interop_metrics.base_tile_metrics_trim(self, n)
-
-    def insert(self, *args):
-        return _py_interop_metrics.base_tile_metrics_insert(self, *args)
-
-    def at(self, n):
-        return _py_interop_metrics.base_tile_metrics_at(self, n)
-
-    def set_version(self, version):
-        return _py_interop_metrics.base_tile_metrics_set_version(self, version)
-
-    def keys(self):
-        return _py_interop_metrics.base_tile_metrics_keys(self)
-
-    def lanes(self):
-        return _py_interop_metrics.base_tile_metrics_lanes(self)
-
-    def lane_count(self):
-        return _py_interop_metrics.base_tile_metrics_lane_count(self)
-
-    def max_lane(self):
-        return _py_interop_metrics.base_tile_metrics_max_lane(self)
-
-    def tile_numbers_for_lane(self, lane):
-        return _py_interop_metrics.base_tile_metrics_tile_numbers_for_lane(self, lane)
-
-    def tile_numbers(self):
-        return _py_interop_metrics.base_tile_metrics_tile_numbers(self)
-
-    def metrics_for_lane(self, *args):
-        return _py_interop_metrics.base_tile_metrics_metrics_for_lane(self, *args)
-
-    def cycles(self):
-        return _py_interop_metrics.base_tile_metrics_cycles(self)
-
-    def metrics_for_cycle(self, cycle):
-        return _py_interop_metrics.base_tile_metrics_metrics_for_cycle(self, cycle)
-
-    def size(self):
-        return _py_interop_metrics.base_tile_metrics_size(self)
-
-    def empty(self):
-        return _py_interop_metrics.base_tile_metrics_empty(self)
-
-    def version(self):
-        return _py_interop_metrics.base_tile_metrics_version(self)
-
-    def clear(self):
-        return _py_interop_metrics.base_tile_metrics_clear(self)
-
-    def metrics(self):
-        return _py_interop_metrics.base_tile_metrics_metrics(self)
-
-    @staticmethod
-    def prefix():
-        return _py_interop_metrics.base_tile_metrics_prefix()
-
-    @staticmethod
-    def suffix():
-        return _py_interop_metrics.base_tile_metrics_suffix()
-
-    def get_metric_ref(self, *args):
-        return _py_interop_metrics.base_tile_metrics_get_metric_ref(self, *args)
-
-    def find(self, *args):
-        return _py_interop_metrics.base_tile_metrics_find(self, *args)
-
-    def get_metric(self, *args):
-        return _py_interop_metrics.base_tile_metrics_get_metric(self, *args)
-
-    def has_metric(self, *args):
-        return _py_interop_metrics.base_tile_metrics_has_metric(self, *args)
-
-    def clear_lookup(self):
-        return _py_interop_metrics.base_tile_metrics_clear_lookup(self)
-    __swig_destroy__ = _py_interop_metrics.delete_base_tile_metrics
-
-# Register base_tile_metrics in _py_interop_metrics:
-_py_interop_metrics.base_tile_metrics_swigregister(base_tile_metrics)
-class vector_tile_metrics(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _py_interop_metrics.vector_tile_metrics___nonzero__(self)
-
-    def __bool__(self):
-        return _py_interop_metrics.vector_tile_metrics___bool__(self)
-
-    def __len__(self):
-        return _py_interop_metrics.vector_tile_metrics___len__(self)
-
-    def __getslice__(self, i, j):
-        return _py_interop_metrics.vector_tile_metrics___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _py_interop_metrics.vector_tile_metrics___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _py_interop_metrics.vector_tile_metrics___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _py_interop_metrics.vector_tile_metrics___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _py_interop_metrics.vector_tile_metrics___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _py_interop_metrics.vector_tile_metrics___setitem__(self, *args)
-
-    def pop(self):
-        return _py_interop_metrics.vector_tile_metrics_pop(self)
-
-    def append(self, x):
-        return _py_interop_metrics.vector_tile_metrics_append(self, x)
-
-    def empty(self):
-        return _py_interop_metrics.vector_tile_metrics_empty(self)
-
-    def size(self):
-        return _py_interop_metrics.vector_tile_metrics_size(self)
-
-    def swap(self, v):
-        return _py_interop_metrics.vector_tile_metrics_swap(self, v)
-
-    def rbegin(self):
-        return _py_interop_metrics.vector_tile_metrics_rbegin(self)
-
-    def rend(self):
-        return _py_interop_metrics.vector_tile_metrics_rend(self)
-
-    def clear(self):
-        return _py_interop_metrics.vector_tile_metrics_clear(self)
-
-    def get_allocator(self):
-        return _py_interop_metrics.vector_tile_metrics_get_allocator(self)
-
-    def pop_back(self):
-        return _py_interop_metrics.vector_tile_metrics_pop_back(self)
-
-    def erase(self, *args):
-        return _py_interop_metrics.vector_tile_metrics_erase(self, *args)
-
-    def __init__(self, *args):
-        _py_interop_metrics.vector_tile_metrics_swiginit(self, _py_interop_metrics.new_vector_tile_metrics(*args))
-
-    def push_back(self, x):
-        return _py_interop_metrics.vector_tile_metrics_push_back(self, x)
-
-    def front(self):
-        return _py_interop_metrics.vector_tile_metrics_front(self)
-
-    def back(self):
-        return _py_interop_metrics.vector_tile_metrics_back(self)
-
-    def assign(self, n, x):
-        return _py_interop_metrics.vector_tile_metrics_assign(self, n, x)
-
-    def resize(self, *args):
-        return _py_interop_metrics.vector_tile_metrics_resize(self, *args)
-
-    def insert(self, *args):
-        return _py_interop_metrics.vector_tile_metrics_insert(self, *args)
-
-    def reserve(self, n):
-        return _py_interop_metrics.vector_tile_metrics_reserve(self, n)
-
-    def capacity(self):
-        return _py_interop_metrics.vector_tile_metrics_capacity(self)
-    __swig_destroy__ = _py_interop_metrics.delete_vector_tile_metrics
-
-# Register vector_tile_metrics in _py_interop_metrics:
-_py_interop_metrics.vector_tile_metrics_swigregister(vector_tile_metrics)
-class base_index_metrics(index_metric_header):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    TYPE = _py_interop_metrics.base_index_metrics_TYPE
-    LATEST_VERSION = _py_interop_metrics.base_index_metrics_LATEST_VERSION
-
-    def __init__(self, *args):
-        _py_interop_metrics.base_index_metrics_swiginit(self, _py_interop_metrics.new_base_index_metrics(*args))
-
-    def copy_by_tile(self, origin, tile_id):
-        return _py_interop_metrics.base_index_metrics_copy_by_tile(self, origin, tile_id)
-
-    def append_tiles(self, origin, tile_id):
-        return _py_interop_metrics.base_index_metrics_append_tiles(self, origin, tile_id)
-
-    def data_source_exists(self, *args):
-        return _py_interop_metrics.base_index_metrics_data_source_exists(self, *args)
-
-    def sort(self):
-        return _py_interop_metrics.base_index_metrics_sort(self)
-
-    def rebuild_index(self, update_ids=False):
-        return _py_interop_metrics.base_index_metrics_rebuild_index(self, update_ids)
-
-    def resize(self, n):
-        return _py_interop_metrics.base_index_metrics_resize(self, n)
-
-    def reserve(self, n):
-        return _py_interop_metrics.base_index_metrics_reserve(self, n)
-
-    def trim(self, n):
-        return _py_interop_metrics.base_index_metrics_trim(self, n)
-
-    def insert(self, *args):
-        return _py_interop_metrics.base_index_metrics_insert(self, *args)
-
-    def at(self, n):
-        return _py_interop_metrics.base_index_metrics_at(self, n)
-
-    def set_version(self, version):
-        return _py_interop_metrics.base_index_metrics_set_version(self, version)
-
-    def keys(self):
-        return _py_interop_metrics.base_index_metrics_keys(self)
-
-    def lanes(self):
-        return _py_interop_metrics.base_index_metrics_lanes(self)
-
-    def lane_count(self):
-        return _py_interop_metrics.base_index_metrics_lane_count(self)
-
-    def max_lane(self):
-        return _py_interop_metrics.base_index_metrics_max_lane(self)
-
-    def tile_numbers_for_lane(self, lane):
-        return _py_interop_metrics.base_index_metrics_tile_numbers_for_lane(self, lane)
-
-    def tile_numbers(self):
-        return _py_interop_metrics.base_index_metrics_tile_numbers(self)
-
-    def metrics_for_lane(self, *args):
-        return _py_interop_metrics.base_index_metrics_metrics_for_lane(self, *args)
-
-    def cycles(self):
-        return _py_interop_metrics.base_index_metrics_cycles(self)
-
-    def metrics_for_cycle(self, cycle):
-        return _py_interop_metrics.base_index_metrics_metrics_for_cycle(self, cycle)
-
-    def size(self):
-        return _py_interop_metrics.base_index_metrics_size(self)
-
-    def empty(self):
-        return _py_interop_metrics.base_index_metrics_empty(self)
-
-    def version(self):
-        return _py_interop_metrics.base_index_metrics_version(self)
-
-    def clear(self):
-        return _py_interop_metrics.base_index_metrics_clear(self)
-
-    def metrics(self):
-        return _py_interop_metrics.base_index_metrics_metrics(self)
-
-    @staticmethod
-    def prefix():
-        return _py_interop_metrics.base_index_metrics_prefix()
-
-    @staticmethod
-    def suffix():
-        return _py_interop_metrics.base_index_metrics_suffix()
-
-    def get_metric_ref(self, *args):
-        return _py_interop_metrics.base_index_metrics_get_metric_ref(self, *args)
-
-    def find(self, *args):
-        return _py_interop_metrics.base_index_metrics_find(self, *args)
-
-    def get_metric(self, *args):
-        return _py_interop_metrics.base_index_metrics_get_metric(self, *args)
-
-    def has_metric(self, *args):
-        return _py_interop_metrics.base_index_metrics_has_metric(self, *args)
-
-    def clear_lookup(self):
-        return _py_interop_metrics.base_index_metrics_clear_lookup(self)
-    __swig_destroy__ = _py_interop_metrics.delete_base_index_metrics
-
-# Register base_index_metrics in _py_interop_metrics:
-_py_interop_metrics.base_index_metrics_swigregister(base_index_metrics)
-class vector_index_metrics(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _py_interop_metrics.vector_index_metrics___nonzero__(self)
-
-    def __bool__(self):
-        return _py_interop_metrics.vector_index_metrics___bool__(self)
-
-    def __len__(self):
-        return _py_interop_metrics.vector_index_metrics___len__(self)
-
-    def __getslice__(self, i, j):
-        return _py_interop_metrics.vector_index_metrics___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _py_interop_metrics.vector_index_metrics___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _py_interop_metrics.vector_index_metrics___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _py_interop_metrics.vector_index_metrics___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _py_interop_metrics.vector_index_metrics___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _py_interop_metrics.vector_index_metrics___setitem__(self, *args)
-
-    def pop(self):
-        return _py_interop_metrics.vector_index_metrics_pop(self)
-
-    def append(self, x):
-        return _py_interop_metrics.vector_index_metrics_append(self, x)
-
-    def empty(self):
-        return _py_interop_metrics.vector_index_metrics_empty(self)
-
-    def size(self):
-        return _py_interop_metrics.vector_index_metrics_size(self)
-
-    def swap(self, v):
-        return _py_interop_metrics.vector_index_metrics_swap(self, v)
-
-    def rbegin(self):
-        return _py_interop_metrics.vector_index_metrics_rbegin(self)
-
-    def rend(self):
-        return _py_interop_metrics.vector_index_metrics_rend(self)
-
-    def clear(self):
-        return _py_interop_metrics.vector_index_metrics_clear(self)
-
-    def get_allocator(self):
-        return _py_interop_metrics.vector_index_metrics_get_allocator(self)
-
-    def pop_back(self):
-        return _py_interop_metrics.vector_index_metrics_pop_back(self)
-
-    def erase(self, *args):
-        return _py_interop_metrics.vector_index_metrics_erase(self, *args)
-
-    def __init__(self, *args):
-        _py_interop_metrics.vector_index_metrics_swiginit(self, _py_interop_metrics.new_vector_index_metrics(*args))
-
-    def push_back(self, x):
-        return _py_interop_metrics.vector_index_metrics_push_back(self, x)
-
-    def front(self):
-        return _py_interop_metrics.vector_index_metrics_front(self)
-
-    def back(self):
-        return _py_interop_metrics.vector_index_metrics_back(self)
-
-    def assign(self, n, x):
-        return _py_interop_metrics.vector_index_metrics_assign(self, n, x)
-
-    def resize(self, *args):
-        return _py_interop_metrics.vector_index_metrics_resize(self, *args)
-
-    def insert(self, *args):
-        return _py_interop_metrics.vector_index_metrics_insert(self, *args)
-
-    def reserve(self, n):
-        return _py_interop_metrics.vector_index_metrics_reserve(self, n)
-
-    def capacity(self):
-        return _py_interop_metrics.vector_index_metrics_capacity(self)
-    __swig_destroy__ = _py_interop_metrics.delete_vector_index_metrics
-
-# Register vector_index_metrics in _py_interop_metrics:
-_py_interop_metrics.vector_index_metrics_swigregister(vector_index_metrics)
-class base_q_collapsed_metrics(q_collapsed_header):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    TYPE = _py_interop_metrics.base_q_collapsed_metrics_TYPE
-    LATEST_VERSION = _py_interop_metrics.base_q_collapsed_metrics_LATEST_VERSION
-
-    def __init__(self, *args):
-        _py_interop_metrics.base_q_collapsed_metrics_swiginit(self, _py_interop_metrics.new_base_q_collapsed_metrics(*args))
-
-    def copy_by_tile(self, origin, tile_id):
-        return _py_interop_metrics.base_q_collapsed_metrics_copy_by_tile(self, origin, tile_id)
-
-    def append_tiles(self, origin, tile_id):
-        return _py_interop_metrics.base_q_collapsed_metrics_append_tiles(self, origin, tile_id)
-
-    def data_source_exists(self, *args):
-        return _py_interop_metrics.base_q_collapsed_metrics_data_source_exists(self, *args)
-
-    def sort(self):
-        return _py_interop_metrics.base_q_collapsed_metrics_sort(self)
-
-    def rebuild_index(self, update_ids=False):
-        return _py_interop_metrics.base_q_collapsed_metrics_rebuild_index(self, update_ids)
-
-    def resize(self, n):
-        return _py_interop_metrics.base_q_collapsed_metrics_resize(self, n)
-
-    def reserve(self, n):
-        return _py_interop_metrics.base_q_collapsed_metrics_reserve(self, n)
-
-    def trim(self, n):
-        return _py_interop_metrics.base_q_collapsed_metrics_trim(self, n)
-
-    def insert(self, *args):
-        return _py_interop_metrics.base_q_collapsed_metrics_insert(self, *args)
-
-    def at(self, n):
-        return _py_interop_metrics.base_q_collapsed_metrics_at(self, n)
-
-    def set_version(self, version):
-        return _py_interop_metrics.base_q_collapsed_metrics_set_version(self, version)
-
-    def keys(self):
-        return _py_interop_metrics.base_q_collapsed_metrics_keys(self)
-
-    def lanes(self):
-        return _py_interop_metrics.base_q_collapsed_metrics_lanes(self)
-
-    def lane_count(self):
-        return _py_interop_metrics.base_q_collapsed_metrics_lane_count(self)
-
-    def max_lane(self):
-        return _py_interop_metrics.base_q_collapsed_metrics_max_lane(self)
-
-    def tile_numbers_for_lane(self, lane):
-        return _py_interop_metrics.base_q_collapsed_metrics_tile_numbers_for_lane(self, lane)
-
-    def tile_numbers(self):
-        return _py_interop_metrics.base_q_collapsed_metrics_tile_numbers(self)
-
-    def metrics_for_lane(self, *args):
-        return _py_interop_metrics.base_q_collapsed_metrics_metrics_for_lane(self, *args)
-
-    def cycles(self):
-        return _py_interop_metrics.base_q_collapsed_metrics_cycles(self)
-
-    def metrics_for_cycle(self, cycle):
-        return _py_interop_metrics.base_q_collapsed_metrics_metrics_for_cycle(self, cycle)
-
-    def size(self):
-        return _py_interop_metrics.base_q_collapsed_metrics_size(self)
-
-    def empty(self):
-        return _py_interop_metrics.base_q_collapsed_metrics_empty(self)
-
-    def version(self):
-        return _py_interop_metrics.base_q_collapsed_metrics_version(self)
-
-    def clear(self):
-        return _py_interop_metrics.base_q_collapsed_metrics_clear(self)
-
-    def metrics(self):
-        return _py_interop_metrics.base_q_collapsed_metrics_metrics(self)
-
-    @staticmethod
-    def prefix():
-        return _py_interop_metrics.base_q_collapsed_metrics_prefix()
-
-    @staticmethod
-    def suffix():
-        return _py_interop_metrics.base_q_collapsed_metrics_suffix()
-
-    def get_metric_ref(self, *args):
-        return _py_interop_metrics.base_q_collapsed_metrics_get_metric_ref(self, *args)
-
-    def find(self, *args):
-        return _py_interop_metrics.base_q_collapsed_metrics_find(self, *args)
-
-    def get_metric(self, *args):
-        return _py_interop_metrics.base_q_collapsed_metrics_get_metric(self, *args)
-
-    def has_metric(self, *args):
-        return _py_interop_metrics.base_q_collapsed_metrics_has_metric(self, *args)
-
-    def clear_lookup(self):
-        return _py_interop_metrics.base_q_collapsed_metrics_clear_lookup(self)
-    __swig_destroy__ = _py_interop_metrics.delete_base_q_collapsed_metrics
-
-# Register base_q_collapsed_metrics in _py_interop_metrics:
-_py_interop_metrics.base_q_collapsed_metrics_swigregister(base_q_collapsed_metrics)
-class vector_q_collapsed_metrics(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _py_interop_metrics.vector_q_collapsed_metrics___nonzero__(self)
-
-    def __bool__(self):
-        return _py_interop_metrics.vector_q_collapsed_metrics___bool__(self)
-
-    def __len__(self):
-        return _py_interop_metrics.vector_q_collapsed_metrics___len__(self)
-
-    def __getslice__(self, i, j):
-        return _py_interop_metrics.vector_q_collapsed_metrics___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _py_interop_metrics.vector_q_collapsed_metrics___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _py_interop_metrics.vector_q_collapsed_metrics___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _py_interop_metrics.vector_q_collapsed_metrics___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _py_interop_metrics.vector_q_collapsed_metrics___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _py_interop_metrics.vector_q_collapsed_metrics___setitem__(self, *args)
-
-    def pop(self):
-        return _py_interop_metrics.vector_q_collapsed_metrics_pop(self)
-
-    def append(self, x):
-        return _py_interop_metrics.vector_q_collapsed_metrics_append(self, x)
-
-    def empty(self):
-        return _py_interop_metrics.vector_q_collapsed_metrics_empty(self)
-
-    def size(self):
-        return _py_interop_metrics.vector_q_collapsed_metrics_size(self)
-
-    def swap(self, v):
-        return _py_interop_metrics.vector_q_collapsed_metrics_swap(self, v)
-
-    def rbegin(self):
-        return _py_interop_metrics.vector_q_collapsed_metrics_rbegin(self)
-
-    def rend(self):
-        return _py_interop_metrics.vector_q_collapsed_metrics_rend(self)
-
-    def clear(self):
-        return _py_interop_metrics.vector_q_collapsed_metrics_clear(self)
-
-    def get_allocator(self):
-        return _py_interop_metrics.vector_q_collapsed_metrics_get_allocator(self)
-
-    def pop_back(self):
-        return _py_interop_metrics.vector_q_collapsed_metrics_pop_back(self)
-
-    def erase(self, *args):
-        return _py_interop_metrics.vector_q_collapsed_metrics_erase(self, *args)
-
-    def __init__(self, *args):
-        _py_interop_metrics.vector_q_collapsed_metrics_swiginit(self, _py_interop_metrics.new_vector_q_collapsed_metrics(*args))
-
-    def push_back(self, x):
-        return _py_interop_metrics.vector_q_collapsed_metrics_push_back(self, x)
-
-    def front(self):
-        return _py_interop_metrics.vector_q_collapsed_metrics_front(self)
-
-    def back(self):
-        return _py_interop_metrics.vector_q_collapsed_metrics_back(self)
-
-    def assign(self, n, x):
-        return _py_interop_metrics.vector_q_collapsed_metrics_assign(self, n, x)
-
-    def resize(self, *args):
-        return _py_interop_metrics.vector_q_collapsed_metrics_resize(self, *args)
-
-    def insert(self, *args):
-        return _py_interop_metrics.vector_q_collapsed_metrics_insert(self, *args)
-
-    def reserve(self, n):
-        return _py_interop_metrics.vector_q_collapsed_metrics_reserve(self, n)
-
-    def capacity(self):
-        return _py_interop_metrics.vector_q_collapsed_metrics_capacity(self)
-    __swig_destroy__ = _py_interop_metrics.delete_vector_q_collapsed_metrics
-
-# Register vector_q_collapsed_metrics in _py_interop_metrics:
-_py_interop_metrics.vector_q_collapsed_metrics_swigregister(vector_q_collapsed_metrics)
-class base_q_by_lane_metrics(q_score_header):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    TYPE = _py_interop_metrics.base_q_by_lane_metrics_TYPE
-    LATEST_VERSION = _py_interop_metrics.base_q_by_lane_metrics_LATEST_VERSION
-
-    def __init__(self, *args):
-        _py_interop_metrics.base_q_by_lane_metrics_swiginit(self, _py_interop_metrics.new_base_q_by_lane_metrics(*args))
-
-    def copy_by_tile(self, origin, tile_id):
-        return _py_interop_metrics.base_q_by_lane_metrics_copy_by_tile(self, origin, tile_id)
-
-    def append_tiles(self, origin, tile_id):
-        return _py_interop_metrics.base_q_by_lane_metrics_append_tiles(self, origin, tile_id)
-
-    def data_source_exists(self, *args):
-        return _py_interop_metrics.base_q_by_lane_metrics_data_source_exists(self, *args)
-
-    def sort(self):
-        return _py_interop_metrics.base_q_by_lane_metrics_sort(self)
-
-    def rebuild_index(self, update_ids=False):
-        return _py_interop_metrics.base_q_by_lane_metrics_rebuild_index(self, update_ids)
-
-    def resize(self, n):
-        return _py_interop_metrics.base_q_by_lane_metrics_resize(self, n)
-
-    def reserve(self, n):
-        return _py_interop_metrics.base_q_by_lane_metrics_reserve(self, n)
-
-    def trim(self, n):
-        return _py_interop_metrics.base_q_by_lane_metrics_trim(self, n)
-
-    def insert(self, *args):
-        return _py_interop_metrics.base_q_by_lane_metrics_insert(self, *args)
-
-    def at(self, n):
-        return _py_interop_metrics.base_q_by_lane_metrics_at(self, n)
-
-    def set_version(self, version):
-        return _py_interop_metrics.base_q_by_lane_metrics_set_version(self, version)
-
-    def keys(self):
-        return _py_interop_metrics.base_q_by_lane_metrics_keys(self)
-
-    def lanes(self):
-        return _py_interop_metrics.base_q_by_lane_metrics_lanes(self)
-
-    def lane_count(self):
-        return _py_interop_metrics.base_q_by_lane_metrics_lane_count(self)
-
-    def max_lane(self):
-        return _py_interop_metrics.base_q_by_lane_metrics_max_lane(self)
-
-    def tile_numbers_for_lane(self, lane):
-        return _py_interop_metrics.base_q_by_lane_metrics_tile_numbers_for_lane(self, lane)
-
-    def tile_numbers(self):
-        return _py_interop_metrics.base_q_by_lane_metrics_tile_numbers(self)
-
-    def metrics_for_lane(self, *args):
-        return _py_interop_metrics.base_q_by_lane_metrics_metrics_for_lane(self, *args)
-
-    def cycles(self):
-        return _py_interop_metrics.base_q_by_lane_metrics_cycles(self)
-
-    def metrics_for_cycle(self, cycle):
-        return _py_interop_metrics.base_q_by_lane_metrics_metrics_for_cycle(self, cycle)
-
-    def size(self):
-        return _py_interop_metrics.base_q_by_lane_metrics_size(self)
-
-    def empty(self):
-        return _py_interop_metrics.base_q_by_lane_metrics_empty(self)
-
-    def version(self):
-        return _py_interop_metrics.base_q_by_lane_metrics_version(self)
-
-    def clear(self):
-        return _py_interop_metrics.base_q_by_lane_metrics_clear(self)
-
-    def metrics(self):
-        return _py_interop_metrics.base_q_by_lane_metrics_metrics(self)
-
-    @staticmethod
-    def prefix():
-        return _py_interop_metrics.base_q_by_lane_metrics_prefix()
-
-    @staticmethod
-    def suffix():
-        return _py_interop_metrics.base_q_by_lane_metrics_suffix()
-
-    def get_metric_ref(self, *args):
-        return _py_interop_metrics.base_q_by_lane_metrics_get_metric_ref(self, *args)
-
-    def find(self, *args):
-        return _py_interop_metrics.base_q_by_lane_metrics_find(self, *args)
-
-    def get_metric(self, *args):
-        return _py_interop_metrics.base_q_by_lane_metrics_get_metric(self, *args)
-
-    def has_metric(self, *args):
-        return _py_interop_metrics.base_q_by_lane_metrics_has_metric(self, *args)
-
-    def clear_lookup(self):
-        return _py_interop_metrics.base_q_by_lane_metrics_clear_lookup(self)
-    __swig_destroy__ = _py_interop_metrics.delete_base_q_by_lane_metrics
-
-# Register base_q_by_lane_metrics in _py_interop_metrics:
-_py_interop_metrics.base_q_by_lane_metrics_swigregister(base_q_by_lane_metrics)
-class vector_q_by_lane_metrics(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _py_interop_metrics.vector_q_by_lane_metrics___nonzero__(self)
-
-    def __bool__(self):
-        return _py_interop_metrics.vector_q_by_lane_metrics___bool__(self)
-
-    def __len__(self):
-        return _py_interop_metrics.vector_q_by_lane_metrics___len__(self)
-
-    def __getslice__(self, i, j):
-        return _py_interop_metrics.vector_q_by_lane_metrics___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _py_interop_metrics.vector_q_by_lane_metrics___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _py_interop_metrics.vector_q_by_lane_metrics___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _py_interop_metrics.vector_q_by_lane_metrics___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _py_interop_metrics.vector_q_by_lane_metrics___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _py_interop_metrics.vector_q_by_lane_metrics___setitem__(self, *args)
-
-    def pop(self):
-        return _py_interop_metrics.vector_q_by_lane_metrics_pop(self)
-
-    def append(self, x):
-        return _py_interop_metrics.vector_q_by_lane_metrics_append(self, x)
-
-    def empty(self):
-        return _py_interop_metrics.vector_q_by_lane_metrics_empty(self)
-
-    def size(self):
-        return _py_interop_metrics.vector_q_by_lane_metrics_size(self)
-
-    def swap(self, v):
-        return _py_interop_metrics.vector_q_by_lane_metrics_swap(self, v)
-
-    def rbegin(self):
-        return _py_interop_metrics.vector_q_by_lane_metrics_rbegin(self)
-
-    def rend(self):
-        return _py_interop_metrics.vector_q_by_lane_metrics_rend(self)
-
-    def clear(self):
-        return _py_interop_metrics.vector_q_by_lane_metrics_clear(self)
-
-    def get_allocator(self):
-        return _py_interop_metrics.vector_q_by_lane_metrics_get_allocator(self)
-
-    def pop_back(self):
-        return _py_interop_metrics.vector_q_by_lane_metrics_pop_back(self)
-
-    def erase(self, *args):
-        return _py_interop_metrics.vector_q_by_lane_metrics_erase(self, *args)
-
-    def __init__(self, *args):
-        _py_interop_metrics.vector_q_by_lane_metrics_swiginit(self, _py_interop_metrics.new_vector_q_by_lane_metrics(*args))
-
-    def push_back(self, x):
-        return _py_interop_metrics.vector_q_by_lane_metrics_push_back(self, x)
-
-    def front(self):
-        return _py_interop_metrics.vector_q_by_lane_metrics_front(self)
-
-    def back(self):
-        return _py_interop_metrics.vector_q_by_lane_metrics_back(self)
-
-    def assign(self, n, x):
-        return _py_interop_metrics.vector_q_by_lane_metrics_assign(self, n, x)
-
-    def resize(self, *args):
-        return _py_interop_metrics.vector_q_by_lane_metrics_resize(self, *args)
-
-    def insert(self, *args):
-        return _py_interop_metrics.vector_q_by_lane_metrics_insert(self, *args)
-
-    def reserve(self, n):
-        return _py_interop_metrics.vector_q_by_lane_metrics_reserve(self, n)
-
-    def capacity(self):
-        return _py_interop_metrics.vector_q_by_lane_metrics_capacity(self)
-    __swig_destroy__ = _py_interop_metrics.delete_vector_q_by_lane_metrics
-
-# Register vector_q_by_lane_metrics in _py_interop_metrics:
-_py_interop_metrics.vector_q_by_lane_metrics_swigregister(vector_q_by_lane_metrics)
-class base_summary_run_metrics(base_metric_header):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    TYPE = _py_interop_metrics.base_summary_run_metrics_TYPE
-    LATEST_VERSION = _py_interop_metrics.base_summary_run_metrics_LATEST_VERSION
-
-    def __init__(self, *args):
-        _py_interop_metrics.base_summary_run_metrics_swiginit(self, _py_interop_metrics.new_base_summary_run_metrics(*args))
-
-    def copy_by_tile(self, origin, tile_id):
-        return _py_interop_metrics.base_summary_run_metrics_copy_by_tile(self, origin, tile_id)
-
-    def append_tiles(self, origin, tile_id):
-        return _py_interop_metrics.base_summary_run_metrics_append_tiles(self, origin, tile_id)
-
-    def data_source_exists(self, *args):
-        return _py_interop_metrics.base_summary_run_metrics_data_source_exists(self, *args)
-
-    def sort(self):
-        return _py_interop_metrics.base_summary_run_metrics_sort(self)
-
-    def rebuild_index(self, update_ids=False):
-        return _py_interop_metrics.base_summary_run_metrics_rebuild_index(self, update_ids)
-
-    def resize(self, n):
-        return _py_interop_metrics.base_summary_run_metrics_resize(self, n)
-
-    def reserve(self, n):
-        return _py_interop_metrics.base_summary_run_metrics_reserve(self, n)
-
-    def trim(self, n):
-        return _py_interop_metrics.base_summary_run_metrics_trim(self, n)
-
-    def insert(self, *args):
-        return _py_interop_metrics.base_summary_run_metrics_insert(self, *args)
-
-    def at(self, n):
-        return _py_interop_metrics.base_summary_run_metrics_at(self, n)
-
-    def set_version(self, version):
-        return _py_interop_metrics.base_summary_run_metrics_set_version(self, version)
-
-    def keys(self):
-        return _py_interop_metrics.base_summary_run_metrics_keys(self)
-
-    def lanes(self):
-        return _py_interop_metrics.base_summary_run_metrics_lanes(self)
-
-    def lane_count(self):
-        return _py_interop_metrics.base_summary_run_metrics_lane_count(self)
-
-    def max_lane(self):
-        return _py_interop_metrics.base_summary_run_metrics_max_lane(self)
-
-    def tile_numbers_for_lane(self, lane):
-        return _py_interop_metrics.base_summary_run_metrics_tile_numbers_for_lane(self, lane)
-
-    def tile_numbers(self):
-        return _py_interop_metrics.base_summary_run_metrics_tile_numbers(self)
-
-    def metrics_for_lane(self, *args):
-        return _py_interop_metrics.base_summary_run_metrics_metrics_for_lane(self, *args)
-
-    def cycles(self):
-        return _py_interop_metrics.base_summary_run_metrics_cycles(self)
-
-    def metrics_for_cycle(self, cycle):
-        return _py_interop_metrics.base_summary_run_metrics_metrics_for_cycle(self, cycle)
-
-    def size(self):
-        return _py_interop_metrics.base_summary_run_metrics_size(self)
-
-    def empty(self):
-        return _py_interop_metrics.base_summary_run_metrics_empty(self)
-
-    def version(self):
-        return _py_interop_metrics.base_summary_run_metrics_version(self)
-
-    def clear(self):
-        return _py_interop_metrics.base_summary_run_metrics_clear(self)
-
-    def metrics(self):
-        return _py_interop_metrics.base_summary_run_metrics_metrics(self)
-
-    @staticmethod
-    def prefix():
-        return _py_interop_metrics.base_summary_run_metrics_prefix()
-
-    @staticmethod
-    def suffix():
-        return _py_interop_metrics.base_summary_run_metrics_suffix()
-
-    def get_metric_ref(self, *args):
-        return _py_interop_metrics.base_summary_run_metrics_get_metric_ref(self, *args)
-
-    def find(self, *args):
-        return _py_interop_metrics.base_summary_run_metrics_find(self, *args)
-
-    def get_metric(self, *args):
-        return _py_interop_metrics.base_summary_run_metrics_get_metric(self, *args)
-
-    def has_metric(self, *args):
-        return _py_interop_metrics.base_summary_run_metrics_has_metric(self, *args)
-
-    def clear_lookup(self):
-        return _py_interop_metrics.base_summary_run_metrics_clear_lookup(self)
-    __swig_destroy__ = _py_interop_metrics.delete_base_summary_run_metrics
-
-# Register base_summary_run_metrics in _py_interop_metrics:
-_py_interop_metrics.base_summary_run_metrics_swigregister(base_summary_run_metrics)
-class vector_summary_run_metrics(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _py_interop_metrics.vector_summary_run_metrics___nonzero__(self)
-
-    def __bool__(self):
-        return _py_interop_metrics.vector_summary_run_metrics___bool__(self)
-
-    def __len__(self):
-        return _py_interop_metrics.vector_summary_run_metrics___len__(self)
-
-    def __getslice__(self, i, j):
-        return _py_interop_metrics.vector_summary_run_metrics___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _py_interop_metrics.vector_summary_run_metrics___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _py_interop_metrics.vector_summary_run_metrics___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _py_interop_metrics.vector_summary_run_metrics___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _py_interop_metrics.vector_summary_run_metrics___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _py_interop_metrics.vector_summary_run_metrics___setitem__(self, *args)
-
-    def pop(self):
-        return _py_interop_metrics.vector_summary_run_metrics_pop(self)
-
-    def append(self, x):
-        return _py_interop_metrics.vector_summary_run_metrics_append(self, x)
-
-    def empty(self):
-        return _py_interop_metrics.vector_summary_run_metrics_empty(self)
-
-    def size(self):
-        return _py_interop_metrics.vector_summary_run_metrics_size(self)
-
-    def swap(self, v):
-        return _py_interop_metrics.vector_summary_run_metrics_swap(self, v)
-
-    def rbegin(self):
-        return _py_interop_metrics.vector_summary_run_metrics_rbegin(self)
-
-    def rend(self):
-        return _py_interop_metrics.vector_summary_run_metrics_rend(self)
-
-    def clear(self):
-        return _py_interop_metrics.vector_summary_run_metrics_clear(self)
-
-    def get_allocator(self):
-        return _py_interop_metrics.vector_summary_run_metrics_get_allocator(self)
-
-    def pop_back(self):
-        return _py_interop_metrics.vector_summary_run_metrics_pop_back(self)
-
-    def erase(self, *args):
-        return _py_interop_metrics.vector_summary_run_metrics_erase(self, *args)
-
-    def __init__(self, *args):
-        _py_interop_metrics.vector_summary_run_metrics_swiginit(self, _py_interop_metrics.new_vector_summary_run_metrics(*args))
-
-    def push_back(self, x):
-        return _py_interop_metrics.vector_summary_run_metrics_push_back(self, x)
-
-    def front(self):
-        return _py_interop_metrics.vector_summary_run_metrics_front(self)
-
-    def back(self):
-        return _py_interop_metrics.vector_summary_run_metrics_back(self)
-
-    def assign(self, n, x):
-        return _py_interop_metrics.vector_summary_run_metrics_assign(self, n, x)
-
-    def resize(self, *args):
-        return _py_interop_metrics.vector_summary_run_metrics_resize(self, *args)
-
-    def insert(self, *args):
-        return _py_interop_metrics.vector_summary_run_metrics_insert(self, *args)
-
-    def reserve(self, n):
-        return _py_interop_metrics.vector_summary_run_metrics_reserve(self, n)
-
-    def capacity(self):
-        return _py_interop_metrics.vector_summary_run_metrics_capacity(self)
-    __swig_destroy__ = _py_interop_metrics.delete_vector_summary_run_metrics
-
-# Register vector_summary_run_metrics in _py_interop_metrics:
-_py_interop_metrics.vector_summary_run_metrics_swigregister(vector_summary_run_metrics)
-
+# This file was automatically generated by SWIG (http://www.swig.org).
+# Version 4.0.2
+#
+# Do not make changes to this file unless you know what you are doing--modify
+# the SWIG interface file instead.
+
+from sys import version_info as _swig_python_version_info
+if _swig_python_version_info < (2, 7, 0):
+    raise RuntimeError("Python 2.7 or later required")
+
+# Import the low-level C/C++ module
+if __package__ or "." in __name__:
+    from . import _py_interop_metrics
+else:
+    import _py_interop_metrics
+
+try:
+    import builtins as __builtin__
+except ImportError:
+    import __builtin__
+
+def _swig_repr(self):
+    try:
+        strthis = "proxy of " + self.this.__repr__()
+    except __builtin__.Exception:
+        strthis = ""
+    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)
+
+
+def _swig_setattr_nondynamic_instance_variable(set):
+    def set_instance_attr(self, name, value):
+        if name == "thisown":
+            self.this.own(value)
+        elif name == "this":
+            set(self, name, value)
+        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
+            set(self, name, value)
+        else:
+            raise AttributeError("You cannot add instance attributes to %s" % self)
+    return set_instance_attr
+
+
+def _swig_setattr_nondynamic_class_variable(set):
+    def set_class_attr(cls, name, value):
+        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
+            set(cls, name, value)
+        else:
+            raise AttributeError("You cannot add class attributes to %s" % cls)
+    return set_class_attr
+
+
+def _swig_add_metaclass(metaclass):
+    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
+    def wrapper(cls):
+        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
+    return wrapper
+
+
+class _SwigNonDynamicMeta(type):
+    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
+    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)
+
+
+class SwigPyIterator(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined - class is abstract")
+    __repr__ = _swig_repr
+    __swig_destroy__ = _py_interop_metrics.delete_SwigPyIterator
+
+    def value(self):
+        return _py_interop_metrics.SwigPyIterator_value(self)
+
+    def incr(self, n=1):
+        return _py_interop_metrics.SwigPyIterator_incr(self, n)
+
+    def decr(self, n=1):
+        return _py_interop_metrics.SwigPyIterator_decr(self, n)
+
+    def distance(self, x):
+        return _py_interop_metrics.SwigPyIterator_distance(self, x)
+
+    def equal(self, x):
+        return _py_interop_metrics.SwigPyIterator_equal(self, x)
+
+    def copy(self):
+        return _py_interop_metrics.SwigPyIterator_copy(self)
+
+    def next(self):
+        return _py_interop_metrics.SwigPyIterator_next(self)
+
+    def __next__(self):
+        return _py_interop_metrics.SwigPyIterator___next__(self)
+
+    def previous(self):
+        return _py_interop_metrics.SwigPyIterator_previous(self)
+
+    def advance(self, n):
+        return _py_interop_metrics.SwigPyIterator_advance(self, n)
+
+    def __eq__(self, x):
+        return _py_interop_metrics.SwigPyIterator___eq__(self, x)
+
+    def __ne__(self, x):
+        return _py_interop_metrics.SwigPyIterator___ne__(self, x)
+
+    def __iadd__(self, n):
+        return _py_interop_metrics.SwigPyIterator___iadd__(self, n)
+
+    def __isub__(self, n):
+        return _py_interop_metrics.SwigPyIterator___isub__(self, n)
+
+    def __add__(self, n):
+        return _py_interop_metrics.SwigPyIterator___add__(self, n)
+
+    def __sub__(self, *args):
+        return _py_interop_metrics.SwigPyIterator___sub__(self, *args)
+    def __iter__(self):
+        return self
+
+# Register SwigPyIterator in _py_interop_metrics:
+_py_interop_metrics.SwigPyIterator_swigregister(SwigPyIterator)
+
+import interop.py_interop_run
+class index_out_of_bounds_exception(interop.py_interop_run.base_exception):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, mesg):
+        _py_interop_metrics.index_out_of_bounds_exception_swiginit(self, _py_interop_metrics.new_index_out_of_bounds_exception(mesg))
+
+    def __str__(self):
+        return _py_interop_metrics.index_out_of_bounds_exception___str__(self)
+    __swig_destroy__ = _py_interop_metrics.delete_index_out_of_bounds_exception
+
+# Register index_out_of_bounds_exception in _py_interop_metrics:
+_py_interop_metrics.index_out_of_bounds_exception_swigregister(index_out_of_bounds_exception)
+
+class csharp_date_time(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, v=0):
+        _py_interop_metrics.csharp_date_time_swiginit(self, _py_interop_metrics.new_csharp_date_time(v))
+
+    @staticmethod
+    def to_unix(*args):
+        return _py_interop_metrics.csharp_date_time_to_unix(*args)
+
+    @staticmethod
+    def to_seconds(*args):
+        return _py_interop_metrics.csharp_date_time_to_seconds(*args)
+
+    @staticmethod
+    def to_csharp(uval):
+        return _py_interop_metrics.csharp_date_time_to_csharp(uval)
+    value = property(_py_interop_metrics.csharp_date_time_value_get, _py_interop_metrics.csharp_date_time_value_set)
+
+    def to_int(self):
+        return _py_interop_metrics.csharp_date_time_to_int(self)
+
+    def to_binary(self):
+        return _py_interop_metrics.csharp_date_time_to_binary(self)
+
+    def __eq__(self, other):
+        return _py_interop_metrics.csharp_date_time___eq__(self, other)
+    __swig_destroy__ = _py_interop_metrics.delete_csharp_date_time
+
+# Register csharp_date_time in _py_interop_metrics:
+_py_interop_metrics.csharp_date_time_swigregister(csharp_date_time)
+
+def csharp_date_time_to_unix(*args):
+    return _py_interop_metrics.csharp_date_time_to_unix(*args)
+
+def csharp_date_time_to_seconds(*args):
+    return _py_interop_metrics.csharp_date_time_to_seconds(*args)
+
+def csharp_date_time_to_csharp(uval):
+    return _py_interop_metrics.csharp_date_time_to_csharp(uval)
+
+class empty_header(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self):
+        _py_interop_metrics.empty_header_swiginit(self, _py_interop_metrics.new_empty_header())
+    __swig_destroy__ = _py_interop_metrics.delete_empty_header
+
+# Register empty_header in _py_interop_metrics:
+_py_interop_metrics.empty_header_swigregister(empty_header)
+
+class base_metric_header(empty_header):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    @staticmethod
+    def default_header():
+        return _py_interop_metrics.base_metric_header_default_header()
+
+    def __init__(self):
+        _py_interop_metrics.base_metric_header_swiginit(self, _py_interop_metrics.new_base_metric_header())
+    __swig_destroy__ = _py_interop_metrics.delete_base_metric_header
+
+# Register base_metric_header in _py_interop_metrics:
+_py_interop_metrics.base_metric_header_swigregister(base_metric_header)
+
+def base_metric_header_default_header():
+    return _py_interop_metrics.base_metric_header_default_header()
+
+class empty_metric(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def set_base(self, arg2, arg3):
+        return _py_interop_metrics.empty_metric_set_base(self, arg2, arg3)
+
+    @staticmethod
+    def suffix():
+        return _py_interop_metrics.empty_metric_suffix()
+
+    def __lt__(self, arg2):
+        return _py_interop_metrics.empty_metric___lt__(self, arg2)
+
+    @staticmethod
+    def create_id(arg1, arg2, arg3=0):
+        return _py_interop_metrics.empty_metric_create_id(arg1, arg2, arg3)
+
+    def __init__(self):
+        _py_interop_metrics.empty_metric_swiginit(self, _py_interop_metrics.new_empty_metric())
+    __swig_destroy__ = _py_interop_metrics.delete_empty_metric
+
+# Register empty_metric in _py_interop_metrics:
+_py_interop_metrics.empty_metric_swigregister(empty_metric)
+
+def empty_metric_suffix():
+    return _py_interop_metrics.empty_metric_suffix()
+
+def empty_metric_create_id(arg1, arg2, arg3=0):
+    return _py_interop_metrics.empty_metric_create_id(arg1, arg2, arg3)
+
+class base_metric(empty_metric):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    LANE_BIT_COUNT = _py_interop_metrics.base_metric_LANE_BIT_COUNT
+    TILE_BIT_COUNT = _py_interop_metrics.base_metric_TILE_BIT_COUNT
+    CYCLE_BIT_COUNT = _py_interop_metrics.base_metric_CYCLE_BIT_COUNT
+    READ_BIT_COUNT = _py_interop_metrics.base_metric_READ_BIT_COUNT
+    RESERVED_BIT_COUNT = _py_interop_metrics.base_metric_RESERVED_BIT_COUNT
+    READ_BIT_SHIFT = _py_interop_metrics.base_metric_READ_BIT_SHIFT
+    CYCLE_BIT_SHIFT = _py_interop_metrics.base_metric_CYCLE_BIT_SHIFT
+    TILE_BIT_SHIFT = _py_interop_metrics.base_metric_TILE_BIT_SHIFT
+    LANE_BIT_SHIFT = _py_interop_metrics.base_metric_LANE_BIT_SHIFT
+
+    def __init__(self, lane=0, tile=0):
+        _py_interop_metrics.base_metric_swiginit(self, _py_interop_metrics.new_base_metric(lane, tile))
+
+    def set_base(self, lane, tile):
+        return _py_interop_metrics.base_metric_set_base(self, lane, tile)
+
+    def id(self):
+        return _py_interop_metrics.base_metric_id(self)
+
+    def tile_hash(self):
+        return _py_interop_metrics.base_metric_tile_hash(self)
+
+    @staticmethod
+    def create_id(lane, tile, arg3=0):
+        return _py_interop_metrics.base_metric_create_id(lane, tile, arg3)
+
+    @staticmethod
+    def lane_from_id(id):
+        return _py_interop_metrics.base_metric_lane_from_id(id)
+
+    @staticmethod
+    def tile_hash_from_id(id):
+        return _py_interop_metrics.base_metric_tile_hash_from_id(id)
+
+    @staticmethod
+    def tile_from_id(id):
+        return _py_interop_metrics.base_metric_tile_from_id(id)
+
+    def lane(self):
+        return _py_interop_metrics.base_metric_lane(self)
+
+    def tile(self):
+        return _py_interop_metrics.base_metric_tile(self)
+
+    def number(self, arg2):
+        return _py_interop_metrics.base_metric_number(self, arg2)
+
+    def section(self, method):
+        return _py_interop_metrics.base_metric_section(self, method)
+
+    def surface(self, method):
+        return _py_interop_metrics.base_metric_surface(self, method)
+
+    def swath(self, method):
+        return _py_interop_metrics.base_metric_swath(self, method)
+
+    def phyiscalLocationIndex(self, method, section_per_lane, tile_count, swath_count, all_surfaces):
+        return _py_interop_metrics.base_metric_phyiscalLocationIndex(self, method, section_per_lane, tile_count, swath_count, all_surfaces)
+
+    def phyiscalLocationColumn(self, method, swath_count, all_surfaces):
+        return _py_interop_metrics.base_metric_phyiscalLocationColumn(self, method, swath_count, all_surfaces)
+
+    def phyiscalLocationRow(self, method, section_per_lane, tile_count):
+        return _py_interop_metrics.base_metric_phyiscalLocationRow(self, method, section_per_lane, tile_count)
+
+    def physical_location_index(self, method, section_per_lane, tile_count, swath_count, all_surfaces):
+        return _py_interop_metrics.base_metric_physical_location_index(self, method, section_per_lane, tile_count, swath_count, all_surfaces)
+
+    def physical_location_column(self, method, swath_count, all_surfaces):
+        return _py_interop_metrics.base_metric_physical_location_column(self, method, swath_count, all_surfaces)
+
+    def physical_location_row(self, method, section_per_lane, tile_count):
+        return _py_interop_metrics.base_metric_physical_location_row(self, method, section_per_lane, tile_count)
+
+    @staticmethod
+    def suffix():
+        return _py_interop_metrics.base_metric_suffix()
+
+    def __lt__(self, metric2):
+        return _py_interop_metrics.base_metric___lt__(self, metric2)
+    __swig_destroy__ = _py_interop_metrics.delete_base_metric
+
+# Register base_metric in _py_interop_metrics:
+_py_interop_metrics.base_metric_swigregister(base_metric)
+
+def base_metric_create_id(lane, tile, arg3=0):
+    return _py_interop_metrics.base_metric_create_id(lane, tile, arg3)
+
+def base_metric_lane_from_id(id):
+    return _py_interop_metrics.base_metric_lane_from_id(id)
+
+def base_metric_tile_hash_from_id(id):
+    return _py_interop_metrics.base_metric_tile_hash_from_id(id)
+
+def base_metric_tile_from_id(id):
+    return _py_interop_metrics.base_metric_tile_from_id(id)
+
+def base_metric_suffix():
+    return _py_interop_metrics.base_metric_suffix()
+
+class base_cycle_metric_header(empty_header):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self):
+        _py_interop_metrics.base_cycle_metric_header_swiginit(self, _py_interop_metrics.new_base_cycle_metric_header())
+
+    @staticmethod
+    def default_header():
+        return _py_interop_metrics.base_cycle_metric_header_default_header()
+
+    def max_cycle(self):
+        return _py_interop_metrics.base_cycle_metric_header_max_cycle(self)
+
+    def clear(self):
+        return _py_interop_metrics.base_cycle_metric_header_clear(self)
+    __swig_destroy__ = _py_interop_metrics.delete_base_cycle_metric_header
+
+# Register base_cycle_metric_header in _py_interop_metrics:
+_py_interop_metrics.base_cycle_metric_header_swigregister(base_cycle_metric_header)
+
+def base_cycle_metric_header_default_header():
+    return _py_interop_metrics.base_cycle_metric_header_default_header()
+
+class base_cycle_metric(base_metric):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, lane=0, tile=0, cycle=0):
+        _py_interop_metrics.base_cycle_metric_swiginit(self, _py_interop_metrics.new_base_cycle_metric(lane, tile, cycle))
+
+    def set_base(self, *args):
+        return _py_interop_metrics.base_cycle_metric_set_base(self, *args)
+
+    def cycle(self):
+        return _py_interop_metrics.base_cycle_metric_cycle(self)
+
+    def id(self):
+        return _py_interop_metrics.base_cycle_metric_id(self)
+
+    def cycle_hash(self):
+        return _py_interop_metrics.base_cycle_metric_cycle_hash(self)
+
+    @staticmethod
+    def cycle_from_id(id):
+        return _py_interop_metrics.base_cycle_metric_cycle_from_id(id)
+
+    @staticmethod
+    def reserved_from_id(id):
+        return _py_interop_metrics.base_cycle_metric_reserved_from_id(id)
+
+    @staticmethod
+    def create_id(lane, tile, cycle):
+        return _py_interop_metrics.base_cycle_metric_create_id(lane, tile, cycle)
+
+    def __lt__(self, metric2):
+        return _py_interop_metrics.base_cycle_metric___lt__(self, metric2)
+    __swig_destroy__ = _py_interop_metrics.delete_base_cycle_metric
+
+# Register base_cycle_metric in _py_interop_metrics:
+_py_interop_metrics.base_cycle_metric_swigregister(base_cycle_metric)
+
+def base_cycle_metric_cycle_from_id(id):
+    return _py_interop_metrics.base_cycle_metric_cycle_from_id(id)
+
+def base_cycle_metric_reserved_from_id(id):
+    return _py_interop_metrics.base_cycle_metric_reserved_from_id(id)
+
+def base_cycle_metric_create_id(lane, tile, cycle):
+    return _py_interop_metrics.base_cycle_metric_create_id(lane, tile, cycle)
+
+class base_read_metric_header(empty_header):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self):
+        _py_interop_metrics.base_read_metric_header_swiginit(self, _py_interop_metrics.new_base_read_metric_header())
+
+    @staticmethod
+    def default_header():
+        return _py_interop_metrics.base_read_metric_header_default_header()
+    __swig_destroy__ = _py_interop_metrics.delete_base_read_metric_header
+
+# Register base_read_metric_header in _py_interop_metrics:
+_py_interop_metrics.base_read_metric_header_swigregister(base_read_metric_header)
+
+def base_read_metric_header_default_header():
+    return _py_interop_metrics.base_read_metric_header_default_header()
+
+class base_read_metric(base_metric):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, lane, tile, read):
+        _py_interop_metrics.base_read_metric_swiginit(self, _py_interop_metrics.new_base_read_metric(lane, tile, read))
+
+    def set_base(self, *args):
+        return _py_interop_metrics.base_read_metric_set_base(self, *args)
+
+    def read(self):
+        return _py_interop_metrics.base_read_metric_read(self)
+
+    def id(self):
+        return _py_interop_metrics.base_read_metric_id(self)
+
+    @staticmethod
+    def create_id(lane, tile, read):
+        return _py_interop_metrics.base_read_metric_create_id(lane, tile, read)
+
+    @staticmethod
+    def read_from_id(id):
+        return _py_interop_metrics.base_read_metric_read_from_id(id)
+
+    def __lt__(self, metric2):
+        return _py_interop_metrics.base_read_metric___lt__(self, metric2)
+    __swig_destroy__ = _py_interop_metrics.delete_base_read_metric
+
+# Register base_read_metric in _py_interop_metrics:
+_py_interop_metrics.base_read_metric_swigregister(base_read_metric)
+
+def base_read_metric_create_id(lane, tile, read):
+    return _py_interop_metrics.base_read_metric_create_id(lane, tile, read)
+
+def base_read_metric_read_from_id(id):
+    return _py_interop_metrics.base_read_metric_read_from_id(id)
+
+class point2d(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _py_interop_metrics.point2d_swiginit(self, _py_interop_metrics.new_point2d(*args))
+
+    def x(self):
+        return _py_interop_metrics.point2d_x(self)
+
+    def y(self):
+        return _py_interop_metrics.point2d_y(self)
+
+    def size_in_bytes(self):
+        return _py_interop_metrics.point2d_size_in_bytes(self)
+    __swig_destroy__ = _py_interop_metrics.delete_point2d
+
+# Register point2d in _py_interop_metrics:
+_py_interop_metrics.point2d_swigregister(point2d)
+
+class index_info_vector(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _py_interop_metrics.index_info_vector___nonzero__(self)
+
+    def __bool__(self):
+        return _py_interop_metrics.index_info_vector___bool__(self)
+
+    def __len__(self):
+        return _py_interop_metrics.index_info_vector___len__(self)
+
+    def __getslice__(self, i, j):
+        return _py_interop_metrics.index_info_vector___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _py_interop_metrics.index_info_vector___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _py_interop_metrics.index_info_vector___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _py_interop_metrics.index_info_vector___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _py_interop_metrics.index_info_vector___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _py_interop_metrics.index_info_vector___setitem__(self, *args)
+
+    def pop(self):
+        return _py_interop_metrics.index_info_vector_pop(self)
+
+    def append(self, x):
+        return _py_interop_metrics.index_info_vector_append(self, x)
+
+    def empty(self):
+        return _py_interop_metrics.index_info_vector_empty(self)
+
+    def size(self):
+        return _py_interop_metrics.index_info_vector_size(self)
+
+    def swap(self, v):
+        return _py_interop_metrics.index_info_vector_swap(self, v)
+
+    def rbegin(self):
+        return _py_interop_metrics.index_info_vector_rbegin(self)
+
+    def rend(self):
+        return _py_interop_metrics.index_info_vector_rend(self)
+
+    def clear(self):
+        return _py_interop_metrics.index_info_vector_clear(self)
+
+    def get_allocator(self):
+        return _py_interop_metrics.index_info_vector_get_allocator(self)
+
+    def pop_back(self):
+        return _py_interop_metrics.index_info_vector_pop_back(self)
+
+    def erase(self, *args):
+        return _py_interop_metrics.index_info_vector_erase(self, *args)
+
+    def __init__(self, *args):
+        _py_interop_metrics.index_info_vector_swiginit(self, _py_interop_metrics.new_index_info_vector(*args))
+
+    def push_back(self, x):
+        return _py_interop_metrics.index_info_vector_push_back(self, x)
+
+    def front(self):
+        return _py_interop_metrics.index_info_vector_front(self)
+
+    def back(self):
+        return _py_interop_metrics.index_info_vector_back(self)
+
+    def assign(self, n, x):
+        return _py_interop_metrics.index_info_vector_assign(self, n, x)
+
+    def resize(self, *args):
+        return _py_interop_metrics.index_info_vector_resize(self, *args)
+
+    def insert(self, *args):
+        return _py_interop_metrics.index_info_vector_insert(self, *args)
+
+    def reserve(self, n):
+        return _py_interop_metrics.index_info_vector_reserve(self, n)
+
+    def capacity(self):
+        return _py_interop_metrics.index_info_vector_capacity(self)
+    __swig_destroy__ = _py_interop_metrics.delete_index_info_vector
+
+# Register index_info_vector in _py_interop_metrics:
+_py_interop_metrics.index_info_vector_swigregister(index_info_vector)
+
+class tile_metric_map(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _py_interop_metrics.tile_metric_map___nonzero__(self)
+
+    def __bool__(self):
+        return _py_interop_metrics.tile_metric_map___bool__(self)
+
+    def __len__(self):
+        return _py_interop_metrics.tile_metric_map___len__(self)
+    def __iter__(self):
+        return self.key_iterator()
+    def iterkeys(self):
+        return self.key_iterator()
+    def itervalues(self):
+        return self.value_iterator()
+    def iteritems(self):
+        return self.iterator()
+
+    def __getitem__(self, key):
+        return _py_interop_metrics.tile_metric_map___getitem__(self, key)
+
+    def __delitem__(self, key):
+        return _py_interop_metrics.tile_metric_map___delitem__(self, key)
+
+    def has_key(self, key):
+        return _py_interop_metrics.tile_metric_map_has_key(self, key)
+
+    def keys(self):
+        return _py_interop_metrics.tile_metric_map_keys(self)
+
+    def values(self):
+        return _py_interop_metrics.tile_metric_map_values(self)
+
+    def items(self):
+        return _py_interop_metrics.tile_metric_map_items(self)
+
+    def __contains__(self, key):
+        return _py_interop_metrics.tile_metric_map___contains__(self, key)
+
+    def key_iterator(self):
+        return _py_interop_metrics.tile_metric_map_key_iterator(self)
+
+    def value_iterator(self):
+        return _py_interop_metrics.tile_metric_map_value_iterator(self)
+
+    def __setitem__(self, *args):
+        return _py_interop_metrics.tile_metric_map___setitem__(self, *args)
+
+    def asdict(self):
+        return _py_interop_metrics.tile_metric_map_asdict(self)
+
+    def __init__(self, *args):
+        _py_interop_metrics.tile_metric_map_swiginit(self, _py_interop_metrics.new_tile_metric_map(*args))
+
+    def empty(self):
+        return _py_interop_metrics.tile_metric_map_empty(self)
+
+    def size(self):
+        return _py_interop_metrics.tile_metric_map_size(self)
+
+    def swap(self, v):
+        return _py_interop_metrics.tile_metric_map_swap(self, v)
+
+    def rbegin(self):
+        return _py_interop_metrics.tile_metric_map_rbegin(self)
+
+    def rend(self):
+        return _py_interop_metrics.tile_metric_map_rend(self)
+
+    def clear(self):
+        return _py_interop_metrics.tile_metric_map_clear(self)
+
+    def get_allocator(self):
+        return _py_interop_metrics.tile_metric_map_get_allocator(self)
+
+    def count(self, x):
+        return _py_interop_metrics.tile_metric_map_count(self, x)
+
+    def erase(self, *args):
+        return _py_interop_metrics.tile_metric_map_erase(self, *args)
+
+    def find(self, x):
+        return _py_interop_metrics.tile_metric_map_find(self, x)
+
+    def lower_bound(self, x):
+        return _py_interop_metrics.tile_metric_map_lower_bound(self, x)
+
+    def upper_bound(self, x):
+        return _py_interop_metrics.tile_metric_map_upper_bound(self, x)
+    __swig_destroy__ = _py_interop_metrics.delete_tile_metric_map
+
+# Register tile_metric_map in _py_interop_metrics:
+_py_interop_metrics.tile_metric_map_swigregister(tile_metric_map)
+
+class cycle_metric_map(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _py_interop_metrics.cycle_metric_map___nonzero__(self)
+
+    def __bool__(self):
+        return _py_interop_metrics.cycle_metric_map___bool__(self)
+
+    def __len__(self):
+        return _py_interop_metrics.cycle_metric_map___len__(self)
+    def __iter__(self):
+        return self.key_iterator()
+    def iterkeys(self):
+        return self.key_iterator()
+    def itervalues(self):
+        return self.value_iterator()
+    def iteritems(self):
+        return self.iterator()
+
+    def __getitem__(self, key):
+        return _py_interop_metrics.cycle_metric_map___getitem__(self, key)
+
+    def __delitem__(self, key):
+        return _py_interop_metrics.cycle_metric_map___delitem__(self, key)
+
+    def has_key(self, key):
+        return _py_interop_metrics.cycle_metric_map_has_key(self, key)
+
+    def keys(self):
+        return _py_interop_metrics.cycle_metric_map_keys(self)
+
+    def values(self):
+        return _py_interop_metrics.cycle_metric_map_values(self)
+
+    def items(self):
+        return _py_interop_metrics.cycle_metric_map_items(self)
+
+    def __contains__(self, key):
+        return _py_interop_metrics.cycle_metric_map___contains__(self, key)
+
+    def key_iterator(self):
+        return _py_interop_metrics.cycle_metric_map_key_iterator(self)
+
+    def value_iterator(self):
+        return _py_interop_metrics.cycle_metric_map_value_iterator(self)
+
+    def __setitem__(self, *args):
+        return _py_interop_metrics.cycle_metric_map___setitem__(self, *args)
+
+    def asdict(self):
+        return _py_interop_metrics.cycle_metric_map_asdict(self)
+
+    def __init__(self, *args):
+        _py_interop_metrics.cycle_metric_map_swiginit(self, _py_interop_metrics.new_cycle_metric_map(*args))
+
+    def empty(self):
+        return _py_interop_metrics.cycle_metric_map_empty(self)
+
+    def size(self):
+        return _py_interop_metrics.cycle_metric_map_size(self)
+
+    def swap(self, v):
+        return _py_interop_metrics.cycle_metric_map_swap(self, v)
+
+    def rbegin(self):
+        return _py_interop_metrics.cycle_metric_map_rbegin(self)
+
+    def rend(self):
+        return _py_interop_metrics.cycle_metric_map_rend(self)
+
+    def clear(self):
+        return _py_interop_metrics.cycle_metric_map_clear(self)
+
+    def get_allocator(self):
+        return _py_interop_metrics.cycle_metric_map_get_allocator(self)
+
+    def count(self, x):
+        return _py_interop_metrics.cycle_metric_map_count(self, x)
+
+    def erase(self, *args):
+        return _py_interop_metrics.cycle_metric_map_erase(self, *args)
+
+    def find(self, x):
+        return _py_interop_metrics.cycle_metric_map_find(self, x)
+
+    def lower_bound(self, x):
+        return _py_interop_metrics.cycle_metric_map_lower_bound(self, x)
+
+    def upper_bound(self, x):
+        return _py_interop_metrics.cycle_metric_map_upper_bound(self, x)
+    __swig_destroy__ = _py_interop_metrics.delete_cycle_metric_map
+
+# Register cycle_metric_map in _py_interop_metrics:
+_py_interop_metrics.cycle_metric_map_swigregister(cycle_metric_map)
+
+class read_metric_vector(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _py_interop_metrics.read_metric_vector___nonzero__(self)
+
+    def __bool__(self):
+        return _py_interop_metrics.read_metric_vector___bool__(self)
+
+    def __len__(self):
+        return _py_interop_metrics.read_metric_vector___len__(self)
+
+    def __getslice__(self, i, j):
+        return _py_interop_metrics.read_metric_vector___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _py_interop_metrics.read_metric_vector___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _py_interop_metrics.read_metric_vector___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _py_interop_metrics.read_metric_vector___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _py_interop_metrics.read_metric_vector___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _py_interop_metrics.read_metric_vector___setitem__(self, *args)
+
+    def pop(self):
+        return _py_interop_metrics.read_metric_vector_pop(self)
+
+    def append(self, x):
+        return _py_interop_metrics.read_metric_vector_append(self, x)
+
+    def empty(self):
+        return _py_interop_metrics.read_metric_vector_empty(self)
+
+    def size(self):
+        return _py_interop_metrics.read_metric_vector_size(self)
+
+    def swap(self, v):
+        return _py_interop_metrics.read_metric_vector_swap(self, v)
+
+    def rbegin(self):
+        return _py_interop_metrics.read_metric_vector_rbegin(self)
+
+    def rend(self):
+        return _py_interop_metrics.read_metric_vector_rend(self)
+
+    def clear(self):
+        return _py_interop_metrics.read_metric_vector_clear(self)
+
+    def get_allocator(self):
+        return _py_interop_metrics.read_metric_vector_get_allocator(self)
+
+    def pop_back(self):
+        return _py_interop_metrics.read_metric_vector_pop_back(self)
+
+    def erase(self, *args):
+        return _py_interop_metrics.read_metric_vector_erase(self, *args)
+
+    def __init__(self, *args):
+        _py_interop_metrics.read_metric_vector_swiginit(self, _py_interop_metrics.new_read_metric_vector(*args))
+
+    def push_back(self, x):
+        return _py_interop_metrics.read_metric_vector_push_back(self, x)
+
+    def front(self):
+        return _py_interop_metrics.read_metric_vector_front(self)
+
+    def back(self):
+        return _py_interop_metrics.read_metric_vector_back(self)
+
+    def assign(self, n, x):
+        return _py_interop_metrics.read_metric_vector_assign(self, n, x)
+
+    def resize(self, *args):
+        return _py_interop_metrics.read_metric_vector_resize(self, *args)
+
+    def insert(self, *args):
+        return _py_interop_metrics.read_metric_vector_insert(self, *args)
+
+    def reserve(self, n):
+        return _py_interop_metrics.read_metric_vector_reserve(self, n)
+
+    def capacity(self):
+        return _py_interop_metrics.read_metric_vector_capacity(self)
+    __swig_destroy__ = _py_interop_metrics.delete_read_metric_vector
+
+# Register read_metric_vector in _py_interop_metrics:
+_py_interop_metrics.read_metric_vector_swigregister(read_metric_vector)
+
+class q_score_bin_vector(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _py_interop_metrics.q_score_bin_vector___nonzero__(self)
+
+    def __bool__(self):
+        return _py_interop_metrics.q_score_bin_vector___bool__(self)
+
+    def __len__(self):
+        return _py_interop_metrics.q_score_bin_vector___len__(self)
+
+    def __getslice__(self, i, j):
+        return _py_interop_metrics.q_score_bin_vector___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _py_interop_metrics.q_score_bin_vector___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _py_interop_metrics.q_score_bin_vector___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _py_interop_metrics.q_score_bin_vector___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _py_interop_metrics.q_score_bin_vector___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _py_interop_metrics.q_score_bin_vector___setitem__(self, *args)
+
+    def pop(self):
+        return _py_interop_metrics.q_score_bin_vector_pop(self)
+
+    def append(self, x):
+        return _py_interop_metrics.q_score_bin_vector_append(self, x)
+
+    def empty(self):
+        return _py_interop_metrics.q_score_bin_vector_empty(self)
+
+    def size(self):
+        return _py_interop_metrics.q_score_bin_vector_size(self)
+
+    def swap(self, v):
+        return _py_interop_metrics.q_score_bin_vector_swap(self, v)
+
+    def rbegin(self):
+        return _py_interop_metrics.q_score_bin_vector_rbegin(self)
+
+    def rend(self):
+        return _py_interop_metrics.q_score_bin_vector_rend(self)
+
+    def clear(self):
+        return _py_interop_metrics.q_score_bin_vector_clear(self)
+
+    def get_allocator(self):
+        return _py_interop_metrics.q_score_bin_vector_get_allocator(self)
+
+    def pop_back(self):
+        return _py_interop_metrics.q_score_bin_vector_pop_back(self)
+
+    def erase(self, *args):
+        return _py_interop_metrics.q_score_bin_vector_erase(self, *args)
+
+    def __init__(self, *args):
+        _py_interop_metrics.q_score_bin_vector_swiginit(self, _py_interop_metrics.new_q_score_bin_vector(*args))
+
+    def push_back(self, x):
+        return _py_interop_metrics.q_score_bin_vector_push_back(self, x)
+
+    def front(self):
+        return _py_interop_metrics.q_score_bin_vector_front(self)
+
+    def back(self):
+        return _py_interop_metrics.q_score_bin_vector_back(self)
+
+    def assign(self, n, x):
+        return _py_interop_metrics.q_score_bin_vector_assign(self, n, x)
+
+    def resize(self, *args):
+        return _py_interop_metrics.q_score_bin_vector_resize(self, *args)
+
+    def insert(self, *args):
+        return _py_interop_metrics.q_score_bin_vector_insert(self, *args)
+
+    def reserve(self, n):
+        return _py_interop_metrics.q_score_bin_vector_reserve(self, n)
+
+    def capacity(self):
+        return _py_interop_metrics.q_score_bin_vector_capacity(self)
+    __swig_destroy__ = _py_interop_metrics.delete_q_score_bin_vector
+
+# Register q_score_bin_vector in _py_interop_metrics:
+_py_interop_metrics.q_score_bin_vector_swigregister(q_score_bin_vector)
+
+class metric_type_name_pair(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _py_interop_metrics.metric_type_name_pair_swiginit(self, _py_interop_metrics.new_metric_type_name_pair(*args))
+    first = property(_py_interop_metrics.metric_type_name_pair_first_get, _py_interop_metrics.metric_type_name_pair_first_set)
+    second = property(_py_interop_metrics.metric_type_name_pair_second_get, _py_interop_metrics.metric_type_name_pair_second_set)
+    def __len__(self):
+        return 2
+    def __repr__(self):
+        return str((self.first, self.second))
+    def __getitem__(self, index): 
+        if not (index % 2):
+            return self.first
+        else:
+            return self.second
+    def __setitem__(self, index, val):
+        if not (index % 2):
+            self.first = val
+        else:
+            self.second = val
+    __swig_destroy__ = _py_interop_metrics.delete_metric_type_name_pair
+
+# Register metric_type_name_pair in _py_interop_metrics:
+_py_interop_metrics.metric_type_name_pair_swigregister(metric_type_name_pair)
+
+class metric_type_description(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _py_interop_metrics.metric_type_description_swiginit(self, _py_interop_metrics.new_metric_type_description(*args))
+
+    def value(self):
+        return _py_interop_metrics.metric_type_description_value(self)
+
+    def description(self):
+        return _py_interop_metrics.metric_type_description_description(self)
+    __swig_destroy__ = _py_interop_metrics.delete_metric_type_description
+
+# Register metric_type_description in _py_interop_metrics:
+_py_interop_metrics.metric_type_description_swigregister(metric_type_description)
+
+class metric_type_description_vector(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _py_interop_metrics.metric_type_description_vector___nonzero__(self)
+
+    def __bool__(self):
+        return _py_interop_metrics.metric_type_description_vector___bool__(self)
+
+    def __len__(self):
+        return _py_interop_metrics.metric_type_description_vector___len__(self)
+
+    def __getslice__(self, i, j):
+        return _py_interop_metrics.metric_type_description_vector___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _py_interop_metrics.metric_type_description_vector___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _py_interop_metrics.metric_type_description_vector___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _py_interop_metrics.metric_type_description_vector___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _py_interop_metrics.metric_type_description_vector___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _py_interop_metrics.metric_type_description_vector___setitem__(self, *args)
+
+    def pop(self):
+        return _py_interop_metrics.metric_type_description_vector_pop(self)
+
+    def append(self, x):
+        return _py_interop_metrics.metric_type_description_vector_append(self, x)
+
+    def empty(self):
+        return _py_interop_metrics.metric_type_description_vector_empty(self)
+
+    def size(self):
+        return _py_interop_metrics.metric_type_description_vector_size(self)
+
+    def swap(self, v):
+        return _py_interop_metrics.metric_type_description_vector_swap(self, v)
+
+    def rbegin(self):
+        return _py_interop_metrics.metric_type_description_vector_rbegin(self)
+
+    def rend(self):
+        return _py_interop_metrics.metric_type_description_vector_rend(self)
+
+    def clear(self):
+        return _py_interop_metrics.metric_type_description_vector_clear(self)
+
+    def get_allocator(self):
+        return _py_interop_metrics.metric_type_description_vector_get_allocator(self)
+
+    def pop_back(self):
+        return _py_interop_metrics.metric_type_description_vector_pop_back(self)
+
+    def erase(self, *args):
+        return _py_interop_metrics.metric_type_description_vector_erase(self, *args)
+
+    def __init__(self, *args):
+        _py_interop_metrics.metric_type_description_vector_swiginit(self, _py_interop_metrics.new_metric_type_description_vector(*args))
+
+    def push_back(self, x):
+        return _py_interop_metrics.metric_type_description_vector_push_back(self, x)
+
+    def front(self):
+        return _py_interop_metrics.metric_type_description_vector_front(self)
+
+    def back(self):
+        return _py_interop_metrics.metric_type_description_vector_back(self)
+
+    def assign(self, n, x):
+        return _py_interop_metrics.metric_type_description_vector_assign(self, n, x)
+
+    def resize(self, *args):
+        return _py_interop_metrics.metric_type_description_vector_resize(self, *args)
+
+    def insert(self, *args):
+        return _py_interop_metrics.metric_type_description_vector_insert(self, *args)
+
+    def reserve(self, n):
+        return _py_interop_metrics.metric_type_description_vector_reserve(self, n)
+
+    def capacity(self):
+        return _py_interop_metrics.metric_type_description_vector_capacity(self)
+    __swig_destroy__ = _py_interop_metrics.delete_metric_type_description_vector
+
+# Register metric_type_description_vector in _py_interop_metrics:
+_py_interop_metrics.metric_type_description_vector_swigregister(metric_type_description_vector)
+
+class metric_type_vector(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _py_interop_metrics.metric_type_vector___nonzero__(self)
+
+    def __bool__(self):
+        return _py_interop_metrics.metric_type_vector___bool__(self)
+
+    def __len__(self):
+        return _py_interop_metrics.metric_type_vector___len__(self)
+
+    def __getslice__(self, i, j):
+        return _py_interop_metrics.metric_type_vector___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _py_interop_metrics.metric_type_vector___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _py_interop_metrics.metric_type_vector___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _py_interop_metrics.metric_type_vector___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _py_interop_metrics.metric_type_vector___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _py_interop_metrics.metric_type_vector___setitem__(self, *args)
+
+    def pop(self):
+        return _py_interop_metrics.metric_type_vector_pop(self)
+
+    def append(self, x):
+        return _py_interop_metrics.metric_type_vector_append(self, x)
+
+    def empty(self):
+        return _py_interop_metrics.metric_type_vector_empty(self)
+
+    def size(self):
+        return _py_interop_metrics.metric_type_vector_size(self)
+
+    def swap(self, v):
+        return _py_interop_metrics.metric_type_vector_swap(self, v)
+
+    def rbegin(self):
+        return _py_interop_metrics.metric_type_vector_rbegin(self)
+
+    def rend(self):
+        return _py_interop_metrics.metric_type_vector_rend(self)
+
+    def clear(self):
+        return _py_interop_metrics.metric_type_vector_clear(self)
+
+    def get_allocator(self):
+        return _py_interop_metrics.metric_type_vector_get_allocator(self)
+
+    def pop_back(self):
+        return _py_interop_metrics.metric_type_vector_pop_back(self)
+
+    def erase(self, *args):
+        return _py_interop_metrics.metric_type_vector_erase(self, *args)
+
+    def __init__(self, *args):
+        _py_interop_metrics.metric_type_vector_swiginit(self, _py_interop_metrics.new_metric_type_vector(*args))
+
+    def push_back(self, x):
+        return _py_interop_metrics.metric_type_vector_push_back(self, x)
+
+    def front(self):
+        return _py_interop_metrics.metric_type_vector_front(self)
+
+    def back(self):
+        return _py_interop_metrics.metric_type_vector_back(self)
+
+    def assign(self, n, x):
+        return _py_interop_metrics.metric_type_vector_assign(self, n, x)
+
+    def resize(self, *args):
+        return _py_interop_metrics.metric_type_vector_resize(self, *args)
+
+    def insert(self, *args):
+        return _py_interop_metrics.metric_type_vector_insert(self, *args)
+
+    def reserve(self, n):
+        return _py_interop_metrics.metric_type_vector_reserve(self, n)
+
+    def capacity(self):
+        return _py_interop_metrics.metric_type_vector_capacity(self)
+    __swig_destroy__ = _py_interop_metrics.delete_metric_type_vector
+
+# Register metric_type_vector in _py_interop_metrics:
+_py_interop_metrics.metric_type_vector_swigregister(metric_type_vector)
+
+class metric_group_vector(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _py_interop_metrics.metric_group_vector___nonzero__(self)
+
+    def __bool__(self):
+        return _py_interop_metrics.metric_group_vector___bool__(self)
+
+    def __len__(self):
+        return _py_interop_metrics.metric_group_vector___len__(self)
+
+    def __getslice__(self, i, j):
+        return _py_interop_metrics.metric_group_vector___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _py_interop_metrics.metric_group_vector___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _py_interop_metrics.metric_group_vector___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _py_interop_metrics.metric_group_vector___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _py_interop_metrics.metric_group_vector___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _py_interop_metrics.metric_group_vector___setitem__(self, *args)
+
+    def pop(self):
+        return _py_interop_metrics.metric_group_vector_pop(self)
+
+    def append(self, x):
+        return _py_interop_metrics.metric_group_vector_append(self, x)
+
+    def empty(self):
+        return _py_interop_metrics.metric_group_vector_empty(self)
+
+    def size(self):
+        return _py_interop_metrics.metric_group_vector_size(self)
+
+    def swap(self, v):
+        return _py_interop_metrics.metric_group_vector_swap(self, v)
+
+    def rbegin(self):
+        return _py_interop_metrics.metric_group_vector_rbegin(self)
+
+    def rend(self):
+        return _py_interop_metrics.metric_group_vector_rend(self)
+
+    def clear(self):
+        return _py_interop_metrics.metric_group_vector_clear(self)
+
+    def get_allocator(self):
+        return _py_interop_metrics.metric_group_vector_get_allocator(self)
+
+    def pop_back(self):
+        return _py_interop_metrics.metric_group_vector_pop_back(self)
+
+    def erase(self, *args):
+        return _py_interop_metrics.metric_group_vector_erase(self, *args)
+
+    def __init__(self, *args):
+        _py_interop_metrics.metric_group_vector_swiginit(self, _py_interop_metrics.new_metric_group_vector(*args))
+
+    def push_back(self, x):
+        return _py_interop_metrics.metric_group_vector_push_back(self, x)
+
+    def front(self):
+        return _py_interop_metrics.metric_group_vector_front(self)
+
+    def back(self):
+        return _py_interop_metrics.metric_group_vector_back(self)
+
+    def assign(self, n, x):
+        return _py_interop_metrics.metric_group_vector_assign(self, n, x)
+
+    def resize(self, *args):
+        return _py_interop_metrics.metric_group_vector_resize(self, *args)
+
+    def insert(self, *args):
+        return _py_interop_metrics.metric_group_vector_insert(self, *args)
+
+    def reserve(self, n):
+        return _py_interop_metrics.metric_group_vector_reserve(self, n)
+
+    def capacity(self):
+        return _py_interop_metrics.metric_group_vector_capacity(self)
+    __swig_destroy__ = _py_interop_metrics.delete_metric_group_vector
+
+# Register metric_group_vector in _py_interop_metrics:
+_py_interop_metrics.metric_group_vector_swigregister(metric_group_vector)
+
+class corrected_intensity_metric(base_cycle_metric):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    TYPE = _py_interop_metrics.corrected_intensity_metric_TYPE
+    LATEST_VERSION = _py_interop_metrics.corrected_intensity_metric_LATEST_VERSION
+
+    def __init__(self, *args):
+        _py_interop_metrics.corrected_intensity_metric_swiginit(self, _py_interop_metrics.new_corrected_intensity_metric(*args))
+
+    def set(self, lane, tile, cycle, called_counts):
+        return _py_interop_metrics.corrected_intensity_metric_set(self, lane, tile, cycle, called_counts)
+
+    def average_cycle_intensity(self):
+        return _py_interop_metrics.corrected_intensity_metric_average_cycle_intensity(self)
+
+    def corrected_int_all(self, index):
+        return _py_interop_metrics.corrected_intensity_metric_corrected_int_all(self, index)
+
+    def corrected_int_all_float(self, index):
+        return _py_interop_metrics.corrected_intensity_metric_corrected_int_all_float(self, index)
+
+    def corrected_int_called(self, index):
+        return _py_interop_metrics.corrected_intensity_metric_corrected_int_called(self, index)
+
+    def called_counts_array(self):
+        return _py_interop_metrics.corrected_intensity_metric_called_counts_array(self)
+
+    def corrected_int_all_array(self):
+        return _py_interop_metrics.corrected_intensity_metric_corrected_int_all_array(self)
+
+    def called_counts(self, index):
+        return _py_interop_metrics.corrected_intensity_metric_called_counts(self, index)
+
+    def no_calls(self):
+        return _py_interop_metrics.corrected_intensity_metric_no_calls(self)
+
+    def signal_to_noise(self):
+        return _py_interop_metrics.corrected_intensity_metric_signal_to_noise(self)
+
+    def total_calls(self, nocalls=False):
+        return _py_interop_metrics.corrected_intensity_metric_total_calls(self, nocalls)
+
+    def total_intensity(self):
+        return _py_interop_metrics.corrected_intensity_metric_total_intensity(self)
+
+    def total_called_intensity(self):
+        return _py_interop_metrics.corrected_intensity_metric_total_called_intensity(self)
+
+    def percent_base(self, index):
+        return _py_interop_metrics.corrected_intensity_metric_percent_base(self, index)
+
+    def percent_bases(self):
+        return _py_interop_metrics.corrected_intensity_metric_percent_bases(self)
+
+    def percent_nocall(self):
+        return _py_interop_metrics.corrected_intensity_metric_percent_nocall(self)
+
+    def corrected_int_called_array(self, *args):
+        return _py_interop_metrics.corrected_intensity_metric_corrected_int_called_array(self, *args)
+
+    def any_valid_called_int(self):
+        return _py_interop_metrics.corrected_intensity_metric_any_valid_called_int(self)
+
+    def averageCycleIntensity(self):
+        return _py_interop_metrics.corrected_intensity_metric_averageCycleIntensity(self)
+
+    def correctedIntCalled(self, *args):
+        return _py_interop_metrics.corrected_intensity_metric_correctedIntCalled(self, *args)
+
+    def correctedIntAll(self, *args):
+        return _py_interop_metrics.corrected_intensity_metric_correctedIntAll(self, *args)
+
+    def noCalls(self):
+        return _py_interop_metrics.corrected_intensity_metric_noCalls(self)
+
+    def percentBase(self, index):
+        return _py_interop_metrics.corrected_intensity_metric_percentBase(self, index)
+
+    def calledCounts(self, *args):
+        return _py_interop_metrics.corrected_intensity_metric_calledCounts(self, *args)
+
+    def signalToNoise(self):
+        return _py_interop_metrics.corrected_intensity_metric_signalToNoise(self)
+
+    def totalCalls(self, nocalls=False):
+        return _py_interop_metrics.corrected_intensity_metric_totalCalls(self, nocalls)
+
+    def totalIntensity(self):
+        return _py_interop_metrics.corrected_intensity_metric_totalIntensity(self)
+
+    def totalCalledIntensity(self):
+        return _py_interop_metrics.corrected_intensity_metric_totalCalledIntensity(self)
+
+    def percentIntensity(self, index):
+        return _py_interop_metrics.corrected_intensity_metric_percentIntensity(self, index)
+
+    def percentCalledIntensity(self, index):
+        return _py_interop_metrics.corrected_intensity_metric_percentCalledIntensity(self, index)
+
+    @staticmethod
+    def prefix():
+        return _py_interop_metrics.corrected_intensity_metric_prefix()
+    __swig_destroy__ = _py_interop_metrics.delete_corrected_intensity_metric
+
+# Register corrected_intensity_metric in _py_interop_metrics:
+_py_interop_metrics.corrected_intensity_metric_swigregister(corrected_intensity_metric)
+
+def corrected_intensity_metric_prefix():
+    return _py_interop_metrics.corrected_intensity_metric_prefix()
+
+class error_metric_header(base_cycle_metric_header):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _py_interop_metrics.error_metric_header_swiginit(self, _py_interop_metrics.new_error_metric_header(*args))
+
+    def number_adapters(self):
+        return _py_interop_metrics.error_metric_header_number_adapters(self)
+
+    def adapter_length(self):
+        return _py_interop_metrics.error_metric_header_adapter_length(self)
+
+    def adapter_sequences(self):
+        return _py_interop_metrics.error_metric_header_adapter_sequences(self)
+
+    def clear(self):
+        return _py_interop_metrics.error_metric_header_clear(self)
+
+    @staticmethod
+    def default_header():
+        return _py_interop_metrics.error_metric_header_default_header()
+    __swig_destroy__ = _py_interop_metrics.delete_error_metric_header
+
+# Register error_metric_header in _py_interop_metrics:
+_py_interop_metrics.error_metric_header_swigregister(error_metric_header)
+
+def error_metric_header_default_header():
+    return _py_interop_metrics.error_metric_header_default_header()
+
+class error_metric(base_cycle_metric):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    MAX_MISMATCH = _py_interop_metrics.error_metric_MAX_MISMATCH
+    TYPE = _py_interop_metrics.error_metric_TYPE
+    LATEST_VERSION = _py_interop_metrics.error_metric_LATEST_VERSION
+
+    def __init__(self, *args):
+        _py_interop_metrics.error_metric_swiginit(self, _py_interop_metrics.new_error_metric(*args))
+
+    def error_rate(self):
+        return _py_interop_metrics.error_metric_error_rate(self)
+
+    def phix_adapter_rate(self):
+        return _py_interop_metrics.error_metric_phix_adapter_rate(self)
+
+    def phix_adapter_rates(self):
+        return _py_interop_metrics.error_metric_phix_adapter_rates(self)
+
+    def phix_adapter_rate_at(self, n):
+        return _py_interop_metrics.error_metric_phix_adapter_rate_at(self, n)
+
+    def phix_adapter_count(self):
+        return _py_interop_metrics.error_metric_phix_adapter_count(self)
+
+    def mismatch_cluster_count(self, n):
+        return _py_interop_metrics.error_metric_mismatch_cluster_count(self, n)
+
+    def mismatch_count(self):
+        return _py_interop_metrics.error_metric_mismatch_count(self)
+
+    def mismatch_cluster_counts(self):
+        return _py_interop_metrics.error_metric_mismatch_cluster_counts(self)
+
+    def errorRate(self):
+        return _py_interop_metrics.error_metric_errorRate(self)
+
+    @staticmethod
+    def prefix():
+        return _py_interop_metrics.error_metric_prefix()
+    __swig_destroy__ = _py_interop_metrics.delete_error_metric
+
+# Register error_metric in _py_interop_metrics:
+_py_interop_metrics.error_metric_swigregister(error_metric)
+
+def error_metric_prefix():
+    return _py_interop_metrics.error_metric_prefix()
+
+class extended_tile_metric(base_metric):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    TYPE = _py_interop_metrics.extended_tile_metric_TYPE
+    LATEST_VERSION = _py_interop_metrics.extended_tile_metric_LATEST_VERSION
+
+    def __init__(self, *args):
+        _py_interop_metrics.extended_tile_metric_swiginit(self, _py_interop_metrics.new_extended_tile_metric(*args))
+
+    def set(self, *args):
+        return _py_interop_metrics.extended_tile_metric_set(self, *args)
+
+    def cluster_count_occupied(self):
+        return _py_interop_metrics.extended_tile_metric_cluster_count_occupied(self)
+
+    def cluster_count_occupied_k(self):
+        return _py_interop_metrics.extended_tile_metric_cluster_count_occupied_k(self)
+
+    def percent_occupied(self):
+        return _py_interop_metrics.extended_tile_metric_percent_occupied(self)
+
+    def upper_left(self):
+        return _py_interop_metrics.extended_tile_metric_upper_left(self)
+
+    def set_cluster_count_k(self, cluster_count_k):
+        return _py_interop_metrics.extended_tile_metric_set_cluster_count_k(self, cluster_count_k)
+
+    @staticmethod
+    def prefix():
+        return _py_interop_metrics.extended_tile_metric_prefix()
+    __swig_destroy__ = _py_interop_metrics.delete_extended_tile_metric
+
+# Register extended_tile_metric in _py_interop_metrics:
+_py_interop_metrics.extended_tile_metric_swigregister(extended_tile_metric)
+
+def extended_tile_metric_prefix():
+    return _py_interop_metrics.extended_tile_metric_prefix()
+
+class extraction_metric_header(base_cycle_metric_header):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    MAX_CHANNELS = _py_interop_metrics.extraction_metric_header_MAX_CHANNELS
+
+    def __init__(self, channel_count):
+        _py_interop_metrics.extraction_metric_header_swiginit(self, _py_interop_metrics.new_extraction_metric_header(channel_count))
+
+    def channel_count(self, *args):
+        return _py_interop_metrics.extraction_metric_header_channel_count(self, *args)
+
+    @staticmethod
+    def default_header():
+        return _py_interop_metrics.extraction_metric_header_default_header()
+
+    def clear(self):
+        return _py_interop_metrics.extraction_metric_header_clear(self)
+    __swig_destroy__ = _py_interop_metrics.delete_extraction_metric_header
+
+# Register extraction_metric_header in _py_interop_metrics:
+_py_interop_metrics.extraction_metric_header_swigregister(extraction_metric_header)
+
+def extraction_metric_header_default_header():
+    return _py_interop_metrics.extraction_metric_header_default_header()
+
+class extraction_metric(base_cycle_metric):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    MAX_CHANNELS = _py_interop_metrics.extraction_metric_MAX_CHANNELS
+    TYPE = _py_interop_metrics.extraction_metric_TYPE
+    LATEST_VERSION = _py_interop_metrics.extraction_metric_LATEST_VERSION
+
+    def __init__(self, *args):
+        _py_interop_metrics.extraction_metric_swiginit(self, _py_interop_metrics.new_extraction_metric(*args))
+
+    def set(self, *args):
+        return _py_interop_metrics.extraction_metric_set(self, *args)
+
+    def date_time_csharp(self):
+        return _py_interop_metrics.extraction_metric_date_time_csharp(self)
+
+    def date_time_csharp_raw(self):
+        return _py_interop_metrics.extraction_metric_date_time_csharp_raw(self)
+
+    def max_intensity(self, channel):
+        return _py_interop_metrics.extraction_metric_max_intensity(self, channel)
+
+    def focus_score(self, channel):
+        return _py_interop_metrics.extraction_metric_focus_score(self, channel)
+
+    def max_intensity_values(self):
+        return _py_interop_metrics.extraction_metric_max_intensity_values(self)
+
+    def focus_scores(self):
+        return _py_interop_metrics.extraction_metric_focus_scores(self)
+
+    def channel_count(self):
+        return _py_interop_metrics.extraction_metric_channel_count(self)
+
+    def trim(self, channel_count):
+        return _py_interop_metrics.extraction_metric_trim(self, channel_count)
+
+    def focusScore(self, channel):
+        return _py_interop_metrics.extraction_metric_focusScore(self, channel)
+
+    def dateTime(self):
+        return _py_interop_metrics.extraction_metric_dateTime(self)
+
+    def focusScores(self):
+        return _py_interop_metrics.extraction_metric_focusScores(self)
+
+    def date_time(self, *args):
+        return _py_interop_metrics.extraction_metric_date_time(self, *args)
+
+    def is_any_p90_zero(self):
+        return _py_interop_metrics.extraction_metric_is_any_p90_zero(self)
+
+    @staticmethod
+    def prefix():
+        return _py_interop_metrics.extraction_metric_prefix()
+    __swig_destroy__ = _py_interop_metrics.delete_extraction_metric
+
+# Register extraction_metric in _py_interop_metrics:
+_py_interop_metrics.extraction_metric_swigregister(extraction_metric)
+
+def extraction_metric_prefix():
+    return _py_interop_metrics.extraction_metric_prefix()
+
+class image_metric_header(base_cycle_metric_header):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    MAX_CHANNELS = _py_interop_metrics.image_metric_header_MAX_CHANNELS
+
+    def __init__(self, channel_count):
+        _py_interop_metrics.image_metric_header_swiginit(self, _py_interop_metrics.new_image_metric_header(channel_count))
+
+    def channelCount(self):
+        return _py_interop_metrics.image_metric_header_channelCount(self)
+
+    def channel_count(self, *args):
+        return _py_interop_metrics.image_metric_header_channel_count(self, *args)
+
+    @staticmethod
+    def default_header():
+        return _py_interop_metrics.image_metric_header_default_header()
+
+    def clear(self):
+        return _py_interop_metrics.image_metric_header_clear(self)
+    __swig_destroy__ = _py_interop_metrics.delete_image_metric_header
+
+# Register image_metric_header in _py_interop_metrics:
+_py_interop_metrics.image_metric_header_swigregister(image_metric_header)
+
+def image_metric_header_default_header():
+    return _py_interop_metrics.image_metric_header_default_header()
+
+class image_metric(base_cycle_metric):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    MAX_CHANNELS = _py_interop_metrics.image_metric_MAX_CHANNELS
+    TYPE = _py_interop_metrics.image_metric_TYPE
+    LATEST_VERSION = _py_interop_metrics.image_metric_LATEST_VERSION
+
+    def __init__(self, *args):
+        _py_interop_metrics.image_metric_swiginit(self, _py_interop_metrics.new_image_metric(*args))
+
+    def min_contrast(self, channel):
+        return _py_interop_metrics.image_metric_min_contrast(self, channel)
+
+    def max_contrast(self, channel):
+        return _py_interop_metrics.image_metric_max_contrast(self, channel)
+
+    def min_contrast_array(self):
+        return _py_interop_metrics.image_metric_min_contrast_array(self)
+
+    def max_contrast_array(self):
+        return _py_interop_metrics.image_metric_max_contrast_array(self)
+
+    def channel_count(self):
+        return _py_interop_metrics.image_metric_channel_count(self)
+
+    def is_any_channel_blank(self):
+        return _py_interop_metrics.image_metric_is_any_channel_blank(self)
+
+    def trim(self, channel_count):
+        return _py_interop_metrics.image_metric_trim(self, channel_count)
+
+    def minContrast(self, *args):
+        return _py_interop_metrics.image_metric_minContrast(self, *args)
+
+    def maxContrast(self, *args):
+        return _py_interop_metrics.image_metric_maxContrast(self, *args)
+
+    def channelCount(self):
+        return _py_interop_metrics.image_metric_channelCount(self)
+
+    @staticmethod
+    def prefix():
+        return _py_interop_metrics.image_metric_prefix()
+    __swig_destroy__ = _py_interop_metrics.delete_image_metric
+
+# Register image_metric in _py_interop_metrics:
+_py_interop_metrics.image_metric_swigregister(image_metric)
+
+def image_metric_prefix():
+    return _py_interop_metrics.image_metric_prefix()
+
+class q_score_bin(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, lower=0, upper=0, value=0):
+        _py_interop_metrics.q_score_bin_swiginit(self, _py_interop_metrics.new_q_score_bin(lower, upper, value))
+
+    def lower(self):
+        return _py_interop_metrics.q_score_bin_lower(self)
+
+    def upper(self):
+        return _py_interop_metrics.q_score_bin_upper(self)
+
+    def value(self):
+        return _py_interop_metrics.q_score_bin_value(self)
+    __swig_destroy__ = _py_interop_metrics.delete_q_score_bin
+
+# Register q_score_bin in _py_interop_metrics:
+_py_interop_metrics.q_score_bin_swigregister(q_score_bin)
+
+class q_score_header(base_cycle_metric_header):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    MAX_Q_BINS = _py_interop_metrics.q_score_header_MAX_Q_BINS
+
+    def __init__(self, *args):
+        _py_interop_metrics.q_score_header_swiginit(self, _py_interop_metrics.new_q_score_header(*args))
+
+    def bin_at(self, n):
+        return _py_interop_metrics.q_score_header_bin_at(self, n)
+
+    def get_bins(self):
+        return _py_interop_metrics.q_score_header_get_bins(self)
+
+    def bins(self):
+        return _py_interop_metrics.q_score_header_bins(self)
+
+    def bin_count(self):
+        return _py_interop_metrics.q_score_header_bin_count(self)
+
+    def q_val_count(self):
+        return _py_interop_metrics.q_score_header_q_val_count(self)
+
+    def index_for_q_value(self, qval):
+        return _py_interop_metrics.q_score_header_index_for_q_value(self, qval)
+
+    def binCount(self):
+        return _py_interop_metrics.q_score_header_binCount(self)
+
+    @staticmethod
+    def default_header():
+        return _py_interop_metrics.q_score_header_default_header()
+
+    def binAt(self, n):
+        return _py_interop_metrics.q_score_header_binAt(self, n)
+
+    def clear(self):
+        return _py_interop_metrics.q_score_header_clear(self)
+    __swig_destroy__ = _py_interop_metrics.delete_q_score_header
+
+# Register q_score_header in _py_interop_metrics:
+_py_interop_metrics.q_score_header_swigregister(q_score_header)
+
+def q_score_header_default_header():
+    return _py_interop_metrics.q_score_header_default_header()
+
+class q_metric(base_cycle_metric):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    TYPE = _py_interop_metrics.q_metric_TYPE
+    LATEST_VERSION = _py_interop_metrics.q_metric_LATEST_VERSION
+    MAX_Q_BINS = _py_interop_metrics.q_metric_MAX_Q_BINS
+
+    def __init__(self, *args):
+        _py_interop_metrics.q_metric_swiginit(self, _py_interop_metrics.new_q_metric(*args))
+
+    def set(self, lane, tile, cycle, qscore_hist):
+        return _py_interop_metrics.q_metric_set(self, lane, tile, cycle, qscore_hist)
+
+    def qscore_hist(self, *args):
+        return _py_interop_metrics.q_metric_qscore_hist(self, *args)
+
+    def size(self):
+        return _py_interop_metrics.q_metric_size(self)
+
+    def sum_qscore(self):
+        return _py_interop_metrics.q_metric_sum_qscore(self)
+
+    def sum_qscore_cumulative(self):
+        return _py_interop_metrics.q_metric_sum_qscore_cumulative(self)
+
+    def total_over_qscore(self, *args):
+        return _py_interop_metrics.q_metric_total_over_qscore(self, *args)
+
+    def total_over_qscore_cumulative(self, *args):
+        return _py_interop_metrics.q_metric_total_over_qscore_cumulative(self, *args)
+
+    def percent_over_qscore(self, *args):
+        return _py_interop_metrics.q_metric_percent_over_qscore(self, *args)
+
+    def percent_over_qscore_cumulative(self, *args):
+        return _py_interop_metrics.q_metric_percent_over_qscore_cumulative(self, *args)
+
+    def median(self, *args):
+        return _py_interop_metrics.q_metric_median(self, *args)
+
+    def is_cumulative_empty(self):
+        return _py_interop_metrics.q_metric_is_cumulative_empty(self)
+
+    def accumulate(self, metric):
+        return _py_interop_metrics.q_metric_accumulate(self, metric)
+
+    def compress(self, header):
+        return _py_interop_metrics.q_metric_compress(self, header)
+
+    def qscoreHist(self, *args):
+        return _py_interop_metrics.q_metric_qscoreHist(self, *args)
+
+    @staticmethod
+    def prefix():
+        return _py_interop_metrics.q_metric_prefix()
+    __swig_destroy__ = _py_interop_metrics.delete_q_metric
+
+# Register q_metric in _py_interop_metrics:
+_py_interop_metrics.q_metric_swigregister(q_metric)
+
+def q_metric_prefix():
+    return _py_interop_metrics.q_metric_prefix()
+
+class tile_metric_header(base_metric_header):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, density):
+        _py_interop_metrics.tile_metric_header_swiginit(self, _py_interop_metrics.new_tile_metric_header(density))
+
+    def density(self):
+        return _py_interop_metrics.tile_metric_header_density(self)
+
+    @staticmethod
+    def default_header():
+        return _py_interop_metrics.tile_metric_header_default_header()
+
+    def clear(self):
+        return _py_interop_metrics.tile_metric_header_clear(self)
+    __swig_destroy__ = _py_interop_metrics.delete_tile_metric_header
+
+# Register tile_metric_header in _py_interop_metrics:
+_py_interop_metrics.tile_metric_header_swigregister(tile_metric_header)
+
+def tile_metric_header_default_header():
+    return _py_interop_metrics.tile_metric_header_default_header()
+
+class read_metric(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _py_interop_metrics.read_metric_swiginit(self, _py_interop_metrics.new_read_metric(*args))
+
+    def read(self):
+        return _py_interop_metrics.read_metric_read(self)
+
+    def percent_aligned(self, *args):
+        return _py_interop_metrics.read_metric_percent_aligned(self, *args)
+
+    def percent_phasing(self, *args):
+        return _py_interop_metrics.read_metric_percent_phasing(self, *args)
+
+    def percent_prephasing(self, *args):
+        return _py_interop_metrics.read_metric_percent_prephasing(self, *args)
+    __swig_destroy__ = _py_interop_metrics.delete_read_metric
+
+# Register read_metric in _py_interop_metrics:
+_py_interop_metrics.read_metric_swigregister(read_metric)
+
+class tile_metric(base_metric):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    TYPE = _py_interop_metrics.tile_metric_TYPE
+    LATEST_VERSION = _py_interop_metrics.tile_metric_LATEST_VERSION
+
+    def __init__(self, *args):
+        _py_interop_metrics.tile_metric_swiginit(self, _py_interop_metrics.new_tile_metric(*args))
+
+    def cluster_density(self):
+        return _py_interop_metrics.tile_metric_cluster_density(self)
+
+    def cluster_density_k(self):
+        return _py_interop_metrics.tile_metric_cluster_density_k(self)
+
+    def cluster_density_pf(self):
+        return _py_interop_metrics.tile_metric_cluster_density_pf(self)
+
+    def cluster_density_pf_k(self):
+        return _py_interop_metrics.tile_metric_cluster_density_pf_k(self)
+
+    def cluster_count(self):
+        return _py_interop_metrics.tile_metric_cluster_count(self)
+
+    def cluster_count_k(self):
+        return _py_interop_metrics.tile_metric_cluster_count_k(self)
+
+    def cluster_count_m(self):
+        return _py_interop_metrics.tile_metric_cluster_count_m(self)
+
+    def cluster_count_pf(self):
+        return _py_interop_metrics.tile_metric_cluster_count_pf(self)
+
+    def cluster_count_pf_k(self):
+        return _py_interop_metrics.tile_metric_cluster_count_pf_k(self)
+
+    def cluster_count_pf_m(self):
+        return _py_interop_metrics.tile_metric_cluster_count_pf_m(self)
+
+    def percent_pf(self):
+        return _py_interop_metrics.tile_metric_percent_pf(self)
+
+    def read_metrics(self):
+        return _py_interop_metrics.tile_metric_read_metrics(self)
+
+    def percent_aligned(self, n):
+        return _py_interop_metrics.tile_metric_percent_aligned(self, n)
+
+    def percent_phasing(self, n):
+        return _py_interop_metrics.tile_metric_percent_phasing(self, n)
+
+    def percent_prephasing(self, n):
+        return _py_interop_metrics.tile_metric_percent_prephasing(self, n)
+
+    def percent_aligned_at(self, number):
+        return _py_interop_metrics.tile_metric_percent_aligned_at(self, number)
+
+    def percent_phasing_at(self, number):
+        return _py_interop_metrics.tile_metric_percent_phasing_at(self, number)
+
+    def percent_prephasing_at(self, number):
+        return _py_interop_metrics.tile_metric_percent_prephasing_at(self, number)
+
+    def read_count(self):
+        return _py_interop_metrics.tile_metric_read_count(self)
+
+    def is_dead_tile(self):
+        return _py_interop_metrics.tile_metric_is_dead_tile(self)
+
+    def update_phasing_if_missing(self, number, phasing, prephasing):
+        return _py_interop_metrics.tile_metric_update_phasing_if_missing(self, number, phasing, prephasing)
+
+    def clusterDensity(self):
+        return _py_interop_metrics.tile_metric_clusterDensity(self)
+
+    def clusterDensityPf(self):
+        return _py_interop_metrics.tile_metric_clusterDensityPf(self)
+
+    def clusterCount(self):
+        return _py_interop_metrics.tile_metric_clusterCount(self)
+
+    def clusterCountPf(self):
+        return _py_interop_metrics.tile_metric_clusterCountPf(self)
+
+    @staticmethod
+    def prefix():
+        return _py_interop_metrics.tile_metric_prefix()
+    __swig_destroy__ = _py_interop_metrics.delete_tile_metric
+
+# Register tile_metric in _py_interop_metrics:
+_py_interop_metrics.tile_metric_swigregister(tile_metric)
+
+def tile_metric_prefix():
+    return _py_interop_metrics.tile_metric_prefix()
+
+class index_info(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _py_interop_metrics.index_info_swiginit(self, _py_interop_metrics.new_index_info(*args))
+
+    def index_seq(self):
+        return _py_interop_metrics.index_info_index_seq(self)
+
+    def sample_id(self):
+        return _py_interop_metrics.index_info_sample_id(self)
+
+    def sample_proj(self):
+        return _py_interop_metrics.index_info_sample_proj(self)
+
+    def cluster_count(self):
+        return _py_interop_metrics.index_info_cluster_count(self)
+
+    def is_dual(self):
+        return _py_interop_metrics.index_info_is_dual(self)
+
+    def index1(self):
+        return _py_interop_metrics.index_info_index1(self)
+
+    def index2(self):
+        return _py_interop_metrics.index_info_index2(self)
+
+    def unique_id(self):
+        return _py_interop_metrics.index_info_unique_id(self)
+    __swig_destroy__ = _py_interop_metrics.delete_index_info
+
+# Register index_info in _py_interop_metrics:
+_py_interop_metrics.index_info_swigregister(index_info)
+
+class index_metric_header(base_read_metric_header):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self):
+        _py_interop_metrics.index_metric_header_swiginit(self, _py_interop_metrics.new_index_metric_header())
+
+    def index_order(self, *args):
+        return _py_interop_metrics.index_metric_header_index_order(self, *args)
+
+    @staticmethod
+    def default_header():
+        return _py_interop_metrics.index_metric_header_default_header()
+
+    def clear(self):
+        return _py_interop_metrics.index_metric_header_clear(self)
+    __swig_destroy__ = _py_interop_metrics.delete_index_metric_header
+
+# Register index_metric_header in _py_interop_metrics:
+_py_interop_metrics.index_metric_header_swigregister(index_metric_header)
+
+def index_metric_header_default_header():
+    return _py_interop_metrics.index_metric_header_default_header()
+
+class index_metric(base_read_metric):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    TYPE = _py_interop_metrics.index_metric_TYPE
+    LATEST_VERSION = _py_interop_metrics.index_metric_LATEST_VERSION
+
+    def __init__(self, *args):
+        _py_interop_metrics.index_metric_swiginit(self, _py_interop_metrics.new_index_metric(*args))
+
+    def size(self):
+        return _py_interop_metrics.index_metric_size(self)
+
+    def indices(self, *args):
+        return _py_interop_metrics.index_metric_indices(self, *args)
+
+    def cluster_count(self):
+        return _py_interop_metrics.index_metric_cluster_count(self)
+
+    def cluster_count_pf(self):
+        return _py_interop_metrics.index_metric_cluster_count_pf(self)
+
+    def set_cluster_counts(self, cluster_count, cluster_count_pf):
+        return _py_interop_metrics.index_metric_set_cluster_counts(self, cluster_count, cluster_count_pf)
+
+    @staticmethod
+    def prefix():
+        return _py_interop_metrics.index_metric_prefix()
+
+    def percent_demultiplexed(self, sample_id):
+        return _py_interop_metrics.index_metric_percent_demultiplexed(self, sample_id)
+    __swig_destroy__ = _py_interop_metrics.delete_index_metric
+
+# Register index_metric in _py_interop_metrics:
+_py_interop_metrics.index_metric_swigregister(index_metric)
+
+def index_metric_prefix():
+    return _py_interop_metrics.index_metric_prefix()
+
+class q_collapsed_header(q_score_header):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _py_interop_metrics.q_collapsed_header_swiginit(self, _py_interop_metrics.new_q_collapsed_header(*args))
+
+    @staticmethod
+    def default_header():
+        return _py_interop_metrics.q_collapsed_header_default_header()
+
+    def clear(self):
+        return _py_interop_metrics.q_collapsed_header_clear(self)
+    __swig_destroy__ = _py_interop_metrics.delete_q_collapsed_header
+
+# Register q_collapsed_header in _py_interop_metrics:
+_py_interop_metrics.q_collapsed_header_swigregister(q_collapsed_header)
+
+def q_collapsed_header_default_header():
+    return _py_interop_metrics.q_collapsed_header_default_header()
+
+class q_collapsed_metric(base_cycle_metric):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    TYPE = _py_interop_metrics.q_collapsed_metric_TYPE
+    LATEST_VERSION = _py_interop_metrics.q_collapsed_metric_LATEST_VERSION
+
+    def __init__(self, *args):
+        _py_interop_metrics.q_collapsed_metric_swiginit(self, _py_interop_metrics.new_q_collapsed_metric(*args))
+
+    def q20(self):
+        return _py_interop_metrics.q_collapsed_metric_q20(self)
+
+    def q30(self):
+        return _py_interop_metrics.q_collapsed_metric_q30(self)
+
+    def total(self):
+        return _py_interop_metrics.q_collapsed_metric_total(self)
+
+    def median_qscore(self):
+        return _py_interop_metrics.q_collapsed_metric_median_qscore(self)
+
+    def median_qscore_flt(self):
+        return _py_interop_metrics.q_collapsed_metric_median_qscore_flt(self)
+
+    def cumulative_q20(self):
+        return _py_interop_metrics.q_collapsed_metric_cumulative_q20(self)
+
+    def cumulative_q30(self):
+        return _py_interop_metrics.q_collapsed_metric_cumulative_q30(self)
+
+    def cumulative_total(self):
+        return _py_interop_metrics.q_collapsed_metric_cumulative_total(self)
+
+    def percent_over_q20(self):
+        return _py_interop_metrics.q_collapsed_metric_percent_over_q20(self)
+
+    def percent_over_q30(self):
+        return _py_interop_metrics.q_collapsed_metric_percent_over_q30(self)
+
+    def cumulative_percent_over_q20(self):
+        return _py_interop_metrics.q_collapsed_metric_cumulative_percent_over_q20(self)
+
+    def cumulative_percent_over_q30(self):
+        return _py_interop_metrics.q_collapsed_metric_cumulative_percent_over_q30(self)
+
+    def accumulate(self, metric):
+        return _py_interop_metrics.q_collapsed_metric_accumulate(self, metric)
+
+    @staticmethod
+    def prefix():
+        return _py_interop_metrics.q_collapsed_metric_prefix()
+
+    @staticmethod
+    def suffix():
+        return _py_interop_metrics.q_collapsed_metric_suffix()
+    __swig_destroy__ = _py_interop_metrics.delete_q_collapsed_metric
+
+# Register q_collapsed_metric in _py_interop_metrics:
+_py_interop_metrics.q_collapsed_metric_swigregister(q_collapsed_metric)
+
+def q_collapsed_metric_prefix():
+    return _py_interop_metrics.q_collapsed_metric_prefix()
+
+def q_collapsed_metric_suffix():
+    return _py_interop_metrics.q_collapsed_metric_suffix()
+
+class q_by_lane_metric(q_metric):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    TYPE = _py_interop_metrics.q_by_lane_metric_TYPE
+    LATEST_VERSION = _py_interop_metrics.q_by_lane_metric_LATEST_VERSION
+
+    def __init__(self, *args):
+        _py_interop_metrics.q_by_lane_metric_swiginit(self, _py_interop_metrics.new_q_by_lane_metric(*args))
+
+    def accumulate_by_lane(self, metric):
+        return _py_interop_metrics.q_by_lane_metric_accumulate_by_lane(self, metric)
+
+    @staticmethod
+    def suffix():
+        return _py_interop_metrics.q_by_lane_metric_suffix()
+    __swig_destroy__ = _py_interop_metrics.delete_q_by_lane_metric
+
+# Register q_by_lane_metric in _py_interop_metrics:
+_py_interop_metrics.q_by_lane_metric_swigregister(q_by_lane_metric)
+
+def q_by_lane_metric_suffix():
+    return _py_interop_metrics.q_by_lane_metric_suffix()
+
+class summary_run_metric(empty_metric):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    TYPE = _py_interop_metrics.summary_run_metric_TYPE
+    LATEST_VERSION = _py_interop_metrics.summary_run_metric_LATEST_VERSION
+
+    def __init__(self, *args):
+        _py_interop_metrics.summary_run_metric_swiginit(self, _py_interop_metrics.new_summary_run_metric(*args))
+
+    def set(self, occupancy_proxy_cluster_count, raw_cluster_count, occupied_cluster_count, pf_cluster_count):
+        return _py_interop_metrics.summary_run_metric_set(self, occupancy_proxy_cluster_count, raw_cluster_count, occupied_cluster_count, pf_cluster_count)
+
+    def raw_cluster_count(self):
+        return _py_interop_metrics.summary_run_metric_raw_cluster_count(self)
+
+    def occupied_cluster_count(self):
+        return _py_interop_metrics.summary_run_metric_occupied_cluster_count(self)
+
+    def pf_cluster_count(self):
+        return _py_interop_metrics.summary_run_metric_pf_cluster_count(self)
+
+    def occupancy_proxy_cluster_count(self):
+        return _py_interop_metrics.summary_run_metric_occupancy_proxy_cluster_count(self)
+
+    def percent_occupancy_proxy(self):
+        return _py_interop_metrics.summary_run_metric_percent_occupancy_proxy(self)
+
+    def percent_pf(self):
+        return _py_interop_metrics.summary_run_metric_percent_pf(self)
+
+    def percent_occupied(self):
+        return _py_interop_metrics.summary_run_metric_percent_occupied(self)
+
+    def id(self):
+        return _py_interop_metrics.summary_run_metric_id(self)
+
+    @staticmethod
+    def prefix():
+        return _py_interop_metrics.summary_run_metric_prefix()
+
+    @staticmethod
+    def missing():
+        return _py_interop_metrics.summary_run_metric_missing()
+    __swig_destroy__ = _py_interop_metrics.delete_summary_run_metric
+
+# Register summary_run_metric in _py_interop_metrics:
+_py_interop_metrics.summary_run_metric_swigregister(summary_run_metric)
+
+def summary_run_metric_prefix():
+    return _py_interop_metrics.summary_run_metric_prefix()
+
+def summary_run_metric_missing():
+    return _py_interop_metrics.summary_run_metric_missing()
+
+class base_corrected_intensity_metrics(base_cycle_metric_header):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    TYPE = _py_interop_metrics.base_corrected_intensity_metrics_TYPE
+    LATEST_VERSION = _py_interop_metrics.base_corrected_intensity_metrics_LATEST_VERSION
+
+    def __init__(self, *args):
+        _py_interop_metrics.base_corrected_intensity_metrics_swiginit(self, _py_interop_metrics.new_base_corrected_intensity_metrics(*args))
+
+    def copy_by_tile(self, origin, tile_id):
+        return _py_interop_metrics.base_corrected_intensity_metrics_copy_by_tile(self, origin, tile_id)
+
+    def append_tiles(self, origin, tile_id):
+        return _py_interop_metrics.base_corrected_intensity_metrics_append_tiles(self, origin, tile_id)
+
+    def data_source_exists(self, *args):
+        return _py_interop_metrics.base_corrected_intensity_metrics_data_source_exists(self, *args)
+
+    def sort(self):
+        return _py_interop_metrics.base_corrected_intensity_metrics_sort(self)
+
+    def rebuild_index(self, update_ids=False):
+        return _py_interop_metrics.base_corrected_intensity_metrics_rebuild_index(self, update_ids)
+
+    def resize(self, n):
+        return _py_interop_metrics.base_corrected_intensity_metrics_resize(self, n)
+
+    def reserve(self, n):
+        return _py_interop_metrics.base_corrected_intensity_metrics_reserve(self, n)
+
+    def trim(self, n):
+        return _py_interop_metrics.base_corrected_intensity_metrics_trim(self, n)
+
+    def insert(self, *args):
+        return _py_interop_metrics.base_corrected_intensity_metrics_insert(self, *args)
+
+    def at(self, n):
+        return _py_interop_metrics.base_corrected_intensity_metrics_at(self, n)
+
+    def set_version(self, version):
+        return _py_interop_metrics.base_corrected_intensity_metrics_set_version(self, version)
+
+    def keys(self):
+        return _py_interop_metrics.base_corrected_intensity_metrics_keys(self)
+
+    def lanes(self):
+        return _py_interop_metrics.base_corrected_intensity_metrics_lanes(self)
+
+    def lane_count(self):
+        return _py_interop_metrics.base_corrected_intensity_metrics_lane_count(self)
+
+    def max_lane(self):
+        return _py_interop_metrics.base_corrected_intensity_metrics_max_lane(self)
+
+    def tile_numbers_for_lane(self, lane):
+        return _py_interop_metrics.base_corrected_intensity_metrics_tile_numbers_for_lane(self, lane)
+
+    def tile_numbers(self):
+        return _py_interop_metrics.base_corrected_intensity_metrics_tile_numbers(self)
+
+    def metrics_for_lane(self, *args):
+        return _py_interop_metrics.base_corrected_intensity_metrics_metrics_for_lane(self, *args)
+
+    def cycles(self):
+        return _py_interop_metrics.base_corrected_intensity_metrics_cycles(self)
+
+    def metrics_for_cycle(self, cycle):
+        return _py_interop_metrics.base_corrected_intensity_metrics_metrics_for_cycle(self, cycle)
+
+    def size(self):
+        return _py_interop_metrics.base_corrected_intensity_metrics_size(self)
+
+    def empty(self):
+        return _py_interop_metrics.base_corrected_intensity_metrics_empty(self)
+
+    def version(self):
+        return _py_interop_metrics.base_corrected_intensity_metrics_version(self)
+
+    def clear(self):
+        return _py_interop_metrics.base_corrected_intensity_metrics_clear(self)
+
+    def metrics(self):
+        return _py_interop_metrics.base_corrected_intensity_metrics_metrics(self)
+
+    @staticmethod
+    def prefix():
+        return _py_interop_metrics.base_corrected_intensity_metrics_prefix()
+
+    @staticmethod
+    def suffix():
+        return _py_interop_metrics.base_corrected_intensity_metrics_suffix()
+
+    def get_metric_ref(self, *args):
+        return _py_interop_metrics.base_corrected_intensity_metrics_get_metric_ref(self, *args)
+
+    def find(self, *args):
+        return _py_interop_metrics.base_corrected_intensity_metrics_find(self, *args)
+
+    def get_metric(self, *args):
+        return _py_interop_metrics.base_corrected_intensity_metrics_get_metric(self, *args)
+
+    def has_metric(self, *args):
+        return _py_interop_metrics.base_corrected_intensity_metrics_has_metric(self, *args)
+
+    def clear_lookup(self):
+        return _py_interop_metrics.base_corrected_intensity_metrics_clear_lookup(self)
+    __swig_destroy__ = _py_interop_metrics.delete_base_corrected_intensity_metrics
+
+# Register base_corrected_intensity_metrics in _py_interop_metrics:
+_py_interop_metrics.base_corrected_intensity_metrics_swigregister(base_corrected_intensity_metrics)
+
+def base_corrected_intensity_metrics_prefix():
+    return _py_interop_metrics.base_corrected_intensity_metrics_prefix()
+
+def base_corrected_intensity_metrics_suffix():
+    return _py_interop_metrics.base_corrected_intensity_metrics_suffix()
+
+class vector_corrected_intensity_metrics(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _py_interop_metrics.vector_corrected_intensity_metrics___nonzero__(self)
+
+    def __bool__(self):
+        return _py_interop_metrics.vector_corrected_intensity_metrics___bool__(self)
+
+    def __len__(self):
+        return _py_interop_metrics.vector_corrected_intensity_metrics___len__(self)
+
+    def __getslice__(self, i, j):
+        return _py_interop_metrics.vector_corrected_intensity_metrics___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _py_interop_metrics.vector_corrected_intensity_metrics___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _py_interop_metrics.vector_corrected_intensity_metrics___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _py_interop_metrics.vector_corrected_intensity_metrics___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _py_interop_metrics.vector_corrected_intensity_metrics___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _py_interop_metrics.vector_corrected_intensity_metrics___setitem__(self, *args)
+
+    def pop(self):
+        return _py_interop_metrics.vector_corrected_intensity_metrics_pop(self)
+
+    def append(self, x):
+        return _py_interop_metrics.vector_corrected_intensity_metrics_append(self, x)
+
+    def empty(self):
+        return _py_interop_metrics.vector_corrected_intensity_metrics_empty(self)
+
+    def size(self):
+        return _py_interop_metrics.vector_corrected_intensity_metrics_size(self)
+
+    def swap(self, v):
+        return _py_interop_metrics.vector_corrected_intensity_metrics_swap(self, v)
+
+    def rbegin(self):
+        return _py_interop_metrics.vector_corrected_intensity_metrics_rbegin(self)
+
+    def rend(self):
+        return _py_interop_metrics.vector_corrected_intensity_metrics_rend(self)
+
+    def clear(self):
+        return _py_interop_metrics.vector_corrected_intensity_metrics_clear(self)
+
+    def get_allocator(self):
+        return _py_interop_metrics.vector_corrected_intensity_metrics_get_allocator(self)
+
+    def pop_back(self):
+        return _py_interop_metrics.vector_corrected_intensity_metrics_pop_back(self)
+
+    def erase(self, *args):
+        return _py_interop_metrics.vector_corrected_intensity_metrics_erase(self, *args)
+
+    def __init__(self, *args):
+        _py_interop_metrics.vector_corrected_intensity_metrics_swiginit(self, _py_interop_metrics.new_vector_corrected_intensity_metrics(*args))
+
+    def push_back(self, x):
+        return _py_interop_metrics.vector_corrected_intensity_metrics_push_back(self, x)
+
+    def front(self):
+        return _py_interop_metrics.vector_corrected_intensity_metrics_front(self)
+
+    def back(self):
+        return _py_interop_metrics.vector_corrected_intensity_metrics_back(self)
+
+    def assign(self, n, x):
+        return _py_interop_metrics.vector_corrected_intensity_metrics_assign(self, n, x)
+
+    def resize(self, *args):
+        return _py_interop_metrics.vector_corrected_intensity_metrics_resize(self, *args)
+
+    def insert(self, *args):
+        return _py_interop_metrics.vector_corrected_intensity_metrics_insert(self, *args)
+
+    def reserve(self, n):
+        return _py_interop_metrics.vector_corrected_intensity_metrics_reserve(self, n)
+
+    def capacity(self):
+        return _py_interop_metrics.vector_corrected_intensity_metrics_capacity(self)
+    __swig_destroy__ = _py_interop_metrics.delete_vector_corrected_intensity_metrics
+
+# Register vector_corrected_intensity_metrics in _py_interop_metrics:
+_py_interop_metrics.vector_corrected_intensity_metrics_swigregister(vector_corrected_intensity_metrics)
+
+class base_error_metrics(error_metric_header):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    TYPE = _py_interop_metrics.base_error_metrics_TYPE
+    LATEST_VERSION = _py_interop_metrics.base_error_metrics_LATEST_VERSION
+
+    def __init__(self, *args):
+        _py_interop_metrics.base_error_metrics_swiginit(self, _py_interop_metrics.new_base_error_metrics(*args))
+
+    def copy_by_tile(self, origin, tile_id):
+        return _py_interop_metrics.base_error_metrics_copy_by_tile(self, origin, tile_id)
+
+    def append_tiles(self, origin, tile_id):
+        return _py_interop_metrics.base_error_metrics_append_tiles(self, origin, tile_id)
+
+    def data_source_exists(self, *args):
+        return _py_interop_metrics.base_error_metrics_data_source_exists(self, *args)
+
+    def sort(self):
+        return _py_interop_metrics.base_error_metrics_sort(self)
+
+    def rebuild_index(self, update_ids=False):
+        return _py_interop_metrics.base_error_metrics_rebuild_index(self, update_ids)
+
+    def resize(self, n):
+        return _py_interop_metrics.base_error_metrics_resize(self, n)
+
+    def reserve(self, n):
+        return _py_interop_metrics.base_error_metrics_reserve(self, n)
+
+    def trim(self, n):
+        return _py_interop_metrics.base_error_metrics_trim(self, n)
+
+    def insert(self, *args):
+        return _py_interop_metrics.base_error_metrics_insert(self, *args)
+
+    def at(self, n):
+        return _py_interop_metrics.base_error_metrics_at(self, n)
+
+    def set_version(self, version):
+        return _py_interop_metrics.base_error_metrics_set_version(self, version)
+
+    def keys(self):
+        return _py_interop_metrics.base_error_metrics_keys(self)
+
+    def lanes(self):
+        return _py_interop_metrics.base_error_metrics_lanes(self)
+
+    def lane_count(self):
+        return _py_interop_metrics.base_error_metrics_lane_count(self)
+
+    def max_lane(self):
+        return _py_interop_metrics.base_error_metrics_max_lane(self)
+
+    def tile_numbers_for_lane(self, lane):
+        return _py_interop_metrics.base_error_metrics_tile_numbers_for_lane(self, lane)
+
+    def tile_numbers(self):
+        return _py_interop_metrics.base_error_metrics_tile_numbers(self)
+
+    def metrics_for_lane(self, *args):
+        return _py_interop_metrics.base_error_metrics_metrics_for_lane(self, *args)
+
+    def cycles(self):
+        return _py_interop_metrics.base_error_metrics_cycles(self)
+
+    def metrics_for_cycle(self, cycle):
+        return _py_interop_metrics.base_error_metrics_metrics_for_cycle(self, cycle)
+
+    def size(self):
+        return _py_interop_metrics.base_error_metrics_size(self)
+
+    def empty(self):
+        return _py_interop_metrics.base_error_metrics_empty(self)
+
+    def version(self):
+        return _py_interop_metrics.base_error_metrics_version(self)
+
+    def clear(self):
+        return _py_interop_metrics.base_error_metrics_clear(self)
+
+    def metrics(self):
+        return _py_interop_metrics.base_error_metrics_metrics(self)
+
+    @staticmethod
+    def prefix():
+        return _py_interop_metrics.base_error_metrics_prefix()
+
+    @staticmethod
+    def suffix():
+        return _py_interop_metrics.base_error_metrics_suffix()
+
+    def get_metric_ref(self, *args):
+        return _py_interop_metrics.base_error_metrics_get_metric_ref(self, *args)
+
+    def find(self, *args):
+        return _py_interop_metrics.base_error_metrics_find(self, *args)
+
+    def get_metric(self, *args):
+        return _py_interop_metrics.base_error_metrics_get_metric(self, *args)
+
+    def has_metric(self, *args):
+        return _py_interop_metrics.base_error_metrics_has_metric(self, *args)
+
+    def clear_lookup(self):
+        return _py_interop_metrics.base_error_metrics_clear_lookup(self)
+    __swig_destroy__ = _py_interop_metrics.delete_base_error_metrics
+
+# Register base_error_metrics in _py_interop_metrics:
+_py_interop_metrics.base_error_metrics_swigregister(base_error_metrics)
+
+def base_error_metrics_prefix():
+    return _py_interop_metrics.base_error_metrics_prefix()
+
+def base_error_metrics_suffix():
+    return _py_interop_metrics.base_error_metrics_suffix()
+
+class vector_error_metrics(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _py_interop_metrics.vector_error_metrics___nonzero__(self)
+
+    def __bool__(self):
+        return _py_interop_metrics.vector_error_metrics___bool__(self)
+
+    def __len__(self):
+        return _py_interop_metrics.vector_error_metrics___len__(self)
+
+    def __getslice__(self, i, j):
+        return _py_interop_metrics.vector_error_metrics___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _py_interop_metrics.vector_error_metrics___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _py_interop_metrics.vector_error_metrics___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _py_interop_metrics.vector_error_metrics___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _py_interop_metrics.vector_error_metrics___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _py_interop_metrics.vector_error_metrics___setitem__(self, *args)
+
+    def pop(self):
+        return _py_interop_metrics.vector_error_metrics_pop(self)
+
+    def append(self, x):
+        return _py_interop_metrics.vector_error_metrics_append(self, x)
+
+    def empty(self):
+        return _py_interop_metrics.vector_error_metrics_empty(self)
+
+    def size(self):
+        return _py_interop_metrics.vector_error_metrics_size(self)
+
+    def swap(self, v):
+        return _py_interop_metrics.vector_error_metrics_swap(self, v)
+
+    def rbegin(self):
+        return _py_interop_metrics.vector_error_metrics_rbegin(self)
+
+    def rend(self):
+        return _py_interop_metrics.vector_error_metrics_rend(self)
+
+    def clear(self):
+        return _py_interop_metrics.vector_error_metrics_clear(self)
+
+    def get_allocator(self):
+        return _py_interop_metrics.vector_error_metrics_get_allocator(self)
+
+    def pop_back(self):
+        return _py_interop_metrics.vector_error_metrics_pop_back(self)
+
+    def erase(self, *args):
+        return _py_interop_metrics.vector_error_metrics_erase(self, *args)
+
+    def __init__(self, *args):
+        _py_interop_metrics.vector_error_metrics_swiginit(self, _py_interop_metrics.new_vector_error_metrics(*args))
+
+    def push_back(self, x):
+        return _py_interop_metrics.vector_error_metrics_push_back(self, x)
+
+    def front(self):
+        return _py_interop_metrics.vector_error_metrics_front(self)
+
+    def back(self):
+        return _py_interop_metrics.vector_error_metrics_back(self)
+
+    def assign(self, n, x):
+        return _py_interop_metrics.vector_error_metrics_assign(self, n, x)
+
+    def resize(self, *args):
+        return _py_interop_metrics.vector_error_metrics_resize(self, *args)
+
+    def insert(self, *args):
+        return _py_interop_metrics.vector_error_metrics_insert(self, *args)
+
+    def reserve(self, n):
+        return _py_interop_metrics.vector_error_metrics_reserve(self, n)
+
+    def capacity(self):
+        return _py_interop_metrics.vector_error_metrics_capacity(self)
+    __swig_destroy__ = _py_interop_metrics.delete_vector_error_metrics
+
+# Register vector_error_metrics in _py_interop_metrics:
+_py_interop_metrics.vector_error_metrics_swigregister(vector_error_metrics)
+
+class base_extended_tile_metrics(base_metric_header):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    TYPE = _py_interop_metrics.base_extended_tile_metrics_TYPE
+    LATEST_VERSION = _py_interop_metrics.base_extended_tile_metrics_LATEST_VERSION
+
+    def __init__(self, *args):
+        _py_interop_metrics.base_extended_tile_metrics_swiginit(self, _py_interop_metrics.new_base_extended_tile_metrics(*args))
+
+    def copy_by_tile(self, origin, tile_id):
+        return _py_interop_metrics.base_extended_tile_metrics_copy_by_tile(self, origin, tile_id)
+
+    def append_tiles(self, origin, tile_id):
+        return _py_interop_metrics.base_extended_tile_metrics_append_tiles(self, origin, tile_id)
+
+    def data_source_exists(self, *args):
+        return _py_interop_metrics.base_extended_tile_metrics_data_source_exists(self, *args)
+
+    def sort(self):
+        return _py_interop_metrics.base_extended_tile_metrics_sort(self)
+
+    def rebuild_index(self, update_ids=False):
+        return _py_interop_metrics.base_extended_tile_metrics_rebuild_index(self, update_ids)
+
+    def resize(self, n):
+        return _py_interop_metrics.base_extended_tile_metrics_resize(self, n)
+
+    def reserve(self, n):
+        return _py_interop_metrics.base_extended_tile_metrics_reserve(self, n)
+
+    def trim(self, n):
+        return _py_interop_metrics.base_extended_tile_metrics_trim(self, n)
+
+    def insert(self, *args):
+        return _py_interop_metrics.base_extended_tile_metrics_insert(self, *args)
+
+    def at(self, n):
+        return _py_interop_metrics.base_extended_tile_metrics_at(self, n)
+
+    def set_version(self, version):
+        return _py_interop_metrics.base_extended_tile_metrics_set_version(self, version)
+
+    def keys(self):
+        return _py_interop_metrics.base_extended_tile_metrics_keys(self)
+
+    def lanes(self):
+        return _py_interop_metrics.base_extended_tile_metrics_lanes(self)
+
+    def lane_count(self):
+        return _py_interop_metrics.base_extended_tile_metrics_lane_count(self)
+
+    def max_lane(self):
+        return _py_interop_metrics.base_extended_tile_metrics_max_lane(self)
+
+    def tile_numbers_for_lane(self, lane):
+        return _py_interop_metrics.base_extended_tile_metrics_tile_numbers_for_lane(self, lane)
+
+    def tile_numbers(self):
+        return _py_interop_metrics.base_extended_tile_metrics_tile_numbers(self)
+
+    def metrics_for_lane(self, *args):
+        return _py_interop_metrics.base_extended_tile_metrics_metrics_for_lane(self, *args)
+
+    def cycles(self):
+        return _py_interop_metrics.base_extended_tile_metrics_cycles(self)
+
+    def metrics_for_cycle(self, cycle):
+        return _py_interop_metrics.base_extended_tile_metrics_metrics_for_cycle(self, cycle)
+
+    def size(self):
+        return _py_interop_metrics.base_extended_tile_metrics_size(self)
+
+    def empty(self):
+        return _py_interop_metrics.base_extended_tile_metrics_empty(self)
+
+    def version(self):
+        return _py_interop_metrics.base_extended_tile_metrics_version(self)
+
+    def clear(self):
+        return _py_interop_metrics.base_extended_tile_metrics_clear(self)
+
+    def metrics(self):
+        return _py_interop_metrics.base_extended_tile_metrics_metrics(self)
+
+    @staticmethod
+    def prefix():
+        return _py_interop_metrics.base_extended_tile_metrics_prefix()
+
+    @staticmethod
+    def suffix():
+        return _py_interop_metrics.base_extended_tile_metrics_suffix()
+
+    def get_metric_ref(self, *args):
+        return _py_interop_metrics.base_extended_tile_metrics_get_metric_ref(self, *args)
+
+    def find(self, *args):
+        return _py_interop_metrics.base_extended_tile_metrics_find(self, *args)
+
+    def get_metric(self, *args):
+        return _py_interop_metrics.base_extended_tile_metrics_get_metric(self, *args)
+
+    def has_metric(self, *args):
+        return _py_interop_metrics.base_extended_tile_metrics_has_metric(self, *args)
+
+    def clear_lookup(self):
+        return _py_interop_metrics.base_extended_tile_metrics_clear_lookup(self)
+    __swig_destroy__ = _py_interop_metrics.delete_base_extended_tile_metrics
+
+# Register base_extended_tile_metrics in _py_interop_metrics:
+_py_interop_metrics.base_extended_tile_metrics_swigregister(base_extended_tile_metrics)
+
+def base_extended_tile_metrics_prefix():
+    return _py_interop_metrics.base_extended_tile_metrics_prefix()
+
+def base_extended_tile_metrics_suffix():
+    return _py_interop_metrics.base_extended_tile_metrics_suffix()
+
+class vector_extended_tile_metrics(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _py_interop_metrics.vector_extended_tile_metrics___nonzero__(self)
+
+    def __bool__(self):
+        return _py_interop_metrics.vector_extended_tile_metrics___bool__(self)
+
+    def __len__(self):
+        return _py_interop_metrics.vector_extended_tile_metrics___len__(self)
+
+    def __getslice__(self, i, j):
+        return _py_interop_metrics.vector_extended_tile_metrics___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _py_interop_metrics.vector_extended_tile_metrics___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _py_interop_metrics.vector_extended_tile_metrics___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _py_interop_metrics.vector_extended_tile_metrics___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _py_interop_metrics.vector_extended_tile_metrics___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _py_interop_metrics.vector_extended_tile_metrics___setitem__(self, *args)
+
+    def pop(self):
+        return _py_interop_metrics.vector_extended_tile_metrics_pop(self)
+
+    def append(self, x):
+        return _py_interop_metrics.vector_extended_tile_metrics_append(self, x)
+
+    def empty(self):
+        return _py_interop_metrics.vector_extended_tile_metrics_empty(self)
+
+    def size(self):
+        return _py_interop_metrics.vector_extended_tile_metrics_size(self)
+
+    def swap(self, v):
+        return _py_interop_metrics.vector_extended_tile_metrics_swap(self, v)
+
+    def rbegin(self):
+        return _py_interop_metrics.vector_extended_tile_metrics_rbegin(self)
+
+    def rend(self):
+        return _py_interop_metrics.vector_extended_tile_metrics_rend(self)
+
+    def clear(self):
+        return _py_interop_metrics.vector_extended_tile_metrics_clear(self)
+
+    def get_allocator(self):
+        return _py_interop_metrics.vector_extended_tile_metrics_get_allocator(self)
+
+    def pop_back(self):
+        return _py_interop_metrics.vector_extended_tile_metrics_pop_back(self)
+
+    def erase(self, *args):
+        return _py_interop_metrics.vector_extended_tile_metrics_erase(self, *args)
+
+    def __init__(self, *args):
+        _py_interop_metrics.vector_extended_tile_metrics_swiginit(self, _py_interop_metrics.new_vector_extended_tile_metrics(*args))
+
+    def push_back(self, x):
+        return _py_interop_metrics.vector_extended_tile_metrics_push_back(self, x)
+
+    def front(self):
+        return _py_interop_metrics.vector_extended_tile_metrics_front(self)
+
+    def back(self):
+        return _py_interop_metrics.vector_extended_tile_metrics_back(self)
+
+    def assign(self, n, x):
+        return _py_interop_metrics.vector_extended_tile_metrics_assign(self, n, x)
+
+    def resize(self, *args):
+        return _py_interop_metrics.vector_extended_tile_metrics_resize(self, *args)
+
+    def insert(self, *args):
+        return _py_interop_metrics.vector_extended_tile_metrics_insert(self, *args)
+
+    def reserve(self, n):
+        return _py_interop_metrics.vector_extended_tile_metrics_reserve(self, n)
+
+    def capacity(self):
+        return _py_interop_metrics.vector_extended_tile_metrics_capacity(self)
+    __swig_destroy__ = _py_interop_metrics.delete_vector_extended_tile_metrics
+
+# Register vector_extended_tile_metrics in _py_interop_metrics:
+_py_interop_metrics.vector_extended_tile_metrics_swigregister(vector_extended_tile_metrics)
+
+class base_extraction_metrics(extraction_metric_header):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    TYPE = _py_interop_metrics.base_extraction_metrics_TYPE
+    LATEST_VERSION = _py_interop_metrics.base_extraction_metrics_LATEST_VERSION
+
+    def __init__(self, *args):
+        _py_interop_metrics.base_extraction_metrics_swiginit(self, _py_interop_metrics.new_base_extraction_metrics(*args))
+
+    def copy_by_tile(self, origin, tile_id):
+        return _py_interop_metrics.base_extraction_metrics_copy_by_tile(self, origin, tile_id)
+
+    def append_tiles(self, origin, tile_id):
+        return _py_interop_metrics.base_extraction_metrics_append_tiles(self, origin, tile_id)
+
+    def data_source_exists(self, *args):
+        return _py_interop_metrics.base_extraction_metrics_data_source_exists(self, *args)
+
+    def sort(self):
+        return _py_interop_metrics.base_extraction_metrics_sort(self)
+
+    def rebuild_index(self, update_ids=False):
+        return _py_interop_metrics.base_extraction_metrics_rebuild_index(self, update_ids)
+
+    def resize(self, n):
+        return _py_interop_metrics.base_extraction_metrics_resize(self, n)
+
+    def reserve(self, n):
+        return _py_interop_metrics.base_extraction_metrics_reserve(self, n)
+
+    def trim(self, n):
+        return _py_interop_metrics.base_extraction_metrics_trim(self, n)
+
+    def insert(self, *args):
+        return _py_interop_metrics.base_extraction_metrics_insert(self, *args)
+
+    def at(self, n):
+        return _py_interop_metrics.base_extraction_metrics_at(self, n)
+
+    def set_version(self, version):
+        return _py_interop_metrics.base_extraction_metrics_set_version(self, version)
+
+    def keys(self):
+        return _py_interop_metrics.base_extraction_metrics_keys(self)
+
+    def lanes(self):
+        return _py_interop_metrics.base_extraction_metrics_lanes(self)
+
+    def lane_count(self):
+        return _py_interop_metrics.base_extraction_metrics_lane_count(self)
+
+    def max_lane(self):
+        return _py_interop_metrics.base_extraction_metrics_max_lane(self)
+
+    def tile_numbers_for_lane(self, lane):
+        return _py_interop_metrics.base_extraction_metrics_tile_numbers_for_lane(self, lane)
+
+    def tile_numbers(self):
+        return _py_interop_metrics.base_extraction_metrics_tile_numbers(self)
+
+    def metrics_for_lane(self, *args):
+        return _py_interop_metrics.base_extraction_metrics_metrics_for_lane(self, *args)
+
+    def cycles(self):
+        return _py_interop_metrics.base_extraction_metrics_cycles(self)
+
+    def metrics_for_cycle(self, cycle):
+        return _py_interop_metrics.base_extraction_metrics_metrics_for_cycle(self, cycle)
+
+    def size(self):
+        return _py_interop_metrics.base_extraction_metrics_size(self)
+
+    def empty(self):
+        return _py_interop_metrics.base_extraction_metrics_empty(self)
+
+    def version(self):
+        return _py_interop_metrics.base_extraction_metrics_version(self)
+
+    def clear(self):
+        return _py_interop_metrics.base_extraction_metrics_clear(self)
+
+    def metrics(self):
+        return _py_interop_metrics.base_extraction_metrics_metrics(self)
+
+    @staticmethod
+    def prefix():
+        return _py_interop_metrics.base_extraction_metrics_prefix()
+
+    @staticmethod
+    def suffix():
+        return _py_interop_metrics.base_extraction_metrics_suffix()
+
+    def get_metric_ref(self, *args):
+        return _py_interop_metrics.base_extraction_metrics_get_metric_ref(self, *args)
+
+    def find(self, *args):
+        return _py_interop_metrics.base_extraction_metrics_find(self, *args)
+
+    def get_metric(self, *args):
+        return _py_interop_metrics.base_extraction_metrics_get_metric(self, *args)
+
+    def has_metric(self, *args):
+        return _py_interop_metrics.base_extraction_metrics_has_metric(self, *args)
+
+    def clear_lookup(self):
+        return _py_interop_metrics.base_extraction_metrics_clear_lookup(self)
+    __swig_destroy__ = _py_interop_metrics.delete_base_extraction_metrics
+
+# Register base_extraction_metrics in _py_interop_metrics:
+_py_interop_metrics.base_extraction_metrics_swigregister(base_extraction_metrics)
+
+def base_extraction_metrics_prefix():
+    return _py_interop_metrics.base_extraction_metrics_prefix()
+
+def base_extraction_metrics_suffix():
+    return _py_interop_metrics.base_extraction_metrics_suffix()
+
+class vector_extraction_metrics(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _py_interop_metrics.vector_extraction_metrics___nonzero__(self)
+
+    def __bool__(self):
+        return _py_interop_metrics.vector_extraction_metrics___bool__(self)
+
+    def __len__(self):
+        return _py_interop_metrics.vector_extraction_metrics___len__(self)
+
+    def __getslice__(self, i, j):
+        return _py_interop_metrics.vector_extraction_metrics___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _py_interop_metrics.vector_extraction_metrics___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _py_interop_metrics.vector_extraction_metrics___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _py_interop_metrics.vector_extraction_metrics___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _py_interop_metrics.vector_extraction_metrics___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _py_interop_metrics.vector_extraction_metrics___setitem__(self, *args)
+
+    def pop(self):
+        return _py_interop_metrics.vector_extraction_metrics_pop(self)
+
+    def append(self, x):
+        return _py_interop_metrics.vector_extraction_metrics_append(self, x)
+
+    def empty(self):
+        return _py_interop_metrics.vector_extraction_metrics_empty(self)
+
+    def size(self):
+        return _py_interop_metrics.vector_extraction_metrics_size(self)
+
+    def swap(self, v):
+        return _py_interop_metrics.vector_extraction_metrics_swap(self, v)
+
+    def rbegin(self):
+        return _py_interop_metrics.vector_extraction_metrics_rbegin(self)
+
+    def rend(self):
+        return _py_interop_metrics.vector_extraction_metrics_rend(self)
+
+    def clear(self):
+        return _py_interop_metrics.vector_extraction_metrics_clear(self)
+
+    def get_allocator(self):
+        return _py_interop_metrics.vector_extraction_metrics_get_allocator(self)
+
+    def pop_back(self):
+        return _py_interop_metrics.vector_extraction_metrics_pop_back(self)
+
+    def erase(self, *args):
+        return _py_interop_metrics.vector_extraction_metrics_erase(self, *args)
+
+    def __init__(self, *args):
+        _py_interop_metrics.vector_extraction_metrics_swiginit(self, _py_interop_metrics.new_vector_extraction_metrics(*args))
+
+    def push_back(self, x):
+        return _py_interop_metrics.vector_extraction_metrics_push_back(self, x)
+
+    def front(self):
+        return _py_interop_metrics.vector_extraction_metrics_front(self)
+
+    def back(self):
+        return _py_interop_metrics.vector_extraction_metrics_back(self)
+
+    def assign(self, n, x):
+        return _py_interop_metrics.vector_extraction_metrics_assign(self, n, x)
+
+    def resize(self, *args):
+        return _py_interop_metrics.vector_extraction_metrics_resize(self, *args)
+
+    def insert(self, *args):
+        return _py_interop_metrics.vector_extraction_metrics_insert(self, *args)
+
+    def reserve(self, n):
+        return _py_interop_metrics.vector_extraction_metrics_reserve(self, n)
+
+    def capacity(self):
+        return _py_interop_metrics.vector_extraction_metrics_capacity(self)
+    __swig_destroy__ = _py_interop_metrics.delete_vector_extraction_metrics
+
+# Register vector_extraction_metrics in _py_interop_metrics:
+_py_interop_metrics.vector_extraction_metrics_swigregister(vector_extraction_metrics)
+
+class base_image_metrics(image_metric_header):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    TYPE = _py_interop_metrics.base_image_metrics_TYPE
+    LATEST_VERSION = _py_interop_metrics.base_image_metrics_LATEST_VERSION
+
+    def __init__(self, *args):
+        _py_interop_metrics.base_image_metrics_swiginit(self, _py_interop_metrics.new_base_image_metrics(*args))
+
+    def copy_by_tile(self, origin, tile_id):
+        return _py_interop_metrics.base_image_metrics_copy_by_tile(self, origin, tile_id)
+
+    def append_tiles(self, origin, tile_id):
+        return _py_interop_metrics.base_image_metrics_append_tiles(self, origin, tile_id)
+
+    def data_source_exists(self, *args):
+        return _py_interop_metrics.base_image_metrics_data_source_exists(self, *args)
+
+    def sort(self):
+        return _py_interop_metrics.base_image_metrics_sort(self)
+
+    def rebuild_index(self, update_ids=False):
+        return _py_interop_metrics.base_image_metrics_rebuild_index(self, update_ids)
+
+    def resize(self, n):
+        return _py_interop_metrics.base_image_metrics_resize(self, n)
+
+    def reserve(self, n):
+        return _py_interop_metrics.base_image_metrics_reserve(self, n)
+
+    def trim(self, n):
+        return _py_interop_metrics.base_image_metrics_trim(self, n)
+
+    def insert(self, *args):
+        return _py_interop_metrics.base_image_metrics_insert(self, *args)
+
+    def at(self, n):
+        return _py_interop_metrics.base_image_metrics_at(self, n)
+
+    def set_version(self, version):
+        return _py_interop_metrics.base_image_metrics_set_version(self, version)
+
+    def keys(self):
+        return _py_interop_metrics.base_image_metrics_keys(self)
+
+    def lanes(self):
+        return _py_interop_metrics.base_image_metrics_lanes(self)
+
+    def lane_count(self):
+        return _py_interop_metrics.base_image_metrics_lane_count(self)
+
+    def max_lane(self):
+        return _py_interop_metrics.base_image_metrics_max_lane(self)
+
+    def tile_numbers_for_lane(self, lane):
+        return _py_interop_metrics.base_image_metrics_tile_numbers_for_lane(self, lane)
+
+    def tile_numbers(self):
+        return _py_interop_metrics.base_image_metrics_tile_numbers(self)
+
+    def metrics_for_lane(self, *args):
+        return _py_interop_metrics.base_image_metrics_metrics_for_lane(self, *args)
+
+    def cycles(self):
+        return _py_interop_metrics.base_image_metrics_cycles(self)
+
+    def metrics_for_cycle(self, cycle):
+        return _py_interop_metrics.base_image_metrics_metrics_for_cycle(self, cycle)
+
+    def size(self):
+        return _py_interop_metrics.base_image_metrics_size(self)
+
+    def empty(self):
+        return _py_interop_metrics.base_image_metrics_empty(self)
+
+    def version(self):
+        return _py_interop_metrics.base_image_metrics_version(self)
+
+    def clear(self):
+        return _py_interop_metrics.base_image_metrics_clear(self)
+
+    def metrics(self):
+        return _py_interop_metrics.base_image_metrics_metrics(self)
+
+    @staticmethod
+    def prefix():
+        return _py_interop_metrics.base_image_metrics_prefix()
+
+    @staticmethod
+    def suffix():
+        return _py_interop_metrics.base_image_metrics_suffix()
+
+    def get_metric_ref(self, *args):
+        return _py_interop_metrics.base_image_metrics_get_metric_ref(self, *args)
+
+    def find(self, *args):
+        return _py_interop_metrics.base_image_metrics_find(self, *args)
+
+    def get_metric(self, *args):
+        return _py_interop_metrics.base_image_metrics_get_metric(self, *args)
+
+    def has_metric(self, *args):
+        return _py_interop_metrics.base_image_metrics_has_metric(self, *args)
+
+    def clear_lookup(self):
+        return _py_interop_metrics.base_image_metrics_clear_lookup(self)
+    __swig_destroy__ = _py_interop_metrics.delete_base_image_metrics
+
+# Register base_image_metrics in _py_interop_metrics:
+_py_interop_metrics.base_image_metrics_swigregister(base_image_metrics)
+
+def base_image_metrics_prefix():
+    return _py_interop_metrics.base_image_metrics_prefix()
+
+def base_image_metrics_suffix():
+    return _py_interop_metrics.base_image_metrics_suffix()
+
+class vector_image_metrics(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _py_interop_metrics.vector_image_metrics___nonzero__(self)
+
+    def __bool__(self):
+        return _py_interop_metrics.vector_image_metrics___bool__(self)
+
+    def __len__(self):
+        return _py_interop_metrics.vector_image_metrics___len__(self)
+
+    def __getslice__(self, i, j):
+        return _py_interop_metrics.vector_image_metrics___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _py_interop_metrics.vector_image_metrics___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _py_interop_metrics.vector_image_metrics___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _py_interop_metrics.vector_image_metrics___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _py_interop_metrics.vector_image_metrics___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _py_interop_metrics.vector_image_metrics___setitem__(self, *args)
+
+    def pop(self):
+        return _py_interop_metrics.vector_image_metrics_pop(self)
+
+    def append(self, x):
+        return _py_interop_metrics.vector_image_metrics_append(self, x)
+
+    def empty(self):
+        return _py_interop_metrics.vector_image_metrics_empty(self)
+
+    def size(self):
+        return _py_interop_metrics.vector_image_metrics_size(self)
+
+    def swap(self, v):
+        return _py_interop_metrics.vector_image_metrics_swap(self, v)
+
+    def rbegin(self):
+        return _py_interop_metrics.vector_image_metrics_rbegin(self)
+
+    def rend(self):
+        return _py_interop_metrics.vector_image_metrics_rend(self)
+
+    def clear(self):
+        return _py_interop_metrics.vector_image_metrics_clear(self)
+
+    def get_allocator(self):
+        return _py_interop_metrics.vector_image_metrics_get_allocator(self)
+
+    def pop_back(self):
+        return _py_interop_metrics.vector_image_metrics_pop_back(self)
+
+    def erase(self, *args):
+        return _py_interop_metrics.vector_image_metrics_erase(self, *args)
+
+    def __init__(self, *args):
+        _py_interop_metrics.vector_image_metrics_swiginit(self, _py_interop_metrics.new_vector_image_metrics(*args))
+
+    def push_back(self, x):
+        return _py_interop_metrics.vector_image_metrics_push_back(self, x)
+
+    def front(self):
+        return _py_interop_metrics.vector_image_metrics_front(self)
+
+    def back(self):
+        return _py_interop_metrics.vector_image_metrics_back(self)
+
+    def assign(self, n, x):
+        return _py_interop_metrics.vector_image_metrics_assign(self, n, x)
+
+    def resize(self, *args):
+        return _py_interop_metrics.vector_image_metrics_resize(self, *args)
+
+    def insert(self, *args):
+        return _py_interop_metrics.vector_image_metrics_insert(self, *args)
+
+    def reserve(self, n):
+        return _py_interop_metrics.vector_image_metrics_reserve(self, n)
+
+    def capacity(self):
+        return _py_interop_metrics.vector_image_metrics_capacity(self)
+    __swig_destroy__ = _py_interop_metrics.delete_vector_image_metrics
+
+# Register vector_image_metrics in _py_interop_metrics:
+_py_interop_metrics.vector_image_metrics_swigregister(vector_image_metrics)
+
+class base_q_metrics(q_score_header):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    TYPE = _py_interop_metrics.base_q_metrics_TYPE
+    LATEST_VERSION = _py_interop_metrics.base_q_metrics_LATEST_VERSION
+
+    def __init__(self, *args):
+        _py_interop_metrics.base_q_metrics_swiginit(self, _py_interop_metrics.new_base_q_metrics(*args))
+
+    def copy_by_tile(self, origin, tile_id):
+        return _py_interop_metrics.base_q_metrics_copy_by_tile(self, origin, tile_id)
+
+    def append_tiles(self, origin, tile_id):
+        return _py_interop_metrics.base_q_metrics_append_tiles(self, origin, tile_id)
+
+    def data_source_exists(self, *args):
+        return _py_interop_metrics.base_q_metrics_data_source_exists(self, *args)
+
+    def sort(self):
+        return _py_interop_metrics.base_q_metrics_sort(self)
+
+    def rebuild_index(self, update_ids=False):
+        return _py_interop_metrics.base_q_metrics_rebuild_index(self, update_ids)
+
+    def resize(self, n):
+        return _py_interop_metrics.base_q_metrics_resize(self, n)
+
+    def reserve(self, n):
+        return _py_interop_metrics.base_q_metrics_reserve(self, n)
+
+    def trim(self, n):
+        return _py_interop_metrics.base_q_metrics_trim(self, n)
+
+    def insert(self, *args):
+        return _py_interop_metrics.base_q_metrics_insert(self, *args)
+
+    def at(self, n):
+        return _py_interop_metrics.base_q_metrics_at(self, n)
+
+    def set_version(self, version):
+        return _py_interop_metrics.base_q_metrics_set_version(self, version)
+
+    def keys(self):
+        return _py_interop_metrics.base_q_metrics_keys(self)
+
+    def lanes(self):
+        return _py_interop_metrics.base_q_metrics_lanes(self)
+
+    def lane_count(self):
+        return _py_interop_metrics.base_q_metrics_lane_count(self)
+
+    def max_lane(self):
+        return _py_interop_metrics.base_q_metrics_max_lane(self)
+
+    def tile_numbers_for_lane(self, lane):
+        return _py_interop_metrics.base_q_metrics_tile_numbers_for_lane(self, lane)
+
+    def tile_numbers(self):
+        return _py_interop_metrics.base_q_metrics_tile_numbers(self)
+
+    def metrics_for_lane(self, *args):
+        return _py_interop_metrics.base_q_metrics_metrics_for_lane(self, *args)
+
+    def cycles(self):
+        return _py_interop_metrics.base_q_metrics_cycles(self)
+
+    def metrics_for_cycle(self, cycle):
+        return _py_interop_metrics.base_q_metrics_metrics_for_cycle(self, cycle)
+
+    def size(self):
+        return _py_interop_metrics.base_q_metrics_size(self)
+
+    def empty(self):
+        return _py_interop_metrics.base_q_metrics_empty(self)
+
+    def version(self):
+        return _py_interop_metrics.base_q_metrics_version(self)
+
+    def clear(self):
+        return _py_interop_metrics.base_q_metrics_clear(self)
+
+    def metrics(self):
+        return _py_interop_metrics.base_q_metrics_metrics(self)
+
+    @staticmethod
+    def prefix():
+        return _py_interop_metrics.base_q_metrics_prefix()
+
+    @staticmethod
+    def suffix():
+        return _py_interop_metrics.base_q_metrics_suffix()
+
+    def get_metric_ref(self, *args):
+        return _py_interop_metrics.base_q_metrics_get_metric_ref(self, *args)
+
+    def find(self, *args):
+        return _py_interop_metrics.base_q_metrics_find(self, *args)
+
+    def get_metric(self, *args):
+        return _py_interop_metrics.base_q_metrics_get_metric(self, *args)
+
+    def has_metric(self, *args):
+        return _py_interop_metrics.base_q_metrics_has_metric(self, *args)
+
+    def clear_lookup(self):
+        return _py_interop_metrics.base_q_metrics_clear_lookup(self)
+    __swig_destroy__ = _py_interop_metrics.delete_base_q_metrics
+
+# Register base_q_metrics in _py_interop_metrics:
+_py_interop_metrics.base_q_metrics_swigregister(base_q_metrics)
+
+def base_q_metrics_prefix():
+    return _py_interop_metrics.base_q_metrics_prefix()
+
+def base_q_metrics_suffix():
+    return _py_interop_metrics.base_q_metrics_suffix()
+
+class vector_q_metrics(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _py_interop_metrics.vector_q_metrics___nonzero__(self)
+
+    def __bool__(self):
+        return _py_interop_metrics.vector_q_metrics___bool__(self)
+
+    def __len__(self):
+        return _py_interop_metrics.vector_q_metrics___len__(self)
+
+    def __getslice__(self, i, j):
+        return _py_interop_metrics.vector_q_metrics___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _py_interop_metrics.vector_q_metrics___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _py_interop_metrics.vector_q_metrics___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _py_interop_metrics.vector_q_metrics___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _py_interop_metrics.vector_q_metrics___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _py_interop_metrics.vector_q_metrics___setitem__(self, *args)
+
+    def pop(self):
+        return _py_interop_metrics.vector_q_metrics_pop(self)
+
+    def append(self, x):
+        return _py_interop_metrics.vector_q_metrics_append(self, x)
+
+    def empty(self):
+        return _py_interop_metrics.vector_q_metrics_empty(self)
+
+    def size(self):
+        return _py_interop_metrics.vector_q_metrics_size(self)
+
+    def swap(self, v):
+        return _py_interop_metrics.vector_q_metrics_swap(self, v)
+
+    def rbegin(self):
+        return _py_interop_metrics.vector_q_metrics_rbegin(self)
+
+    def rend(self):
+        return _py_interop_metrics.vector_q_metrics_rend(self)
+
+    def clear(self):
+        return _py_interop_metrics.vector_q_metrics_clear(self)
+
+    def get_allocator(self):
+        return _py_interop_metrics.vector_q_metrics_get_allocator(self)
+
+    def pop_back(self):
+        return _py_interop_metrics.vector_q_metrics_pop_back(self)
+
+    def erase(self, *args):
+        return _py_interop_metrics.vector_q_metrics_erase(self, *args)
+
+    def __init__(self, *args):
+        _py_interop_metrics.vector_q_metrics_swiginit(self, _py_interop_metrics.new_vector_q_metrics(*args))
+
+    def push_back(self, x):
+        return _py_interop_metrics.vector_q_metrics_push_back(self, x)
+
+    def front(self):
+        return _py_interop_metrics.vector_q_metrics_front(self)
+
+    def back(self):
+        return _py_interop_metrics.vector_q_metrics_back(self)
+
+    def assign(self, n, x):
+        return _py_interop_metrics.vector_q_metrics_assign(self, n, x)
+
+    def resize(self, *args):
+        return _py_interop_metrics.vector_q_metrics_resize(self, *args)
+
+    def insert(self, *args):
+        return _py_interop_metrics.vector_q_metrics_insert(self, *args)
+
+    def reserve(self, n):
+        return _py_interop_metrics.vector_q_metrics_reserve(self, n)
+
+    def capacity(self):
+        return _py_interop_metrics.vector_q_metrics_capacity(self)
+    __swig_destroy__ = _py_interop_metrics.delete_vector_q_metrics
+
+# Register vector_q_metrics in _py_interop_metrics:
+_py_interop_metrics.vector_q_metrics_swigregister(vector_q_metrics)
+
+class base_tile_metrics(tile_metric_header):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    TYPE = _py_interop_metrics.base_tile_metrics_TYPE
+    LATEST_VERSION = _py_interop_metrics.base_tile_metrics_LATEST_VERSION
+
+    def __init__(self, *args):
+        _py_interop_metrics.base_tile_metrics_swiginit(self, _py_interop_metrics.new_base_tile_metrics(*args))
+
+    def copy_by_tile(self, origin, tile_id):
+        return _py_interop_metrics.base_tile_metrics_copy_by_tile(self, origin, tile_id)
+
+    def append_tiles(self, origin, tile_id):
+        return _py_interop_metrics.base_tile_metrics_append_tiles(self, origin, tile_id)
+
+    def data_source_exists(self, *args):
+        return _py_interop_metrics.base_tile_metrics_data_source_exists(self, *args)
+
+    def sort(self):
+        return _py_interop_metrics.base_tile_metrics_sort(self)
+
+    def rebuild_index(self, update_ids=False):
+        return _py_interop_metrics.base_tile_metrics_rebuild_index(self, update_ids)
+
+    def resize(self, n):
+        return _py_interop_metrics.base_tile_metrics_resize(self, n)
+
+    def reserve(self, n):
+        return _py_interop_metrics.base_tile_metrics_reserve(self, n)
+
+    def trim(self, n):
+        return _py_interop_metrics.base_tile_metrics_trim(self, n)
+
+    def insert(self, *args):
+        return _py_interop_metrics.base_tile_metrics_insert(self, *args)
+
+    def at(self, n):
+        return _py_interop_metrics.base_tile_metrics_at(self, n)
+
+    def set_version(self, version):
+        return _py_interop_metrics.base_tile_metrics_set_version(self, version)
+
+    def keys(self):
+        return _py_interop_metrics.base_tile_metrics_keys(self)
+
+    def lanes(self):
+        return _py_interop_metrics.base_tile_metrics_lanes(self)
+
+    def lane_count(self):
+        return _py_interop_metrics.base_tile_metrics_lane_count(self)
+
+    def max_lane(self):
+        return _py_interop_metrics.base_tile_metrics_max_lane(self)
+
+    def tile_numbers_for_lane(self, lane):
+        return _py_interop_metrics.base_tile_metrics_tile_numbers_for_lane(self, lane)
+
+    def tile_numbers(self):
+        return _py_interop_metrics.base_tile_metrics_tile_numbers(self)
+
+    def metrics_for_lane(self, *args):
+        return _py_interop_metrics.base_tile_metrics_metrics_for_lane(self, *args)
+
+    def cycles(self):
+        return _py_interop_metrics.base_tile_metrics_cycles(self)
+
+    def metrics_for_cycle(self, cycle):
+        return _py_interop_metrics.base_tile_metrics_metrics_for_cycle(self, cycle)
+
+    def size(self):
+        return _py_interop_metrics.base_tile_metrics_size(self)
+
+    def empty(self):
+        return _py_interop_metrics.base_tile_metrics_empty(self)
+
+    def version(self):
+        return _py_interop_metrics.base_tile_metrics_version(self)
+
+    def clear(self):
+        return _py_interop_metrics.base_tile_metrics_clear(self)
+
+    def metrics(self):
+        return _py_interop_metrics.base_tile_metrics_metrics(self)
+
+    @staticmethod
+    def prefix():
+        return _py_interop_metrics.base_tile_metrics_prefix()
+
+    @staticmethod
+    def suffix():
+        return _py_interop_metrics.base_tile_metrics_suffix()
+
+    def get_metric_ref(self, *args):
+        return _py_interop_metrics.base_tile_metrics_get_metric_ref(self, *args)
+
+    def find(self, *args):
+        return _py_interop_metrics.base_tile_metrics_find(self, *args)
+
+    def get_metric(self, *args):
+        return _py_interop_metrics.base_tile_metrics_get_metric(self, *args)
+
+    def has_metric(self, *args):
+        return _py_interop_metrics.base_tile_metrics_has_metric(self, *args)
+
+    def clear_lookup(self):
+        return _py_interop_metrics.base_tile_metrics_clear_lookup(self)
+    __swig_destroy__ = _py_interop_metrics.delete_base_tile_metrics
+
+# Register base_tile_metrics in _py_interop_metrics:
+_py_interop_metrics.base_tile_metrics_swigregister(base_tile_metrics)
+
+def base_tile_metrics_prefix():
+    return _py_interop_metrics.base_tile_metrics_prefix()
+
+def base_tile_metrics_suffix():
+    return _py_interop_metrics.base_tile_metrics_suffix()
+
+class vector_tile_metrics(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _py_interop_metrics.vector_tile_metrics___nonzero__(self)
+
+    def __bool__(self):
+        return _py_interop_metrics.vector_tile_metrics___bool__(self)
+
+    def __len__(self):
+        return _py_interop_metrics.vector_tile_metrics___len__(self)
+
+    def __getslice__(self, i, j):
+        return _py_interop_metrics.vector_tile_metrics___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _py_interop_metrics.vector_tile_metrics___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _py_interop_metrics.vector_tile_metrics___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _py_interop_metrics.vector_tile_metrics___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _py_interop_metrics.vector_tile_metrics___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _py_interop_metrics.vector_tile_metrics___setitem__(self, *args)
+
+    def pop(self):
+        return _py_interop_metrics.vector_tile_metrics_pop(self)
+
+    def append(self, x):
+        return _py_interop_metrics.vector_tile_metrics_append(self, x)
+
+    def empty(self):
+        return _py_interop_metrics.vector_tile_metrics_empty(self)
+
+    def size(self):
+        return _py_interop_metrics.vector_tile_metrics_size(self)
+
+    def swap(self, v):
+        return _py_interop_metrics.vector_tile_metrics_swap(self, v)
+
+    def rbegin(self):
+        return _py_interop_metrics.vector_tile_metrics_rbegin(self)
+
+    def rend(self):
+        return _py_interop_metrics.vector_tile_metrics_rend(self)
+
+    def clear(self):
+        return _py_interop_metrics.vector_tile_metrics_clear(self)
+
+    def get_allocator(self):
+        return _py_interop_metrics.vector_tile_metrics_get_allocator(self)
+
+    def pop_back(self):
+        return _py_interop_metrics.vector_tile_metrics_pop_back(self)
+
+    def erase(self, *args):
+        return _py_interop_metrics.vector_tile_metrics_erase(self, *args)
+
+    def __init__(self, *args):
+        _py_interop_metrics.vector_tile_metrics_swiginit(self, _py_interop_metrics.new_vector_tile_metrics(*args))
+
+    def push_back(self, x):
+        return _py_interop_metrics.vector_tile_metrics_push_back(self, x)
+
+    def front(self):
+        return _py_interop_metrics.vector_tile_metrics_front(self)
+
+    def back(self):
+        return _py_interop_metrics.vector_tile_metrics_back(self)
+
+    def assign(self, n, x):
+        return _py_interop_metrics.vector_tile_metrics_assign(self, n, x)
+
+    def resize(self, *args):
+        return _py_interop_metrics.vector_tile_metrics_resize(self, *args)
+
+    def insert(self, *args):
+        return _py_interop_metrics.vector_tile_metrics_insert(self, *args)
+
+    def reserve(self, n):
+        return _py_interop_metrics.vector_tile_metrics_reserve(self, n)
+
+    def capacity(self):
+        return _py_interop_metrics.vector_tile_metrics_capacity(self)
+    __swig_destroy__ = _py_interop_metrics.delete_vector_tile_metrics
+
+# Register vector_tile_metrics in _py_interop_metrics:
+_py_interop_metrics.vector_tile_metrics_swigregister(vector_tile_metrics)
+
+class base_index_metrics(index_metric_header):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    TYPE = _py_interop_metrics.base_index_metrics_TYPE
+    LATEST_VERSION = _py_interop_metrics.base_index_metrics_LATEST_VERSION
+
+    def __init__(self, *args):
+        _py_interop_metrics.base_index_metrics_swiginit(self, _py_interop_metrics.new_base_index_metrics(*args))
+
+    def copy_by_tile(self, origin, tile_id):
+        return _py_interop_metrics.base_index_metrics_copy_by_tile(self, origin, tile_id)
+
+    def append_tiles(self, origin, tile_id):
+        return _py_interop_metrics.base_index_metrics_append_tiles(self, origin, tile_id)
+
+    def data_source_exists(self, *args):
+        return _py_interop_metrics.base_index_metrics_data_source_exists(self, *args)
+
+    def sort(self):
+        return _py_interop_metrics.base_index_metrics_sort(self)
+
+    def rebuild_index(self, update_ids=False):
+        return _py_interop_metrics.base_index_metrics_rebuild_index(self, update_ids)
+
+    def resize(self, n):
+        return _py_interop_metrics.base_index_metrics_resize(self, n)
+
+    def reserve(self, n):
+        return _py_interop_metrics.base_index_metrics_reserve(self, n)
+
+    def trim(self, n):
+        return _py_interop_metrics.base_index_metrics_trim(self, n)
+
+    def insert(self, *args):
+        return _py_interop_metrics.base_index_metrics_insert(self, *args)
+
+    def at(self, n):
+        return _py_interop_metrics.base_index_metrics_at(self, n)
+
+    def set_version(self, version):
+        return _py_interop_metrics.base_index_metrics_set_version(self, version)
+
+    def keys(self):
+        return _py_interop_metrics.base_index_metrics_keys(self)
+
+    def lanes(self):
+        return _py_interop_metrics.base_index_metrics_lanes(self)
+
+    def lane_count(self):
+        return _py_interop_metrics.base_index_metrics_lane_count(self)
+
+    def max_lane(self):
+        return _py_interop_metrics.base_index_metrics_max_lane(self)
+
+    def tile_numbers_for_lane(self, lane):
+        return _py_interop_metrics.base_index_metrics_tile_numbers_for_lane(self, lane)
+
+    def tile_numbers(self):
+        return _py_interop_metrics.base_index_metrics_tile_numbers(self)
+
+    def metrics_for_lane(self, *args):
+        return _py_interop_metrics.base_index_metrics_metrics_for_lane(self, *args)
+
+    def cycles(self):
+        return _py_interop_metrics.base_index_metrics_cycles(self)
+
+    def metrics_for_cycle(self, cycle):
+        return _py_interop_metrics.base_index_metrics_metrics_for_cycle(self, cycle)
+
+    def size(self):
+        return _py_interop_metrics.base_index_metrics_size(self)
+
+    def empty(self):
+        return _py_interop_metrics.base_index_metrics_empty(self)
+
+    def version(self):
+        return _py_interop_metrics.base_index_metrics_version(self)
+
+    def clear(self):
+        return _py_interop_metrics.base_index_metrics_clear(self)
+
+    def metrics(self):
+        return _py_interop_metrics.base_index_metrics_metrics(self)
+
+    @staticmethod
+    def prefix():
+        return _py_interop_metrics.base_index_metrics_prefix()
+
+    @staticmethod
+    def suffix():
+        return _py_interop_metrics.base_index_metrics_suffix()
+
+    def get_metric_ref(self, *args):
+        return _py_interop_metrics.base_index_metrics_get_metric_ref(self, *args)
+
+    def find(self, *args):
+        return _py_interop_metrics.base_index_metrics_find(self, *args)
+
+    def get_metric(self, *args):
+        return _py_interop_metrics.base_index_metrics_get_metric(self, *args)
+
+    def has_metric(self, *args):
+        return _py_interop_metrics.base_index_metrics_has_metric(self, *args)
+
+    def clear_lookup(self):
+        return _py_interop_metrics.base_index_metrics_clear_lookup(self)
+    __swig_destroy__ = _py_interop_metrics.delete_base_index_metrics
+
+# Register base_index_metrics in _py_interop_metrics:
+_py_interop_metrics.base_index_metrics_swigregister(base_index_metrics)
+
+def base_index_metrics_prefix():
+    return _py_interop_metrics.base_index_metrics_prefix()
+
+def base_index_metrics_suffix():
+    return _py_interop_metrics.base_index_metrics_suffix()
+
+class vector_index_metrics(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _py_interop_metrics.vector_index_metrics___nonzero__(self)
+
+    def __bool__(self):
+        return _py_interop_metrics.vector_index_metrics___bool__(self)
+
+    def __len__(self):
+        return _py_interop_metrics.vector_index_metrics___len__(self)
+
+    def __getslice__(self, i, j):
+        return _py_interop_metrics.vector_index_metrics___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _py_interop_metrics.vector_index_metrics___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _py_interop_metrics.vector_index_metrics___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _py_interop_metrics.vector_index_metrics___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _py_interop_metrics.vector_index_metrics___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _py_interop_metrics.vector_index_metrics___setitem__(self, *args)
+
+    def pop(self):
+        return _py_interop_metrics.vector_index_metrics_pop(self)
+
+    def append(self, x):
+        return _py_interop_metrics.vector_index_metrics_append(self, x)
+
+    def empty(self):
+        return _py_interop_metrics.vector_index_metrics_empty(self)
+
+    def size(self):
+        return _py_interop_metrics.vector_index_metrics_size(self)
+
+    def swap(self, v):
+        return _py_interop_metrics.vector_index_metrics_swap(self, v)
+
+    def rbegin(self):
+        return _py_interop_metrics.vector_index_metrics_rbegin(self)
+
+    def rend(self):
+        return _py_interop_metrics.vector_index_metrics_rend(self)
+
+    def clear(self):
+        return _py_interop_metrics.vector_index_metrics_clear(self)
+
+    def get_allocator(self):
+        return _py_interop_metrics.vector_index_metrics_get_allocator(self)
+
+    def pop_back(self):
+        return _py_interop_metrics.vector_index_metrics_pop_back(self)
+
+    def erase(self, *args):
+        return _py_interop_metrics.vector_index_metrics_erase(self, *args)
+
+    def __init__(self, *args):
+        _py_interop_metrics.vector_index_metrics_swiginit(self, _py_interop_metrics.new_vector_index_metrics(*args))
+
+    def push_back(self, x):
+        return _py_interop_metrics.vector_index_metrics_push_back(self, x)
+
+    def front(self):
+        return _py_interop_metrics.vector_index_metrics_front(self)
+
+    def back(self):
+        return _py_interop_metrics.vector_index_metrics_back(self)
+
+    def assign(self, n, x):
+        return _py_interop_metrics.vector_index_metrics_assign(self, n, x)
+
+    def resize(self, *args):
+        return _py_interop_metrics.vector_index_metrics_resize(self, *args)
+
+    def insert(self, *args):
+        return _py_interop_metrics.vector_index_metrics_insert(self, *args)
+
+    def reserve(self, n):
+        return _py_interop_metrics.vector_index_metrics_reserve(self, n)
+
+    def capacity(self):
+        return _py_interop_metrics.vector_index_metrics_capacity(self)
+    __swig_destroy__ = _py_interop_metrics.delete_vector_index_metrics
+
+# Register vector_index_metrics in _py_interop_metrics:
+_py_interop_metrics.vector_index_metrics_swigregister(vector_index_metrics)
+
+class base_q_collapsed_metrics(q_collapsed_header):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    TYPE = _py_interop_metrics.base_q_collapsed_metrics_TYPE
+    LATEST_VERSION = _py_interop_metrics.base_q_collapsed_metrics_LATEST_VERSION
+
+    def __init__(self, *args):
+        _py_interop_metrics.base_q_collapsed_metrics_swiginit(self, _py_interop_metrics.new_base_q_collapsed_metrics(*args))
+
+    def copy_by_tile(self, origin, tile_id):
+        return _py_interop_metrics.base_q_collapsed_metrics_copy_by_tile(self, origin, tile_id)
+
+    def append_tiles(self, origin, tile_id):
+        return _py_interop_metrics.base_q_collapsed_metrics_append_tiles(self, origin, tile_id)
+
+    def data_source_exists(self, *args):
+        return _py_interop_metrics.base_q_collapsed_metrics_data_source_exists(self, *args)
+
+    def sort(self):
+        return _py_interop_metrics.base_q_collapsed_metrics_sort(self)
+
+    def rebuild_index(self, update_ids=False):
+        return _py_interop_metrics.base_q_collapsed_metrics_rebuild_index(self, update_ids)
+
+    def resize(self, n):
+        return _py_interop_metrics.base_q_collapsed_metrics_resize(self, n)
+
+    def reserve(self, n):
+        return _py_interop_metrics.base_q_collapsed_metrics_reserve(self, n)
+
+    def trim(self, n):
+        return _py_interop_metrics.base_q_collapsed_metrics_trim(self, n)
+
+    def insert(self, *args):
+        return _py_interop_metrics.base_q_collapsed_metrics_insert(self, *args)
+
+    def at(self, n):
+        return _py_interop_metrics.base_q_collapsed_metrics_at(self, n)
+
+    def set_version(self, version):
+        return _py_interop_metrics.base_q_collapsed_metrics_set_version(self, version)
+
+    def keys(self):
+        return _py_interop_metrics.base_q_collapsed_metrics_keys(self)
+
+    def lanes(self):
+        return _py_interop_metrics.base_q_collapsed_metrics_lanes(self)
+
+    def lane_count(self):
+        return _py_interop_metrics.base_q_collapsed_metrics_lane_count(self)
+
+    def max_lane(self):
+        return _py_interop_metrics.base_q_collapsed_metrics_max_lane(self)
+
+    def tile_numbers_for_lane(self, lane):
+        return _py_interop_metrics.base_q_collapsed_metrics_tile_numbers_for_lane(self, lane)
+
+    def tile_numbers(self):
+        return _py_interop_metrics.base_q_collapsed_metrics_tile_numbers(self)
+
+    def metrics_for_lane(self, *args):
+        return _py_interop_metrics.base_q_collapsed_metrics_metrics_for_lane(self, *args)
+
+    def cycles(self):
+        return _py_interop_metrics.base_q_collapsed_metrics_cycles(self)
+
+    def metrics_for_cycle(self, cycle):
+        return _py_interop_metrics.base_q_collapsed_metrics_metrics_for_cycle(self, cycle)
+
+    def size(self):
+        return _py_interop_metrics.base_q_collapsed_metrics_size(self)
+
+    def empty(self):
+        return _py_interop_metrics.base_q_collapsed_metrics_empty(self)
+
+    def version(self):
+        return _py_interop_metrics.base_q_collapsed_metrics_version(self)
+
+    def clear(self):
+        return _py_interop_metrics.base_q_collapsed_metrics_clear(self)
+
+    def metrics(self):
+        return _py_interop_metrics.base_q_collapsed_metrics_metrics(self)
+
+    @staticmethod
+    def prefix():
+        return _py_interop_metrics.base_q_collapsed_metrics_prefix()
+
+    @staticmethod
+    def suffix():
+        return _py_interop_metrics.base_q_collapsed_metrics_suffix()
+
+    def get_metric_ref(self, *args):
+        return _py_interop_metrics.base_q_collapsed_metrics_get_metric_ref(self, *args)
+
+    def find(self, *args):
+        return _py_interop_metrics.base_q_collapsed_metrics_find(self, *args)
+
+    def get_metric(self, *args):
+        return _py_interop_metrics.base_q_collapsed_metrics_get_metric(self, *args)
+
+    def has_metric(self, *args):
+        return _py_interop_metrics.base_q_collapsed_metrics_has_metric(self, *args)
+
+    def clear_lookup(self):
+        return _py_interop_metrics.base_q_collapsed_metrics_clear_lookup(self)
+    __swig_destroy__ = _py_interop_metrics.delete_base_q_collapsed_metrics
+
+# Register base_q_collapsed_metrics in _py_interop_metrics:
+_py_interop_metrics.base_q_collapsed_metrics_swigregister(base_q_collapsed_metrics)
+
+def base_q_collapsed_metrics_prefix():
+    return _py_interop_metrics.base_q_collapsed_metrics_prefix()
+
+def base_q_collapsed_metrics_suffix():
+    return _py_interop_metrics.base_q_collapsed_metrics_suffix()
+
+class vector_q_collapsed_metrics(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _py_interop_metrics.vector_q_collapsed_metrics___nonzero__(self)
+
+    def __bool__(self):
+        return _py_interop_metrics.vector_q_collapsed_metrics___bool__(self)
+
+    def __len__(self):
+        return _py_interop_metrics.vector_q_collapsed_metrics___len__(self)
+
+    def __getslice__(self, i, j):
+        return _py_interop_metrics.vector_q_collapsed_metrics___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _py_interop_metrics.vector_q_collapsed_metrics___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _py_interop_metrics.vector_q_collapsed_metrics___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _py_interop_metrics.vector_q_collapsed_metrics___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _py_interop_metrics.vector_q_collapsed_metrics___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _py_interop_metrics.vector_q_collapsed_metrics___setitem__(self, *args)
+
+    def pop(self):
+        return _py_interop_metrics.vector_q_collapsed_metrics_pop(self)
+
+    def append(self, x):
+        return _py_interop_metrics.vector_q_collapsed_metrics_append(self, x)
+
+    def empty(self):
+        return _py_interop_metrics.vector_q_collapsed_metrics_empty(self)
+
+    def size(self):
+        return _py_interop_metrics.vector_q_collapsed_metrics_size(self)
+
+    def swap(self, v):
+        return _py_interop_metrics.vector_q_collapsed_metrics_swap(self, v)
+
+    def rbegin(self):
+        return _py_interop_metrics.vector_q_collapsed_metrics_rbegin(self)
+
+    def rend(self):
+        return _py_interop_metrics.vector_q_collapsed_metrics_rend(self)
+
+    def clear(self):
+        return _py_interop_metrics.vector_q_collapsed_metrics_clear(self)
+
+    def get_allocator(self):
+        return _py_interop_metrics.vector_q_collapsed_metrics_get_allocator(self)
+
+    def pop_back(self):
+        return _py_interop_metrics.vector_q_collapsed_metrics_pop_back(self)
+
+    def erase(self, *args):
+        return _py_interop_metrics.vector_q_collapsed_metrics_erase(self, *args)
+
+    def __init__(self, *args):
+        _py_interop_metrics.vector_q_collapsed_metrics_swiginit(self, _py_interop_metrics.new_vector_q_collapsed_metrics(*args))
+
+    def push_back(self, x):
+        return _py_interop_metrics.vector_q_collapsed_metrics_push_back(self, x)
+
+    def front(self):
+        return _py_interop_metrics.vector_q_collapsed_metrics_front(self)
+
+    def back(self):
+        return _py_interop_metrics.vector_q_collapsed_metrics_back(self)
+
+    def assign(self, n, x):
+        return _py_interop_metrics.vector_q_collapsed_metrics_assign(self, n, x)
+
+    def resize(self, *args):
+        return _py_interop_metrics.vector_q_collapsed_metrics_resize(self, *args)
+
+    def insert(self, *args):
+        return _py_interop_metrics.vector_q_collapsed_metrics_insert(self, *args)
+
+    def reserve(self, n):
+        return _py_interop_metrics.vector_q_collapsed_metrics_reserve(self, n)
+
+    def capacity(self):
+        return _py_interop_metrics.vector_q_collapsed_metrics_capacity(self)
+    __swig_destroy__ = _py_interop_metrics.delete_vector_q_collapsed_metrics
+
+# Register vector_q_collapsed_metrics in _py_interop_metrics:
+_py_interop_metrics.vector_q_collapsed_metrics_swigregister(vector_q_collapsed_metrics)
+
+class base_q_by_lane_metrics(q_score_header):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    TYPE = _py_interop_metrics.base_q_by_lane_metrics_TYPE
+    LATEST_VERSION = _py_interop_metrics.base_q_by_lane_metrics_LATEST_VERSION
+
+    def __init__(self, *args):
+        _py_interop_metrics.base_q_by_lane_metrics_swiginit(self, _py_interop_metrics.new_base_q_by_lane_metrics(*args))
+
+    def copy_by_tile(self, origin, tile_id):
+        return _py_interop_metrics.base_q_by_lane_metrics_copy_by_tile(self, origin, tile_id)
+
+    def append_tiles(self, origin, tile_id):
+        return _py_interop_metrics.base_q_by_lane_metrics_append_tiles(self, origin, tile_id)
+
+    def data_source_exists(self, *args):
+        return _py_interop_metrics.base_q_by_lane_metrics_data_source_exists(self, *args)
+
+    def sort(self):
+        return _py_interop_metrics.base_q_by_lane_metrics_sort(self)
+
+    def rebuild_index(self, update_ids=False):
+        return _py_interop_metrics.base_q_by_lane_metrics_rebuild_index(self, update_ids)
+
+    def resize(self, n):
+        return _py_interop_metrics.base_q_by_lane_metrics_resize(self, n)
+
+    def reserve(self, n):
+        return _py_interop_metrics.base_q_by_lane_metrics_reserve(self, n)
+
+    def trim(self, n):
+        return _py_interop_metrics.base_q_by_lane_metrics_trim(self, n)
+
+    def insert(self, *args):
+        return _py_interop_metrics.base_q_by_lane_metrics_insert(self, *args)
+
+    def at(self, n):
+        return _py_interop_metrics.base_q_by_lane_metrics_at(self, n)
+
+    def set_version(self, version):
+        return _py_interop_metrics.base_q_by_lane_metrics_set_version(self, version)
+
+    def keys(self):
+        return _py_interop_metrics.base_q_by_lane_metrics_keys(self)
+
+    def lanes(self):
+        return _py_interop_metrics.base_q_by_lane_metrics_lanes(self)
+
+    def lane_count(self):
+        return _py_interop_metrics.base_q_by_lane_metrics_lane_count(self)
+
+    def max_lane(self):
+        return _py_interop_metrics.base_q_by_lane_metrics_max_lane(self)
+
+    def tile_numbers_for_lane(self, lane):
+        return _py_interop_metrics.base_q_by_lane_metrics_tile_numbers_for_lane(self, lane)
+
+    def tile_numbers(self):
+        return _py_interop_metrics.base_q_by_lane_metrics_tile_numbers(self)
+
+    def metrics_for_lane(self, *args):
+        return _py_interop_metrics.base_q_by_lane_metrics_metrics_for_lane(self, *args)
+
+    def cycles(self):
+        return _py_interop_metrics.base_q_by_lane_metrics_cycles(self)
+
+    def metrics_for_cycle(self, cycle):
+        return _py_interop_metrics.base_q_by_lane_metrics_metrics_for_cycle(self, cycle)
+
+    def size(self):
+        return _py_interop_metrics.base_q_by_lane_metrics_size(self)
+
+    def empty(self):
+        return _py_interop_metrics.base_q_by_lane_metrics_empty(self)
+
+    def version(self):
+        return _py_interop_metrics.base_q_by_lane_metrics_version(self)
+
+    def clear(self):
+        return _py_interop_metrics.base_q_by_lane_metrics_clear(self)
+
+    def metrics(self):
+        return _py_interop_metrics.base_q_by_lane_metrics_metrics(self)
+
+    @staticmethod
+    def prefix():
+        return _py_interop_metrics.base_q_by_lane_metrics_prefix()
+
+    @staticmethod
+    def suffix():
+        return _py_interop_metrics.base_q_by_lane_metrics_suffix()
+
+    def get_metric_ref(self, *args):
+        return _py_interop_metrics.base_q_by_lane_metrics_get_metric_ref(self, *args)
+
+    def find(self, *args):
+        return _py_interop_metrics.base_q_by_lane_metrics_find(self, *args)
+
+    def get_metric(self, *args):
+        return _py_interop_metrics.base_q_by_lane_metrics_get_metric(self, *args)
+
+    def has_metric(self, *args):
+        return _py_interop_metrics.base_q_by_lane_metrics_has_metric(self, *args)
+
+    def clear_lookup(self):
+        return _py_interop_metrics.base_q_by_lane_metrics_clear_lookup(self)
+    __swig_destroy__ = _py_interop_metrics.delete_base_q_by_lane_metrics
+
+# Register base_q_by_lane_metrics in _py_interop_metrics:
+_py_interop_metrics.base_q_by_lane_metrics_swigregister(base_q_by_lane_metrics)
+
+def base_q_by_lane_metrics_prefix():
+    return _py_interop_metrics.base_q_by_lane_metrics_prefix()
+
+def base_q_by_lane_metrics_suffix():
+    return _py_interop_metrics.base_q_by_lane_metrics_suffix()
+
+class vector_q_by_lane_metrics(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _py_interop_metrics.vector_q_by_lane_metrics___nonzero__(self)
+
+    def __bool__(self):
+        return _py_interop_metrics.vector_q_by_lane_metrics___bool__(self)
+
+    def __len__(self):
+        return _py_interop_metrics.vector_q_by_lane_metrics___len__(self)
+
+    def __getslice__(self, i, j):
+        return _py_interop_metrics.vector_q_by_lane_metrics___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _py_interop_metrics.vector_q_by_lane_metrics___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _py_interop_metrics.vector_q_by_lane_metrics___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _py_interop_metrics.vector_q_by_lane_metrics___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _py_interop_metrics.vector_q_by_lane_metrics___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _py_interop_metrics.vector_q_by_lane_metrics___setitem__(self, *args)
+
+    def pop(self):
+        return _py_interop_metrics.vector_q_by_lane_metrics_pop(self)
+
+    def append(self, x):
+        return _py_interop_metrics.vector_q_by_lane_metrics_append(self, x)
+
+    def empty(self):
+        return _py_interop_metrics.vector_q_by_lane_metrics_empty(self)
+
+    def size(self):
+        return _py_interop_metrics.vector_q_by_lane_metrics_size(self)
+
+    def swap(self, v):
+        return _py_interop_metrics.vector_q_by_lane_metrics_swap(self, v)
+
+    def rbegin(self):
+        return _py_interop_metrics.vector_q_by_lane_metrics_rbegin(self)
+
+    def rend(self):
+        return _py_interop_metrics.vector_q_by_lane_metrics_rend(self)
+
+    def clear(self):
+        return _py_interop_metrics.vector_q_by_lane_metrics_clear(self)
+
+    def get_allocator(self):
+        return _py_interop_metrics.vector_q_by_lane_metrics_get_allocator(self)
+
+    def pop_back(self):
+        return _py_interop_metrics.vector_q_by_lane_metrics_pop_back(self)
+
+    def erase(self, *args):
+        return _py_interop_metrics.vector_q_by_lane_metrics_erase(self, *args)
+
+    def __init__(self, *args):
+        _py_interop_metrics.vector_q_by_lane_metrics_swiginit(self, _py_interop_metrics.new_vector_q_by_lane_metrics(*args))
+
+    def push_back(self, x):
+        return _py_interop_metrics.vector_q_by_lane_metrics_push_back(self, x)
+
+    def front(self):
+        return _py_interop_metrics.vector_q_by_lane_metrics_front(self)
+
+    def back(self):
+        return _py_interop_metrics.vector_q_by_lane_metrics_back(self)
+
+    def assign(self, n, x):
+        return _py_interop_metrics.vector_q_by_lane_metrics_assign(self, n, x)
+
+    def resize(self, *args):
+        return _py_interop_metrics.vector_q_by_lane_metrics_resize(self, *args)
+
+    def insert(self, *args):
+        return _py_interop_metrics.vector_q_by_lane_metrics_insert(self, *args)
+
+    def reserve(self, n):
+        return _py_interop_metrics.vector_q_by_lane_metrics_reserve(self, n)
+
+    def capacity(self):
+        return _py_interop_metrics.vector_q_by_lane_metrics_capacity(self)
+    __swig_destroy__ = _py_interop_metrics.delete_vector_q_by_lane_metrics
+
+# Register vector_q_by_lane_metrics in _py_interop_metrics:
+_py_interop_metrics.vector_q_by_lane_metrics_swigregister(vector_q_by_lane_metrics)
+
+class base_summary_run_metrics(base_metric_header):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    TYPE = _py_interop_metrics.base_summary_run_metrics_TYPE
+    LATEST_VERSION = _py_interop_metrics.base_summary_run_metrics_LATEST_VERSION
+
+    def __init__(self, *args):
+        _py_interop_metrics.base_summary_run_metrics_swiginit(self, _py_interop_metrics.new_base_summary_run_metrics(*args))
+
+    def copy_by_tile(self, origin, tile_id):
+        return _py_interop_metrics.base_summary_run_metrics_copy_by_tile(self, origin, tile_id)
+
+    def append_tiles(self, origin, tile_id):
+        return _py_interop_metrics.base_summary_run_metrics_append_tiles(self, origin, tile_id)
+
+    def data_source_exists(self, *args):
+        return _py_interop_metrics.base_summary_run_metrics_data_source_exists(self, *args)
+
+    def sort(self):
+        return _py_interop_metrics.base_summary_run_metrics_sort(self)
+
+    def rebuild_index(self, update_ids=False):
+        return _py_interop_metrics.base_summary_run_metrics_rebuild_index(self, update_ids)
+
+    def resize(self, n):
+        return _py_interop_metrics.base_summary_run_metrics_resize(self, n)
+
+    def reserve(self, n):
+        return _py_interop_metrics.base_summary_run_metrics_reserve(self, n)
+
+    def trim(self, n):
+        return _py_interop_metrics.base_summary_run_metrics_trim(self, n)
+
+    def insert(self, *args):
+        return _py_interop_metrics.base_summary_run_metrics_insert(self, *args)
+
+    def at(self, n):
+        return _py_interop_metrics.base_summary_run_metrics_at(self, n)
+
+    def set_version(self, version):
+        return _py_interop_metrics.base_summary_run_metrics_set_version(self, version)
+
+    def keys(self):
+        return _py_interop_metrics.base_summary_run_metrics_keys(self)
+
+    def lanes(self):
+        return _py_interop_metrics.base_summary_run_metrics_lanes(self)
+
+    def lane_count(self):
+        return _py_interop_metrics.base_summary_run_metrics_lane_count(self)
+
+    def max_lane(self):
+        return _py_interop_metrics.base_summary_run_metrics_max_lane(self)
+
+    def tile_numbers_for_lane(self, lane):
+        return _py_interop_metrics.base_summary_run_metrics_tile_numbers_for_lane(self, lane)
+
+    def tile_numbers(self):
+        return _py_interop_metrics.base_summary_run_metrics_tile_numbers(self)
+
+    def metrics_for_lane(self, *args):
+        return _py_interop_metrics.base_summary_run_metrics_metrics_for_lane(self, *args)
+
+    def cycles(self):
+        return _py_interop_metrics.base_summary_run_metrics_cycles(self)
+
+    def metrics_for_cycle(self, cycle):
+        return _py_interop_metrics.base_summary_run_metrics_metrics_for_cycle(self, cycle)
+
+    def size(self):
+        return _py_interop_metrics.base_summary_run_metrics_size(self)
+
+    def empty(self):
+        return _py_interop_metrics.base_summary_run_metrics_empty(self)
+
+    def version(self):
+        return _py_interop_metrics.base_summary_run_metrics_version(self)
+
+    def clear(self):
+        return _py_interop_metrics.base_summary_run_metrics_clear(self)
+
+    def metrics(self):
+        return _py_interop_metrics.base_summary_run_metrics_metrics(self)
+
+    @staticmethod
+    def prefix():
+        return _py_interop_metrics.base_summary_run_metrics_prefix()
+
+    @staticmethod
+    def suffix():
+        return _py_interop_metrics.base_summary_run_metrics_suffix()
+
+    def get_metric_ref(self, *args):
+        return _py_interop_metrics.base_summary_run_metrics_get_metric_ref(self, *args)
+
+    def find(self, *args):
+        return _py_interop_metrics.base_summary_run_metrics_find(self, *args)
+
+    def get_metric(self, *args):
+        return _py_interop_metrics.base_summary_run_metrics_get_metric(self, *args)
+
+    def has_metric(self, *args):
+        return _py_interop_metrics.base_summary_run_metrics_has_metric(self, *args)
+
+    def clear_lookup(self):
+        return _py_interop_metrics.base_summary_run_metrics_clear_lookup(self)
+    __swig_destroy__ = _py_interop_metrics.delete_base_summary_run_metrics
+
+# Register base_summary_run_metrics in _py_interop_metrics:
+_py_interop_metrics.base_summary_run_metrics_swigregister(base_summary_run_metrics)
+
+def base_summary_run_metrics_prefix():
+    return _py_interop_metrics.base_summary_run_metrics_prefix()
+
+def base_summary_run_metrics_suffix():
+    return _py_interop_metrics.base_summary_run_metrics_suffix()
+
+class vector_summary_run_metrics(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _py_interop_metrics.vector_summary_run_metrics___nonzero__(self)
+
+    def __bool__(self):
+        return _py_interop_metrics.vector_summary_run_metrics___bool__(self)
+
+    def __len__(self):
+        return _py_interop_metrics.vector_summary_run_metrics___len__(self)
+
+    def __getslice__(self, i, j):
+        return _py_interop_metrics.vector_summary_run_metrics___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _py_interop_metrics.vector_summary_run_metrics___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _py_interop_metrics.vector_summary_run_metrics___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _py_interop_metrics.vector_summary_run_metrics___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _py_interop_metrics.vector_summary_run_metrics___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _py_interop_metrics.vector_summary_run_metrics___setitem__(self, *args)
+
+    def pop(self):
+        return _py_interop_metrics.vector_summary_run_metrics_pop(self)
+
+    def append(self, x):
+        return _py_interop_metrics.vector_summary_run_metrics_append(self, x)
+
+    def empty(self):
+        return _py_interop_metrics.vector_summary_run_metrics_empty(self)
+
+    def size(self):
+        return _py_interop_metrics.vector_summary_run_metrics_size(self)
+
+    def swap(self, v):
+        return _py_interop_metrics.vector_summary_run_metrics_swap(self, v)
+
+    def rbegin(self):
+        return _py_interop_metrics.vector_summary_run_metrics_rbegin(self)
+
+    def rend(self):
+        return _py_interop_metrics.vector_summary_run_metrics_rend(self)
+
+    def clear(self):
+        return _py_interop_metrics.vector_summary_run_metrics_clear(self)
+
+    def get_allocator(self):
+        return _py_interop_metrics.vector_summary_run_metrics_get_allocator(self)
+
+    def pop_back(self):
+        return _py_interop_metrics.vector_summary_run_metrics_pop_back(self)
+
+    def erase(self, *args):
+        return _py_interop_metrics.vector_summary_run_metrics_erase(self, *args)
+
+    def __init__(self, *args):
+        _py_interop_metrics.vector_summary_run_metrics_swiginit(self, _py_interop_metrics.new_vector_summary_run_metrics(*args))
+
+    def push_back(self, x):
+        return _py_interop_metrics.vector_summary_run_metrics_push_back(self, x)
+
+    def front(self):
+        return _py_interop_metrics.vector_summary_run_metrics_front(self)
+
+    def back(self):
+        return _py_interop_metrics.vector_summary_run_metrics_back(self)
+
+    def assign(self, n, x):
+        return _py_interop_metrics.vector_summary_run_metrics_assign(self, n, x)
+
+    def resize(self, *args):
+        return _py_interop_metrics.vector_summary_run_metrics_resize(self, *args)
+
+    def insert(self, *args):
+        return _py_interop_metrics.vector_summary_run_metrics_insert(self, *args)
+
+    def reserve(self, n):
+        return _py_interop_metrics.vector_summary_run_metrics_reserve(self, n)
+
+    def capacity(self):
+        return _py_interop_metrics.vector_summary_run_metrics_capacity(self)
+    __swig_destroy__ = _py_interop_metrics.delete_vector_summary_run_metrics
+
+# Register vector_summary_run_metrics in _py_interop_metrics:
+_py_interop_metrics.vector_summary_run_metrics_swigregister(vector_summary_run_metrics)
+
+
+
```

## interop/py_interop_plot.py

```diff
@@ -1,1029 +1,1052 @@
-# This file was automatically generated by SWIG (https://www.swig.org).
-# Version 4.1.1
-#
-# Do not make changes to this file unless you know what you are doing - modify
-# the SWIG interface file instead.
-
-from sys import version_info as _swig_python_version_info
-# Import the low-level C/C++ module
-if __package__ or "." in __name__:
-    from . import _py_interop_plot
-else:
-    import _py_interop_plot
-
-try:
-    import builtins as __builtin__
-except ImportError:
-    import __builtin__
-
-def _swig_repr(self):
-    try:
-        strthis = "proxy of " + self.this.__repr__()
-    except __builtin__.Exception:
-        strthis = ""
-    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)
-
-
-def _swig_setattr_nondynamic_instance_variable(set):
-    def set_instance_attr(self, name, value):
-        if name == "this":
-            set(self, name, value)
-        elif name == "thisown":
-            self.this.own(value)
-        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
-            set(self, name, value)
-        else:
-            raise AttributeError("You cannot add instance attributes to %s" % self)
-    return set_instance_attr
-
-
-def _swig_setattr_nondynamic_class_variable(set):
-    def set_class_attr(cls, name, value):
-        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
-            set(cls, name, value)
-        else:
-            raise AttributeError("You cannot add class attributes to %s" % cls)
-    return set_class_attr
-
-
-def _swig_add_metaclass(metaclass):
-    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
-    def wrapper(cls):
-        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
-    return wrapper
-
-
-class _SwigNonDynamicMeta(type):
-    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
-    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)
-
-
-class SwigPyIterator(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined - class is abstract")
-    __repr__ = _swig_repr
-    __swig_destroy__ = _py_interop_plot.delete_SwigPyIterator
-
-    def value(self):
-        return _py_interop_plot.SwigPyIterator_value(self)
-
-    def incr(self, n=1):
-        return _py_interop_plot.SwigPyIterator_incr(self, n)
-
-    def decr(self, n=1):
-        return _py_interop_plot.SwigPyIterator_decr(self, n)
-
-    def distance(self, x):
-        return _py_interop_plot.SwigPyIterator_distance(self, x)
-
-    def equal(self, x):
-        return _py_interop_plot.SwigPyIterator_equal(self, x)
-
-    def copy(self):
-        return _py_interop_plot.SwigPyIterator_copy(self)
-
-    def next(self):
-        return _py_interop_plot.SwigPyIterator_next(self)
-
-    def __next__(self):
-        return _py_interop_plot.SwigPyIterator___next__(self)
-
-    def previous(self):
-        return _py_interop_plot.SwigPyIterator_previous(self)
-
-    def advance(self, n):
-        return _py_interop_plot.SwigPyIterator_advance(self, n)
-
-    def __eq__(self, x):
-        return _py_interop_plot.SwigPyIterator___eq__(self, x)
-
-    def __ne__(self, x):
-        return _py_interop_plot.SwigPyIterator___ne__(self, x)
-
-    def __iadd__(self, n):
-        return _py_interop_plot.SwigPyIterator___iadd__(self, n)
-
-    def __isub__(self, n):
-        return _py_interop_plot.SwigPyIterator___isub__(self, n)
-
-    def __add__(self, n):
-        return _py_interop_plot.SwigPyIterator___add__(self, n)
-
-    def __sub__(self, *args):
-        return _py_interop_plot.SwigPyIterator___sub__(self, *args)
-    def __iter__(self):
-        return self
-
-# Register SwigPyIterator in _py_interop_plot:
-_py_interop_plot.SwigPyIterator_swigregister(SwigPyIterator)
-import interop.py_interop_run
-import interop.py_interop_metrics
-import interop.py_interop_run_metrics
-import interop.py_interop_comm
-class invalid_filter_option(interop.py_interop_run.base_exception):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, mesg):
-        _py_interop_plot.invalid_filter_option_swiginit(self, _py_interop_plot.new_invalid_filter_option(mesg))
-
-    def __str__(self):
-        return _py_interop_plot.invalid_filter_option___str__(self)
-    __swig_destroy__ = _py_interop_plot.delete_invalid_filter_option
-
-# Register invalid_filter_option in _py_interop_plot:
-_py_interop_plot.invalid_filter_option_swigregister(invalid_filter_option)
-class axis(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self):
-        _py_interop_plot.axis_swiginit(self, _py_interop_plot.new_axis())
-
-    def set_range(self, vmin, vmax):
-        return _py_interop_plot.axis_set_range(self, vmin, vmax)
-
-    def set_label(self, label):
-        return _py_interop_plot.axis_set_label(self, label)
-
-    def clear(self):
-        return _py_interop_plot.axis_clear(self)
-
-    def label(self):
-        return _py_interop_plot.axis_label(self)
-
-    def min(self):
-        return _py_interop_plot.axis_min(self)
-
-    def max(self):
-        return _py_interop_plot.axis_max(self)
-    __swig_destroy__ = _py_interop_plot.delete_axis
-
-# Register axis in _py_interop_plot:
-_py_interop_plot.axis_swigregister(axis)
-class axes(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def set_range(self, xmin, xmax, ymin, ymax):
-        return _py_interop_plot.axes_set_range(self, xmin, xmax, ymin, ymax)
-
-    def set_xrange(self, vmin, vmax):
-        return _py_interop_plot.axes_set_xrange(self, vmin, vmax)
-
-    def set_yrange(self, vmin, vmax):
-        return _py_interop_plot.axes_set_yrange(self, vmin, vmax)
-
-    def set_xlabel(self, label):
-        return _py_interop_plot.axes_set_xlabel(self, label)
-
-    def set_ylabel(self, label):
-        return _py_interop_plot.axes_set_ylabel(self, label)
-
-    def set_xaxis(self, xaxes):
-        return _py_interop_plot.axes_set_xaxis(self, xaxes)
-
-    def set_yaxis(self, yaxes):
-        return _py_interop_plot.axes_set_yaxis(self, yaxes)
-
-    def clear(self):
-        return _py_interop_plot.axes_clear(self)
-
-    def xlabel(self):
-        return _py_interop_plot.axes_xlabel(self)
-
-    def ylabel(self):
-        return _py_interop_plot.axes_ylabel(self)
-
-    def x(self):
-        return _py_interop_plot.axes_x(self)
-
-    def y(self):
-        return _py_interop_plot.axes_y(self)
-
-    def __init__(self):
-        _py_interop_plot.axes_swiginit(self, _py_interop_plot.new_axes())
-    __swig_destroy__ = _py_interop_plot.delete_axes
-
-# Register axes in _py_interop_plot:
-_py_interop_plot.axes_swigregister(axes)
-class filter_options(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    ALL_IDS = _py_interop_plot.filter_options_ALL_IDS
-    ALL_CHANNELS = _py_interop_plot.filter_options_ALL_CHANNELS
-    ALL_BASES = _py_interop_plot.filter_options_ALL_BASES
-
-    def __init__(self, *args):
-        _py_interop_plot.filter_options_swiginit(self, _py_interop_plot.new_filter_options(*args))
-
-    def reset(self):
-        return _py_interop_plot.filter_options_reset(self)
-
-    def validate(self, type, run_info, check_ignored=False):
-        return _py_interop_plot.filter_options_validate(self, type, run_info, check_ignored)
-
-    def all_channels(self, *args):
-        return _py_interop_plot.filter_options_all_channels(self, *args)
-
-    def all_bases(self, *args):
-        return _py_interop_plot.filter_options_all_bases(self, *args)
-
-    def all_reads(self):
-        return _py_interop_plot.filter_options_all_reads(self)
-
-    def all_cycles(self):
-        return _py_interop_plot.filter_options_all_cycles(self)
-
-    def all_lanes(self):
-        return _py_interop_plot.filter_options_all_lanes(self)
-
-    def all_tile_numbers(self):
-        return _py_interop_plot.filter_options_all_tile_numbers(self)
-
-    def all_swaths(self):
-        return _py_interop_plot.filter_options_all_swaths(self)
-
-    def all_sections(self):
-        return _py_interop_plot.filter_options_all_sections(self)
-
-    def is_specific_read(self, *args):
-        return _py_interop_plot.filter_options_is_specific_read(self, *args)
-
-    def is_specific_surface(self):
-        return _py_interop_plot.filter_options_is_specific_surface(self)
-
-    def valid_lane(self, lane):
-        return _py_interop_plot.filter_options_valid_lane(self, lane)
-
-    def valid_surface(self, surface):
-        return _py_interop_plot.filter_options_valid_surface(self, surface)
-
-    def valid_read(self, read):
-        return _py_interop_plot.filter_options_valid_read(self, read)
-
-    def valid_cycle(self, cycle):
-        return _py_interop_plot.filter_options_valid_cycle(self, cycle)
-
-    def valid_tile_number(self, tile_number):
-        return _py_interop_plot.filter_options_valid_tile_number(self, tile_number)
-
-    def valid_swath(self, swath):
-        return _py_interop_plot.filter_options_valid_swath(self, swath)
-
-    def valid_section(self, section):
-        return _py_interop_plot.filter_options_valid_section(self, section)
-
-    def valid_channel(self, channel):
-        return _py_interop_plot.filter_options_valid_channel(self, channel)
-
-    def valid_base(self, base):
-        return _py_interop_plot.filter_options_valid_base(self, base)
-
-    def tile_naming_method(self, naming_method):
-        return _py_interop_plot.filter_options_tile_naming_method(self, naming_method)
-
-    def swath(self, s):
-        return _py_interop_plot.filter_options_swath(self, s)
-
-    def section(self, s):
-        return _py_interop_plot.filter_options_section(self, s)
-
-    def tile_number(self, s):
-        return _py_interop_plot.filter_options_tile_number(self, s)
-
-    def lane(self, *args):
-        return _py_interop_plot.filter_options_lane(self, *args)
-
-    def channel(self, *args):
-        return _py_interop_plot.filter_options_channel(self, *args)
-
-    def dna_base(self, *args):
-        return _py_interop_plot.filter_options_dna_base(self, *args)
-
-    def read(self, *args):
-        return _py_interop_plot.filter_options_read(self, *args)
-
-    def cycle(self, *args):
-        return _py_interop_plot.filter_options_cycle(self, *args)
-
-    def surface(self, *args):
-        return _py_interop_plot.filter_options_surface(self, *args)
-
-    def cycle_description(self):
-        return _py_interop_plot.filter_options_cycle_description(self)
-
-    def lane_description(self):
-        return _py_interop_plot.filter_options_lane_description(self)
-
-    def channel_description(self, channels):
-        return _py_interop_plot.filter_options_channel_description(self, channels)
-
-    def base_description(self):
-        return _py_interop_plot.filter_options_base_description(self)
-
-    def surface_description(self):
-        return _py_interop_plot.filter_options_surface_description(self)
-
-    def read_description(self):
-        return _py_interop_plot.filter_options_read_description(self)
-
-    def naming_method(self):
-        return _py_interop_plot.filter_options_naming_method(self)
-
-    def supports_section(self, arg2, info):
-        return _py_interop_plot.filter_options_supports_section(self, arg2, info)
-
-    def supports_swath(self, arg2):
-        return _py_interop_plot.filter_options_supports_swath(self, arg2)
-
-    def supports_tile(self, arg2):
-        return _py_interop_plot.filter_options_supports_tile(self, arg2)
-
-    def supports_all_lanes(self, plot_type):
-        return _py_interop_plot.filter_options_supports_all_lanes(self, plot_type)
-
-    def supports_lane(self, plot_type):
-        return _py_interop_plot.filter_options_supports_lane(self, plot_type)
-
-    def supports_all_bases(self, plot_type):
-        return _py_interop_plot.filter_options_supports_all_bases(self, plot_type)
-
-    def supports_base(self, metric_type):
-        return _py_interop_plot.filter_options_supports_base(self, metric_type)
-
-    def supports_all_channels(self, plot_type):
-        return _py_interop_plot.filter_options_supports_all_channels(self, plot_type)
-
-    def supports_channel(self, metric_type):
-        return _py_interop_plot.filter_options_supports_channel(self, metric_type)
-
-    def supports_all_cycles(self, plot_type):
-        return _py_interop_plot.filter_options_supports_all_cycles(self, plot_type)
-
-    def supports_cycle(self, metric_type, plot_type):
-        return _py_interop_plot.filter_options_supports_cycle(self, metric_type, plot_type)
-
-    def supports_all_reads(self, plot_type):
-        return _py_interop_plot.filter_options_supports_all_reads(self, plot_type)
-
-    def supports_read(self, metric_type, plot_type):
-        return _py_interop_plot.filter_options_supports_read(self, metric_type, plot_type)
-
-    def supports_surface(self, metric_type, info):
-        return _py_interop_plot.filter_options_supports_surface(self, metric_type, info)
-
-    def subsample(self, *args):
-        return _py_interop_plot.filter_options_subsample(self, *args)
-    __swig_destroy__ = _py_interop_plot.delete_filter_options
-
-# Register filter_options in _py_interop_plot:
-_py_interop_plot.filter_options_swigregister(filter_options)
-class chart_data(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def set_axes(self, xyaxes):
-        return _py_interop_plot.chart_data_set_axes(self, xyaxes)
-
-    def set_xaxis(self, xaxes):
-        return _py_interop_plot.chart_data_set_xaxis(self, xaxes)
-
-    def set_yaxis(self, yaxes):
-        return _py_interop_plot.chart_data_set_yaxis(self, yaxes)
-
-    def set_xlabel(self, label):
-        return _py_interop_plot.chart_data_set_xlabel(self, label)
-
-    def set_ylabel(self, label):
-        return _py_interop_plot.chart_data_set_ylabel(self, label)
-
-    def set_range(self, xmin, xmax, ymin, ymax):
-        return _py_interop_plot.chart_data_set_range(self, xmin, xmax, ymin, ymax)
-
-    def set_xrange(self, vmin, vmax):
-        return _py_interop_plot.chart_data_set_xrange(self, vmin, vmax)
-
-    def set_yrange(self, vmin, vmax):
-        return _py_interop_plot.chart_data_set_yrange(self, vmin, vmax)
-
-    def set_title(self, title):
-        return _py_interop_plot.chart_data_set_title(self, title)
-
-    def clear(self):
-        return _py_interop_plot.chart_data_clear(self)
-
-    def x_axis(self):
-        return _py_interop_plot.chart_data_x_axis(self)
-
-    def y_axis(self):
-        return _py_interop_plot.chart_data_y_axis(self)
-
-    def title(self):
-        return _py_interop_plot.chart_data_title(self)
-
-    def xyaxes(self):
-        return _py_interop_plot.chart_data_xyaxes(self)
-
-    def __init__(self):
-        _py_interop_plot.chart_data_swiginit(self, _py_interop_plot.new_chart_data())
-    __swig_destroy__ = _py_interop_plot.delete_chart_data
-
-# Register chart_data in _py_interop_plot:
-_py_interop_plot.chart_data_swigregister(chart_data)
-class heatmap_data(chart_data):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self):
-        _py_interop_plot.heatmap_data_swiginit(self, _py_interop_plot.new_heatmap_data())
-    __swig_destroy__ = _py_interop_plot.delete_heatmap_data
-
-    def at(self, *args):
-        return _py_interop_plot.heatmap_data_at(self, *args)
-
-    def row_count(self):
-        return _py_interop_plot.heatmap_data_row_count(self)
-
-    def column_count(self):
-        return _py_interop_plot.heatmap_data_column_count(self)
-
-    def length(self):
-        return _py_interop_plot.heatmap_data_length(self)
-
-    def empty(self):
-        return _py_interop_plot.heatmap_data_empty(self)
-
-    def set_buffer(self, *args):
-        return _py_interop_plot.heatmap_data_set_buffer(self, *args)
-
-    def resize(self, *args):
-        return _py_interop_plot.heatmap_data_resize(self, *args)
-
-    def clear(self):
-        return _py_interop_plot.heatmap_data_clear(self)
-
-    def index_of(self, row, col):
-        return _py_interop_plot.heatmap_data_index_of(self, row, col)
-
-# Register heatmap_data in _py_interop_plot:
-_py_interop_plot.heatmap_data_swigregister(heatmap_data)
-class flowcell_data(heatmap_data):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self):
-        _py_interop_plot.flowcell_data_swiginit(self, _py_interop_plot.new_flowcell_data())
-    __swig_destroy__ = _py_interop_plot.delete_flowcell_data
-
-    def tile_at(self, index):
-        return _py_interop_plot.flowcell_data_tile_at(self, index)
-
-    def tile_id(self, lane_idx, loc):
-        return _py_interop_plot.flowcell_data_tile_id(self, lane_idx, loc)
-
-    def saxis(self):
-        return _py_interop_plot.flowcell_data_saxis(self)
-
-    def subtitle(self):
-        return _py_interop_plot.flowcell_data_subtitle(self)
-
-    def lane_count(self):
-        return _py_interop_plot.flowcell_data_lane_count(self)
-
-    def swath_count(self):
-        return _py_interop_plot.flowcell_data_swath_count(self)
-
-    def tile_count(self):
-        return _py_interop_plot.flowcell_data_tile_count(self)
-
-    def total_tile_count(self):
-        return _py_interop_plot.flowcell_data_total_tile_count(self)
-
-    def set_data(self, lane_idx, loc, tile_id, value):
-        return _py_interop_plot.flowcell_data_set_data(self, lane_idx, loc, tile_id, value)
-
-    def set_saxis(self, plot_axis):
-        return _py_interop_plot.flowcell_data_set_saxis(self, plot_axis)
-
-    def set_label(self, label):
-        return _py_interop_plot.flowcell_data_set_label(self, label)
-
-    def set_subtitle(self, subtitle):
-        return _py_interop_plot.flowcell_data_set_subtitle(self, subtitle)
-
-    def set_range(self, vmin, vmax):
-        return _py_interop_plot.flowcell_data_set_range(self, vmin, vmax)
-
-    def set_buffer(self, data_buffer, id_buffer, lanes, swaths, tiles):
-        return _py_interop_plot.flowcell_data_set_buffer(self, data_buffer, id_buffer, lanes, swaths, tiles)
-
-    def resize(self, lanes, swaths, tiles):
-        return _py_interop_plot.flowcell_data_resize(self, lanes, swaths, tiles)
-
-    def clear(self):
-        return _py_interop_plot.flowcell_data_clear(self)
-
-# Register flowcell_data in _py_interop_plot:
-_py_interop_plot.flowcell_data_swigregister(flowcell_data)
-class float_point(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, x=0, y=0):
-        _py_interop_plot.float_point_swiginit(self, _py_interop_plot.new_float_point(x, y))
-
-    def x(self):
-        return _py_interop_plot.float_point_x(self)
-
-    def y(self):
-        return _py_interop_plot.float_point_y(self)
-
-    def max_value(self):
-        return _py_interop_plot.float_point_max_value(self)
-
-    def min_value(self):
-        return _py_interop_plot.float_point_min_value(self)
-
-    def add(self, x, y):
-        return _py_interop_plot.float_point_add(self, x, y)
-
-    def set(self, x, y):
-        return _py_interop_plot.float_point_set(self, x, y)
-    __swig_destroy__ = _py_interop_plot.delete_float_point
-
-# Register float_point in _py_interop_plot:
-_py_interop_plot.float_point_swigregister(float_point)
-class candle_stick_point(float_point):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _py_interop_plot.candle_stick_point_swiginit(self, _py_interop_plot.new_candle_stick_point(*args))
-
-    def max_value(self):
-        return _py_interop_plot.candle_stick_point_max_value(self)
-
-    def min_value(self):
-        return _py_interop_plot.candle_stick_point_min_value(self)
-
-    def p25(self):
-        return _py_interop_plot.candle_stick_point_p25(self)
-
-    def p50(self):
-        return _py_interop_plot.candle_stick_point_p50(self)
-
-    def p75(self):
-        return _py_interop_plot.candle_stick_point_p75(self)
-
-    def lower(self):
-        return _py_interop_plot.candle_stick_point_lower(self)
-
-    def upper(self):
-        return _py_interop_plot.candle_stick_point_upper(self)
-
-    def outliers(self):
-        return _py_interop_plot.candle_stick_point_outliers(self)
-
-    def data_point_count(self):
-        return _py_interop_plot.candle_stick_point_data_point_count(self)
-    __swig_destroy__ = _py_interop_plot.delete_candle_stick_point
-
-# Register candle_stick_point in _py_interop_plot:
-_py_interop_plot.candle_stick_point_swigregister(candle_stick_point)
-class bar_point(float_point):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, x=0, height=0, width=0):
-        _py_interop_plot.bar_point_swiginit(self, _py_interop_plot.new_bar_point(x, height, width))
-
-    def set(self, x, height, width=1):
-        return _py_interop_plot.bar_point_set(self, x, height, width)
-
-    def width(self):
-        return _py_interop_plot.bar_point_width(self)
-
-    def min_value(self):
-        return _py_interop_plot.bar_point_min_value(self)
-    __swig_destroy__ = _py_interop_plot.delete_bar_point
-
-# Register bar_point in _py_interop_plot:
-_py_interop_plot.bar_point_swigregister(bar_point)
-class bar_vector(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _py_interop_plot.bar_vector___nonzero__(self)
-
-    def __bool__(self):
-        return _py_interop_plot.bar_vector___bool__(self)
-
-    def __len__(self):
-        return _py_interop_plot.bar_vector___len__(self)
-
-    def __getslice__(self, i, j):
-        return _py_interop_plot.bar_vector___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _py_interop_plot.bar_vector___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _py_interop_plot.bar_vector___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _py_interop_plot.bar_vector___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _py_interop_plot.bar_vector___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _py_interop_plot.bar_vector___setitem__(self, *args)
-
-    def pop(self):
-        return _py_interop_plot.bar_vector_pop(self)
-
-    def append(self, x):
-        return _py_interop_plot.bar_vector_append(self, x)
-
-    def empty(self):
-        return _py_interop_plot.bar_vector_empty(self)
-
-    def size(self):
-        return _py_interop_plot.bar_vector_size(self)
-
-    def swap(self, v):
-        return _py_interop_plot.bar_vector_swap(self, v)
-
-    def rbegin(self):
-        return _py_interop_plot.bar_vector_rbegin(self)
-
-    def rend(self):
-        return _py_interop_plot.bar_vector_rend(self)
-
-    def clear(self):
-        return _py_interop_plot.bar_vector_clear(self)
-
-    def get_allocator(self):
-        return _py_interop_plot.bar_vector_get_allocator(self)
-
-    def pop_back(self):
-        return _py_interop_plot.bar_vector_pop_back(self)
-
-    def erase(self, *args):
-        return _py_interop_plot.bar_vector_erase(self, *args)
-
-    def __init__(self, *args):
-        _py_interop_plot.bar_vector_swiginit(self, _py_interop_plot.new_bar_vector(*args))
-
-    def push_back(self, x):
-        return _py_interop_plot.bar_vector_push_back(self, x)
-
-    def front(self):
-        return _py_interop_plot.bar_vector_front(self)
-
-    def back(self):
-        return _py_interop_plot.bar_vector_back(self)
-
-    def assign(self, n, x):
-        return _py_interop_plot.bar_vector_assign(self, n, x)
-
-    def resize(self, *args):
-        return _py_interop_plot.bar_vector_resize(self, *args)
-
-    def insert(self, *args):
-        return _py_interop_plot.bar_vector_insert(self, *args)
-
-    def reserve(self, n):
-        return _py_interop_plot.bar_vector_reserve(self, n)
-
-    def capacity(self):
-        return _py_interop_plot.bar_vector_capacity(self)
-    __swig_destroy__ = _py_interop_plot.delete_bar_vector
-
-# Register bar_vector in _py_interop_plot:
-_py_interop_plot.bar_vector_swigregister(bar_vector)
-class candle_stick_vector(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _py_interop_plot.candle_stick_vector___nonzero__(self)
-
-    def __bool__(self):
-        return _py_interop_plot.candle_stick_vector___bool__(self)
-
-    def __len__(self):
-        return _py_interop_plot.candle_stick_vector___len__(self)
-
-    def __getslice__(self, i, j):
-        return _py_interop_plot.candle_stick_vector___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _py_interop_plot.candle_stick_vector___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _py_interop_plot.candle_stick_vector___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _py_interop_plot.candle_stick_vector___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _py_interop_plot.candle_stick_vector___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _py_interop_plot.candle_stick_vector___setitem__(self, *args)
-
-    def pop(self):
-        return _py_interop_plot.candle_stick_vector_pop(self)
-
-    def append(self, x):
-        return _py_interop_plot.candle_stick_vector_append(self, x)
-
-    def empty(self):
-        return _py_interop_plot.candle_stick_vector_empty(self)
-
-    def size(self):
-        return _py_interop_plot.candle_stick_vector_size(self)
-
-    def swap(self, v):
-        return _py_interop_plot.candle_stick_vector_swap(self, v)
-
-    def rbegin(self):
-        return _py_interop_plot.candle_stick_vector_rbegin(self)
-
-    def rend(self):
-        return _py_interop_plot.candle_stick_vector_rend(self)
-
-    def clear(self):
-        return _py_interop_plot.candle_stick_vector_clear(self)
-
-    def get_allocator(self):
-        return _py_interop_plot.candle_stick_vector_get_allocator(self)
-
-    def pop_back(self):
-        return _py_interop_plot.candle_stick_vector_pop_back(self)
-
-    def erase(self, *args):
-        return _py_interop_plot.candle_stick_vector_erase(self, *args)
-
-    def __init__(self, *args):
-        _py_interop_plot.candle_stick_vector_swiginit(self, _py_interop_plot.new_candle_stick_vector(*args))
-
-    def push_back(self, x):
-        return _py_interop_plot.candle_stick_vector_push_back(self, x)
-
-    def front(self):
-        return _py_interop_plot.candle_stick_vector_front(self)
-
-    def back(self):
-        return _py_interop_plot.candle_stick_vector_back(self)
-
-    def assign(self, n, x):
-        return _py_interop_plot.candle_stick_vector_assign(self, n, x)
-
-    def resize(self, *args):
-        return _py_interop_plot.candle_stick_vector_resize(self, *args)
-
-    def insert(self, *args):
-        return _py_interop_plot.candle_stick_vector_insert(self, *args)
-
-    def reserve(self, n):
-        return _py_interop_plot.candle_stick_vector_reserve(self, n)
-
-    def capacity(self):
-        return _py_interop_plot.candle_stick_vector_capacity(self)
-    __swig_destroy__ = _py_interop_plot.delete_candle_stick_vector
-
-# Register candle_stick_vector in _py_interop_plot:
-_py_interop_plot.candle_stick_vector_swigregister(candle_stick_vector)
-class candle_stick_collection(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def at(self, index):
-        return _py_interop_plot.candle_stick_collection_at(self, index)
-
-    def size(self):
-        return _py_interop_plot.candle_stick_collection_size(self)
-
-    def assign(self, n, val):
-        return _py_interop_plot.candle_stick_collection_assign(self, n, val)
-
-    def resize(self, n):
-        return _py_interop_plot.candle_stick_collection_resize(self, n)
-
-    def push_back(self, point):
-        return _py_interop_plot.candle_stick_collection_push_back(self, point)
-
-    def __init__(self):
-        _py_interop_plot.candle_stick_collection_swiginit(self, _py_interop_plot.new_candle_stick_collection())
-    __swig_destroy__ = _py_interop_plot.delete_candle_stick_collection
-
-# Register candle_stick_collection in _py_interop_plot:
-_py_interop_plot.candle_stick_collection_swigregister(candle_stick_collection)
-class bar_collection(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def at(self, index):
-        return _py_interop_plot.bar_collection_at(self, index)
-
-    def size(self):
-        return _py_interop_plot.bar_collection_size(self)
-
-    def assign(self, n, val):
-        return _py_interop_plot.bar_collection_assign(self, n, val)
-
-    def resize(self, n):
-        return _py_interop_plot.bar_collection_resize(self, n)
-
-    def push_back(self, point):
-        return _py_interop_plot.bar_collection_push_back(self, point)
-
-    def __init__(self):
-        _py_interop_plot.bar_collection_swiginit(self, _py_interop_plot.new_bar_collection())
-    __swig_destroy__ = _py_interop_plot.delete_bar_collection
-
-# Register bar_collection in _py_interop_plot:
-_py_interop_plot.bar_collection_swigregister(bar_collection)
-class candle_stick_series(candle_stick_collection):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    Candlestick = _py_interop_plot.candle_stick_series_Candlestick
-    Line = _py_interop_plot.candle_stick_series_Line
-    Bar = _py_interop_plot.candle_stick_series_Bar
-
-    def __init__(self, *args):
-        _py_interop_plot.candle_stick_series_swiginit(self, _py_interop_plot.new_candle_stick_series(*args))
-
-    def title(self):
-        return _py_interop_plot.candle_stick_series_title(self)
-
-    def series_type(self):
-        return _py_interop_plot.candle_stick_series_series_type(self)
-
-    def options(self):
-        return _py_interop_plot.candle_stick_series_options(self)
-
-    def add_option(self, option):
-        return _py_interop_plot.candle_stick_series_add_option(self, option)
-
-    def color(self, *args):
-        return _py_interop_plot.candle_stick_series_color(self, *args)
-    __swig_destroy__ = _py_interop_plot.delete_candle_stick_series
-
-# Register candle_stick_series in _py_interop_plot:
-_py_interop_plot.candle_stick_series_swigregister(candle_stick_series)
-class bar_series(bar_collection):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    Candlestick = _py_interop_plot.bar_series_Candlestick
-    Line = _py_interop_plot.bar_series_Line
-    Bar = _py_interop_plot.bar_series_Bar
-
-    def __init__(self, *args):
-        _py_interop_plot.bar_series_swiginit(self, _py_interop_plot.new_bar_series(*args))
-
-    def title(self):
-        return _py_interop_plot.bar_series_title(self)
-
-    def series_type(self):
-        return _py_interop_plot.bar_series_series_type(self)
-
-    def options(self):
-        return _py_interop_plot.bar_series_options(self)
-
-    def add_option(self, option):
-        return _py_interop_plot.bar_series_add_option(self, option)
-
-    def color(self, *args):
-        return _py_interop_plot.bar_series_color(self, *args)
-    __swig_destroy__ = _py_interop_plot.delete_bar_series
-
-# Register bar_series in _py_interop_plot:
-_py_interop_plot.bar_series_swigregister(bar_series)
-class candle_stick_plot_data(chart_data):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def at(self, index):
-        return _py_interop_plot.candle_stick_plot_data_at(self, index)
-
-    def size(self):
-        return _py_interop_plot.candle_stick_plot_data_size(self)
-
-    def empty(self):
-        return _py_interop_plot.candle_stick_plot_data_empty(self)
-
-    def clear(self):
-        return _py_interop_plot.candle_stick_plot_data_clear(self)
-
-    def resize(self, n):
-        return _py_interop_plot.candle_stick_plot_data_resize(self, n)
-
-    def assign(self, n, val):
-        return _py_interop_plot.candle_stick_plot_data_assign(self, n, val)
-
-    def push_back(self, val):
-        return _py_interop_plot.candle_stick_plot_data_push_back(self, val)
-
-    def __init__(self):
-        _py_interop_plot.candle_stick_plot_data_swiginit(self, _py_interop_plot.new_candle_stick_plot_data())
-    __swig_destroy__ = _py_interop_plot.delete_candle_stick_plot_data
-
-# Register candle_stick_plot_data in _py_interop_plot:
-_py_interop_plot.candle_stick_plot_data_swigregister(candle_stick_plot_data)
-class bar_plot_data(chart_data):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def at(self, index):
-        return _py_interop_plot.bar_plot_data_at(self, index)
-
-    def size(self):
-        return _py_interop_plot.bar_plot_data_size(self)
-
-    def empty(self):
-        return _py_interop_plot.bar_plot_data_empty(self)
-
-    def clear(self):
-        return _py_interop_plot.bar_plot_data_clear(self)
-
-    def resize(self, n):
-        return _py_interop_plot.bar_plot_data_resize(self, n)
-
-    def assign(self, n, val):
-        return _py_interop_plot.bar_plot_data_assign(self, n, val)
-
-    def push_back(self, val):
-        return _py_interop_plot.bar_plot_data_push_back(self, val)
-
-    def __init__(self):
-        _py_interop_plot.bar_plot_data_swiginit(self, _py_interop_plot.new_bar_plot_data())
-    __swig_destroy__ = _py_interop_plot.delete_bar_plot_data
-
-# Register bar_plot_data in _py_interop_plot:
-_py_interop_plot.bar_plot_data_swigregister(bar_plot_data)
-
-def plot_by_cycle(*args):
-    return _py_interop_plot.plot_by_cycle(*args)
-
-def list_by_cycle_metrics(types, ignore_accumulated=False):
-    return _py_interop_plot.list_by_cycle_metrics(types, ignore_accumulated)
-
-def filter_by_cycle_metrics(types, ignore_accumulated=False):
-    return _py_interop_plot.filter_by_cycle_metrics(types, ignore_accumulated)
-
-def plot_by_lane(*args):
-    return _py_interop_plot.plot_by_lane(*args)
-
-def list_by_lane_metrics(types, ignore_pf=False):
-    return _py_interop_plot.list_by_lane_metrics(types, ignore_pf)
-
-def filter_by_lane_metrics(types, ignore_pf=False):
-    return _py_interop_plot.filter_by_lane_metrics(types, ignore_pf)
-
-def plot_qscore_histogram(metrics, options, data, boundary=0):
-    return _py_interop_plot.plot_qscore_histogram(metrics, options, data, boundary)
-
-def plot_qscore_heatmap(metrics, options, data, buffer=None):
-    return _py_interop_plot.plot_qscore_heatmap(metrics, options, data, buffer)
-
-def count_rows_for_heatmap(metrics):
-    return _py_interop_plot.count_rows_for_heatmap(metrics)
-
-def count_columns_for_heatmap(metrics):
-    return _py_interop_plot.count_columns_for_heatmap(metrics)
-
-def plot_flowcell_map(*args):
-    return _py_interop_plot.plot_flowcell_map(*args)
-
-def plot_flowcell_map2(*args):
-    return _py_interop_plot.plot_flowcell_map2(*args)
-
-def list_flowcell_metrics(types, ignore_accumulated=False):
-    return _py_interop_plot.list_flowcell_metrics(types, ignore_accumulated)
-
-def filter_flowcell_metrics(types, ignore_accumulated=False):
-    return _py_interop_plot.filter_flowcell_metrics(types, ignore_accumulated)
-
-def calculate_flowcell_buffer_size(metrics, options):
-    return _py_interop_plot.calculate_flowcell_buffer_size(metrics, options)
-
-def plot_sample_qc(metrics, lane, data):
-    return _py_interop_plot.plot_sample_qc(metrics, lane, data)
-
-def list_plot_metrics(types):
-    return _py_interop_plot.list_plot_metrics(types)
-
-def list_available_plot_metrics(metrics, types):
-    return _py_interop_plot.list_available_plot_metrics(metrics, types)
-
+# This file was automatically generated by SWIG (http://www.swig.org).
+# Version 4.0.2
+#
+# Do not make changes to this file unless you know what you are doing--modify
+# the SWIG interface file instead.
+
+from sys import version_info as _swig_python_version_info
+if _swig_python_version_info < (2, 7, 0):
+    raise RuntimeError("Python 2.7 or later required")
+
+# Import the low-level C/C++ module
+if __package__ or "." in __name__:
+    from . import _py_interop_plot
+else:
+    import _py_interop_plot
+
+try:
+    import builtins as __builtin__
+except ImportError:
+    import __builtin__
+
+def _swig_repr(self):
+    try:
+        strthis = "proxy of " + self.this.__repr__()
+    except __builtin__.Exception:
+        strthis = ""
+    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)
+
+
+def _swig_setattr_nondynamic_instance_variable(set):
+    def set_instance_attr(self, name, value):
+        if name == "thisown":
+            self.this.own(value)
+        elif name == "this":
+            set(self, name, value)
+        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
+            set(self, name, value)
+        else:
+            raise AttributeError("You cannot add instance attributes to %s" % self)
+    return set_instance_attr
+
+
+def _swig_setattr_nondynamic_class_variable(set):
+    def set_class_attr(cls, name, value):
+        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
+            set(cls, name, value)
+        else:
+            raise AttributeError("You cannot add class attributes to %s" % cls)
+    return set_class_attr
+
+
+def _swig_add_metaclass(metaclass):
+    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
+    def wrapper(cls):
+        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
+    return wrapper
+
+
+class _SwigNonDynamicMeta(type):
+    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
+    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)
+
+
+class SwigPyIterator(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined - class is abstract")
+    __repr__ = _swig_repr
+    __swig_destroy__ = _py_interop_plot.delete_SwigPyIterator
+
+    def value(self):
+        return _py_interop_plot.SwigPyIterator_value(self)
+
+    def incr(self, n=1):
+        return _py_interop_plot.SwigPyIterator_incr(self, n)
+
+    def decr(self, n=1):
+        return _py_interop_plot.SwigPyIterator_decr(self, n)
+
+    def distance(self, x):
+        return _py_interop_plot.SwigPyIterator_distance(self, x)
+
+    def equal(self, x):
+        return _py_interop_plot.SwigPyIterator_equal(self, x)
+
+    def copy(self):
+        return _py_interop_plot.SwigPyIterator_copy(self)
+
+    def next(self):
+        return _py_interop_plot.SwigPyIterator_next(self)
+
+    def __next__(self):
+        return _py_interop_plot.SwigPyIterator___next__(self)
+
+    def previous(self):
+        return _py_interop_plot.SwigPyIterator_previous(self)
+
+    def advance(self, n):
+        return _py_interop_plot.SwigPyIterator_advance(self, n)
+
+    def __eq__(self, x):
+        return _py_interop_plot.SwigPyIterator___eq__(self, x)
+
+    def __ne__(self, x):
+        return _py_interop_plot.SwigPyIterator___ne__(self, x)
+
+    def __iadd__(self, n):
+        return _py_interop_plot.SwigPyIterator___iadd__(self, n)
+
+    def __isub__(self, n):
+        return _py_interop_plot.SwigPyIterator___isub__(self, n)
+
+    def __add__(self, n):
+        return _py_interop_plot.SwigPyIterator___add__(self, n)
+
+    def __sub__(self, *args):
+        return _py_interop_plot.SwigPyIterator___sub__(self, *args)
+    def __iter__(self):
+        return self
+
+# Register SwigPyIterator in _py_interop_plot:
+_py_interop_plot.SwigPyIterator_swigregister(SwigPyIterator)
+
+import interop.py_interop_run
+import interop.py_interop_metrics
+import interop.py_interop_run_metrics
+import interop.py_interop_comm
+class invalid_filter_option(interop.py_interop_run.base_exception):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, mesg):
+        _py_interop_plot.invalid_filter_option_swiginit(self, _py_interop_plot.new_invalid_filter_option(mesg))
+
+    def __str__(self):
+        return _py_interop_plot.invalid_filter_option___str__(self)
+    __swig_destroy__ = _py_interop_plot.delete_invalid_filter_option
+
+# Register invalid_filter_option in _py_interop_plot:
+_py_interop_plot.invalid_filter_option_swigregister(invalid_filter_option)
+
+class axis(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self):
+        _py_interop_plot.axis_swiginit(self, _py_interop_plot.new_axis())
+
+    def set_range(self, vmin, vmax):
+        return _py_interop_plot.axis_set_range(self, vmin, vmax)
+
+    def set_label(self, label):
+        return _py_interop_plot.axis_set_label(self, label)
+
+    def clear(self):
+        return _py_interop_plot.axis_clear(self)
+
+    def label(self):
+        return _py_interop_plot.axis_label(self)
+
+    def min(self):
+        return _py_interop_plot.axis_min(self)
+
+    def max(self):
+        return _py_interop_plot.axis_max(self)
+    __swig_destroy__ = _py_interop_plot.delete_axis
+
+# Register axis in _py_interop_plot:
+_py_interop_plot.axis_swigregister(axis)
+
+class axes(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def set_range(self, xmin, xmax, ymin, ymax):
+        return _py_interop_plot.axes_set_range(self, xmin, xmax, ymin, ymax)
+
+    def set_xrange(self, vmin, vmax):
+        return _py_interop_plot.axes_set_xrange(self, vmin, vmax)
+
+    def set_yrange(self, vmin, vmax):
+        return _py_interop_plot.axes_set_yrange(self, vmin, vmax)
+
+    def set_xlabel(self, label):
+        return _py_interop_plot.axes_set_xlabel(self, label)
+
+    def set_ylabel(self, label):
+        return _py_interop_plot.axes_set_ylabel(self, label)
+
+    def set_xaxis(self, xaxes):
+        return _py_interop_plot.axes_set_xaxis(self, xaxes)
+
+    def set_yaxis(self, yaxes):
+        return _py_interop_plot.axes_set_yaxis(self, yaxes)
+
+    def clear(self):
+        return _py_interop_plot.axes_clear(self)
+
+    def xlabel(self):
+        return _py_interop_plot.axes_xlabel(self)
+
+    def ylabel(self):
+        return _py_interop_plot.axes_ylabel(self)
+
+    def x(self):
+        return _py_interop_plot.axes_x(self)
+
+    def y(self):
+        return _py_interop_plot.axes_y(self)
+
+    def __init__(self):
+        _py_interop_plot.axes_swiginit(self, _py_interop_plot.new_axes())
+    __swig_destroy__ = _py_interop_plot.delete_axes
+
+# Register axes in _py_interop_plot:
+_py_interop_plot.axes_swigregister(axes)
+
+class filter_options(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    ALL_IDS = _py_interop_plot.filter_options_ALL_IDS
+    ALL_CHANNELS = _py_interop_plot.filter_options_ALL_CHANNELS
+    ALL_BASES = _py_interop_plot.filter_options_ALL_BASES
+
+    def __init__(self, *args):
+        _py_interop_plot.filter_options_swiginit(self, _py_interop_plot.new_filter_options(*args))
+
+    def reset(self):
+        return _py_interop_plot.filter_options_reset(self)
+
+    def validate(self, type, run_info, check_ignored=False):
+        return _py_interop_plot.filter_options_validate(self, type, run_info, check_ignored)
+
+    def all_channels(self, *args):
+        return _py_interop_plot.filter_options_all_channels(self, *args)
+
+    def all_bases(self, *args):
+        return _py_interop_plot.filter_options_all_bases(self, *args)
+
+    def all_reads(self):
+        return _py_interop_plot.filter_options_all_reads(self)
+
+    def all_cycles(self):
+        return _py_interop_plot.filter_options_all_cycles(self)
+
+    def all_lanes(self):
+        return _py_interop_plot.filter_options_all_lanes(self)
+
+    def all_tile_numbers(self):
+        return _py_interop_plot.filter_options_all_tile_numbers(self)
+
+    def all_swaths(self):
+        return _py_interop_plot.filter_options_all_swaths(self)
+
+    def all_sections(self):
+        return _py_interop_plot.filter_options_all_sections(self)
+
+    def is_specific_read(self, *args):
+        return _py_interop_plot.filter_options_is_specific_read(self, *args)
+
+    def is_specific_surface(self):
+        return _py_interop_plot.filter_options_is_specific_surface(self)
+
+    def valid_lane(self, lane):
+        return _py_interop_plot.filter_options_valid_lane(self, lane)
+
+    def valid_surface(self, surface):
+        return _py_interop_plot.filter_options_valid_surface(self, surface)
+
+    def valid_read(self, read):
+        return _py_interop_plot.filter_options_valid_read(self, read)
+
+    def valid_cycle(self, cycle):
+        return _py_interop_plot.filter_options_valid_cycle(self, cycle)
+
+    def valid_tile_number(self, tile_number):
+        return _py_interop_plot.filter_options_valid_tile_number(self, tile_number)
+
+    def valid_swath(self, swath):
+        return _py_interop_plot.filter_options_valid_swath(self, swath)
+
+    def valid_section(self, section):
+        return _py_interop_plot.filter_options_valid_section(self, section)
+
+    def valid_channel(self, channel):
+        return _py_interop_plot.filter_options_valid_channel(self, channel)
+
+    def valid_base(self, base):
+        return _py_interop_plot.filter_options_valid_base(self, base)
+
+    def tile_naming_method(self, naming_method):
+        return _py_interop_plot.filter_options_tile_naming_method(self, naming_method)
+
+    def swath(self, s):
+        return _py_interop_plot.filter_options_swath(self, s)
+
+    def section(self, s):
+        return _py_interop_plot.filter_options_section(self, s)
+
+    def tile_number(self, s):
+        return _py_interop_plot.filter_options_tile_number(self, s)
+
+    def lane(self, *args):
+        return _py_interop_plot.filter_options_lane(self, *args)
+
+    def channel(self, *args):
+        return _py_interop_plot.filter_options_channel(self, *args)
+
+    def dna_base(self, *args):
+        return _py_interop_plot.filter_options_dna_base(self, *args)
+
+    def read(self, *args):
+        return _py_interop_plot.filter_options_read(self, *args)
+
+    def cycle(self, *args):
+        return _py_interop_plot.filter_options_cycle(self, *args)
+
+    def surface(self, *args):
+        return _py_interop_plot.filter_options_surface(self, *args)
+
+    def cycle_description(self):
+        return _py_interop_plot.filter_options_cycle_description(self)
+
+    def lane_description(self):
+        return _py_interop_plot.filter_options_lane_description(self)
+
+    def channel_description(self, channels):
+        return _py_interop_plot.filter_options_channel_description(self, channels)
+
+    def base_description(self):
+        return _py_interop_plot.filter_options_base_description(self)
+
+    def surface_description(self):
+        return _py_interop_plot.filter_options_surface_description(self)
+
+    def read_description(self):
+        return _py_interop_plot.filter_options_read_description(self)
+
+    def naming_method(self):
+        return _py_interop_plot.filter_options_naming_method(self)
+
+    def supports_section(self, arg2, info):
+        return _py_interop_plot.filter_options_supports_section(self, arg2, info)
+
+    def supports_swath(self, arg2):
+        return _py_interop_plot.filter_options_supports_swath(self, arg2)
+
+    def supports_tile(self, arg2):
+        return _py_interop_plot.filter_options_supports_tile(self, arg2)
+
+    def supports_all_lanes(self, plot_type):
+        return _py_interop_plot.filter_options_supports_all_lanes(self, plot_type)
+
+    def supports_lane(self, plot_type):
+        return _py_interop_plot.filter_options_supports_lane(self, plot_type)
+
+    def supports_all_bases(self, plot_type):
+        return _py_interop_plot.filter_options_supports_all_bases(self, plot_type)
+
+    def supports_base(self, metric_type):
+        return _py_interop_plot.filter_options_supports_base(self, metric_type)
+
+    def supports_all_channels(self, plot_type):
+        return _py_interop_plot.filter_options_supports_all_channels(self, plot_type)
+
+    def supports_channel(self, metric_type):
+        return _py_interop_plot.filter_options_supports_channel(self, metric_type)
+
+    def supports_all_cycles(self, plot_type):
+        return _py_interop_plot.filter_options_supports_all_cycles(self, plot_type)
+
+    def supports_cycle(self, metric_type, plot_type):
+        return _py_interop_plot.filter_options_supports_cycle(self, metric_type, plot_type)
+
+    def supports_all_reads(self, plot_type):
+        return _py_interop_plot.filter_options_supports_all_reads(self, plot_type)
+
+    def supports_read(self, metric_type, plot_type):
+        return _py_interop_plot.filter_options_supports_read(self, metric_type, plot_type)
+
+    def supports_surface(self, metric_type, info):
+        return _py_interop_plot.filter_options_supports_surface(self, metric_type, info)
+
+    def subsample(self, *args):
+        return _py_interop_plot.filter_options_subsample(self, *args)
+    __swig_destroy__ = _py_interop_plot.delete_filter_options
+
+# Register filter_options in _py_interop_plot:
+_py_interop_plot.filter_options_swigregister(filter_options)
+
+class chart_data(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def set_axes(self, xyaxes):
+        return _py_interop_plot.chart_data_set_axes(self, xyaxes)
+
+    def set_xaxis(self, xaxes):
+        return _py_interop_plot.chart_data_set_xaxis(self, xaxes)
+
+    def set_yaxis(self, yaxes):
+        return _py_interop_plot.chart_data_set_yaxis(self, yaxes)
+
+    def set_xlabel(self, label):
+        return _py_interop_plot.chart_data_set_xlabel(self, label)
+
+    def set_ylabel(self, label):
+        return _py_interop_plot.chart_data_set_ylabel(self, label)
+
+    def set_range(self, xmin, xmax, ymin, ymax):
+        return _py_interop_plot.chart_data_set_range(self, xmin, xmax, ymin, ymax)
+
+    def set_xrange(self, vmin, vmax):
+        return _py_interop_plot.chart_data_set_xrange(self, vmin, vmax)
+
+    def set_yrange(self, vmin, vmax):
+        return _py_interop_plot.chart_data_set_yrange(self, vmin, vmax)
+
+    def set_title(self, title):
+        return _py_interop_plot.chart_data_set_title(self, title)
+
+    def clear(self):
+        return _py_interop_plot.chart_data_clear(self)
+
+    def x_axis(self):
+        return _py_interop_plot.chart_data_x_axis(self)
+
+    def y_axis(self):
+        return _py_interop_plot.chart_data_y_axis(self)
+
+    def title(self):
+        return _py_interop_plot.chart_data_title(self)
+
+    def xyaxes(self):
+        return _py_interop_plot.chart_data_xyaxes(self)
+
+    def __init__(self):
+        _py_interop_plot.chart_data_swiginit(self, _py_interop_plot.new_chart_data())
+    __swig_destroy__ = _py_interop_plot.delete_chart_data
+
+# Register chart_data in _py_interop_plot:
+_py_interop_plot.chart_data_swigregister(chart_data)
+
+class heatmap_data(chart_data):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self):
+        _py_interop_plot.heatmap_data_swiginit(self, _py_interop_plot.new_heatmap_data())
+    __swig_destroy__ = _py_interop_plot.delete_heatmap_data
+
+    def at(self, *args):
+        return _py_interop_plot.heatmap_data_at(self, *args)
+
+    def row_count(self):
+        return _py_interop_plot.heatmap_data_row_count(self)
+
+    def column_count(self):
+        return _py_interop_plot.heatmap_data_column_count(self)
+
+    def length(self):
+        return _py_interop_plot.heatmap_data_length(self)
+
+    def empty(self):
+        return _py_interop_plot.heatmap_data_empty(self)
+
+    def set_buffer(self, *args):
+        return _py_interop_plot.heatmap_data_set_buffer(self, *args)
+
+    def resize(self, *args):
+        return _py_interop_plot.heatmap_data_resize(self, *args)
+
+    def clear(self):
+        return _py_interop_plot.heatmap_data_clear(self)
+
+    def index_of(self, row, col):
+        return _py_interop_plot.heatmap_data_index_of(self, row, col)
+
+# Register heatmap_data in _py_interop_plot:
+_py_interop_plot.heatmap_data_swigregister(heatmap_data)
+
+class flowcell_data(heatmap_data):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self):
+        _py_interop_plot.flowcell_data_swiginit(self, _py_interop_plot.new_flowcell_data())
+    __swig_destroy__ = _py_interop_plot.delete_flowcell_data
+
+    def tile_at(self, index):
+        return _py_interop_plot.flowcell_data_tile_at(self, index)
+
+    def tile_id(self, lane_idx, loc):
+        return _py_interop_plot.flowcell_data_tile_id(self, lane_idx, loc)
+
+    def saxis(self):
+        return _py_interop_plot.flowcell_data_saxis(self)
+
+    def subtitle(self):
+        return _py_interop_plot.flowcell_data_subtitle(self)
+
+    def lane_count(self):
+        return _py_interop_plot.flowcell_data_lane_count(self)
+
+    def swath_count(self):
+        return _py_interop_plot.flowcell_data_swath_count(self)
+
+    def tile_count(self):
+        return _py_interop_plot.flowcell_data_tile_count(self)
+
+    def total_tile_count(self):
+        return _py_interop_plot.flowcell_data_total_tile_count(self)
+
+    def set_data(self, lane_idx, loc, tile_id, value):
+        return _py_interop_plot.flowcell_data_set_data(self, lane_idx, loc, tile_id, value)
+
+    def set_saxis(self, plot_axis):
+        return _py_interop_plot.flowcell_data_set_saxis(self, plot_axis)
+
+    def set_label(self, label):
+        return _py_interop_plot.flowcell_data_set_label(self, label)
+
+    def set_subtitle(self, subtitle):
+        return _py_interop_plot.flowcell_data_set_subtitle(self, subtitle)
+
+    def set_range(self, vmin, vmax):
+        return _py_interop_plot.flowcell_data_set_range(self, vmin, vmax)
+
+    def set_buffer(self, data_buffer, id_buffer, lanes, swaths, tiles):
+        return _py_interop_plot.flowcell_data_set_buffer(self, data_buffer, id_buffer, lanes, swaths, tiles)
+
+    def resize(self, lanes, swaths, tiles):
+        return _py_interop_plot.flowcell_data_resize(self, lanes, swaths, tiles)
+
+    def clear(self):
+        return _py_interop_plot.flowcell_data_clear(self)
+
+# Register flowcell_data in _py_interop_plot:
+_py_interop_plot.flowcell_data_swigregister(flowcell_data)
+
+class float_point(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, x=0, y=0):
+        _py_interop_plot.float_point_swiginit(self, _py_interop_plot.new_float_point(x, y))
+
+    def x(self):
+        return _py_interop_plot.float_point_x(self)
+
+    def y(self):
+        return _py_interop_plot.float_point_y(self)
+
+    def max_value(self):
+        return _py_interop_plot.float_point_max_value(self)
+
+    def min_value(self):
+        return _py_interop_plot.float_point_min_value(self)
+
+    def add(self, x, y):
+        return _py_interop_plot.float_point_add(self, x, y)
+
+    def set(self, x, y):
+        return _py_interop_plot.float_point_set(self, x, y)
+    __swig_destroy__ = _py_interop_plot.delete_float_point
+
+# Register float_point in _py_interop_plot:
+_py_interop_plot.float_point_swigregister(float_point)
+
+class candle_stick_point(float_point):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _py_interop_plot.candle_stick_point_swiginit(self, _py_interop_plot.new_candle_stick_point(*args))
+
+    def max_value(self):
+        return _py_interop_plot.candle_stick_point_max_value(self)
+
+    def min_value(self):
+        return _py_interop_plot.candle_stick_point_min_value(self)
+
+    def p25(self):
+        return _py_interop_plot.candle_stick_point_p25(self)
+
+    def p50(self):
+        return _py_interop_plot.candle_stick_point_p50(self)
+
+    def p75(self):
+        return _py_interop_plot.candle_stick_point_p75(self)
+
+    def lower(self):
+        return _py_interop_plot.candle_stick_point_lower(self)
+
+    def upper(self):
+        return _py_interop_plot.candle_stick_point_upper(self)
+
+    def outliers(self):
+        return _py_interop_plot.candle_stick_point_outliers(self)
+
+    def data_point_count(self):
+        return _py_interop_plot.candle_stick_point_data_point_count(self)
+    __swig_destroy__ = _py_interop_plot.delete_candle_stick_point
+
+# Register candle_stick_point in _py_interop_plot:
+_py_interop_plot.candle_stick_point_swigregister(candle_stick_point)
+
+class bar_point(float_point):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, x=0, height=0, width=0):
+        _py_interop_plot.bar_point_swiginit(self, _py_interop_plot.new_bar_point(x, height, width))
+
+    def set(self, x, height, width=1):
+        return _py_interop_plot.bar_point_set(self, x, height, width)
+
+    def width(self):
+        return _py_interop_plot.bar_point_width(self)
+
+    def min_value(self):
+        return _py_interop_plot.bar_point_min_value(self)
+    __swig_destroy__ = _py_interop_plot.delete_bar_point
+
+# Register bar_point in _py_interop_plot:
+_py_interop_plot.bar_point_swigregister(bar_point)
+
+class bar_vector(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _py_interop_plot.bar_vector___nonzero__(self)
+
+    def __bool__(self):
+        return _py_interop_plot.bar_vector___bool__(self)
+
+    def __len__(self):
+        return _py_interop_plot.bar_vector___len__(self)
+
+    def __getslice__(self, i, j):
+        return _py_interop_plot.bar_vector___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _py_interop_plot.bar_vector___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _py_interop_plot.bar_vector___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _py_interop_plot.bar_vector___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _py_interop_plot.bar_vector___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _py_interop_plot.bar_vector___setitem__(self, *args)
+
+    def pop(self):
+        return _py_interop_plot.bar_vector_pop(self)
+
+    def append(self, x):
+        return _py_interop_plot.bar_vector_append(self, x)
+
+    def empty(self):
+        return _py_interop_plot.bar_vector_empty(self)
+
+    def size(self):
+        return _py_interop_plot.bar_vector_size(self)
+
+    def swap(self, v):
+        return _py_interop_plot.bar_vector_swap(self, v)
+
+    def rbegin(self):
+        return _py_interop_plot.bar_vector_rbegin(self)
+
+    def rend(self):
+        return _py_interop_plot.bar_vector_rend(self)
+
+    def clear(self):
+        return _py_interop_plot.bar_vector_clear(self)
+
+    def get_allocator(self):
+        return _py_interop_plot.bar_vector_get_allocator(self)
+
+    def pop_back(self):
+        return _py_interop_plot.bar_vector_pop_back(self)
+
+    def erase(self, *args):
+        return _py_interop_plot.bar_vector_erase(self, *args)
+
+    def __init__(self, *args):
+        _py_interop_plot.bar_vector_swiginit(self, _py_interop_plot.new_bar_vector(*args))
+
+    def push_back(self, x):
+        return _py_interop_plot.bar_vector_push_back(self, x)
+
+    def front(self):
+        return _py_interop_plot.bar_vector_front(self)
+
+    def back(self):
+        return _py_interop_plot.bar_vector_back(self)
+
+    def assign(self, n, x):
+        return _py_interop_plot.bar_vector_assign(self, n, x)
+
+    def resize(self, *args):
+        return _py_interop_plot.bar_vector_resize(self, *args)
+
+    def insert(self, *args):
+        return _py_interop_plot.bar_vector_insert(self, *args)
+
+    def reserve(self, n):
+        return _py_interop_plot.bar_vector_reserve(self, n)
+
+    def capacity(self):
+        return _py_interop_plot.bar_vector_capacity(self)
+    __swig_destroy__ = _py_interop_plot.delete_bar_vector
+
+# Register bar_vector in _py_interop_plot:
+_py_interop_plot.bar_vector_swigregister(bar_vector)
+
+class candle_stick_vector(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _py_interop_plot.candle_stick_vector___nonzero__(self)
+
+    def __bool__(self):
+        return _py_interop_plot.candle_stick_vector___bool__(self)
+
+    def __len__(self):
+        return _py_interop_plot.candle_stick_vector___len__(self)
+
+    def __getslice__(self, i, j):
+        return _py_interop_plot.candle_stick_vector___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _py_interop_plot.candle_stick_vector___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _py_interop_plot.candle_stick_vector___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _py_interop_plot.candle_stick_vector___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _py_interop_plot.candle_stick_vector___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _py_interop_plot.candle_stick_vector___setitem__(self, *args)
+
+    def pop(self):
+        return _py_interop_plot.candle_stick_vector_pop(self)
+
+    def append(self, x):
+        return _py_interop_plot.candle_stick_vector_append(self, x)
+
+    def empty(self):
+        return _py_interop_plot.candle_stick_vector_empty(self)
+
+    def size(self):
+        return _py_interop_plot.candle_stick_vector_size(self)
+
+    def swap(self, v):
+        return _py_interop_plot.candle_stick_vector_swap(self, v)
+
+    def rbegin(self):
+        return _py_interop_plot.candle_stick_vector_rbegin(self)
+
+    def rend(self):
+        return _py_interop_plot.candle_stick_vector_rend(self)
+
+    def clear(self):
+        return _py_interop_plot.candle_stick_vector_clear(self)
+
+    def get_allocator(self):
+        return _py_interop_plot.candle_stick_vector_get_allocator(self)
+
+    def pop_back(self):
+        return _py_interop_plot.candle_stick_vector_pop_back(self)
+
+    def erase(self, *args):
+        return _py_interop_plot.candle_stick_vector_erase(self, *args)
+
+    def __init__(self, *args):
+        _py_interop_plot.candle_stick_vector_swiginit(self, _py_interop_plot.new_candle_stick_vector(*args))
+
+    def push_back(self, x):
+        return _py_interop_plot.candle_stick_vector_push_back(self, x)
+
+    def front(self):
+        return _py_interop_plot.candle_stick_vector_front(self)
+
+    def back(self):
+        return _py_interop_plot.candle_stick_vector_back(self)
+
+    def assign(self, n, x):
+        return _py_interop_plot.candle_stick_vector_assign(self, n, x)
+
+    def resize(self, *args):
+        return _py_interop_plot.candle_stick_vector_resize(self, *args)
+
+    def insert(self, *args):
+        return _py_interop_plot.candle_stick_vector_insert(self, *args)
+
+    def reserve(self, n):
+        return _py_interop_plot.candle_stick_vector_reserve(self, n)
+
+    def capacity(self):
+        return _py_interop_plot.candle_stick_vector_capacity(self)
+    __swig_destroy__ = _py_interop_plot.delete_candle_stick_vector
+
+# Register candle_stick_vector in _py_interop_plot:
+_py_interop_plot.candle_stick_vector_swigregister(candle_stick_vector)
+
+class candle_stick_collection(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def at(self, index):
+        return _py_interop_plot.candle_stick_collection_at(self, index)
+
+    def size(self):
+        return _py_interop_plot.candle_stick_collection_size(self)
+
+    def assign(self, n, val):
+        return _py_interop_plot.candle_stick_collection_assign(self, n, val)
+
+    def resize(self, n):
+        return _py_interop_plot.candle_stick_collection_resize(self, n)
+
+    def push_back(self, point):
+        return _py_interop_plot.candle_stick_collection_push_back(self, point)
+
+    def __init__(self):
+        _py_interop_plot.candle_stick_collection_swiginit(self, _py_interop_plot.new_candle_stick_collection())
+    __swig_destroy__ = _py_interop_plot.delete_candle_stick_collection
+
+# Register candle_stick_collection in _py_interop_plot:
+_py_interop_plot.candle_stick_collection_swigregister(candle_stick_collection)
+
+class bar_collection(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def at(self, index):
+        return _py_interop_plot.bar_collection_at(self, index)
+
+    def size(self):
+        return _py_interop_plot.bar_collection_size(self)
+
+    def assign(self, n, val):
+        return _py_interop_plot.bar_collection_assign(self, n, val)
+
+    def resize(self, n):
+        return _py_interop_plot.bar_collection_resize(self, n)
+
+    def push_back(self, point):
+        return _py_interop_plot.bar_collection_push_back(self, point)
+
+    def __init__(self):
+        _py_interop_plot.bar_collection_swiginit(self, _py_interop_plot.new_bar_collection())
+    __swig_destroy__ = _py_interop_plot.delete_bar_collection
+
+# Register bar_collection in _py_interop_plot:
+_py_interop_plot.bar_collection_swigregister(bar_collection)
+
+class candle_stick_series(candle_stick_collection):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    Candlestick = _py_interop_plot.candle_stick_series_Candlestick
+    Line = _py_interop_plot.candle_stick_series_Line
+    Bar = _py_interop_plot.candle_stick_series_Bar
+
+    def __init__(self, *args):
+        _py_interop_plot.candle_stick_series_swiginit(self, _py_interop_plot.new_candle_stick_series(*args))
+
+    def title(self):
+        return _py_interop_plot.candle_stick_series_title(self)
+
+    def series_type(self):
+        return _py_interop_plot.candle_stick_series_series_type(self)
+
+    def options(self):
+        return _py_interop_plot.candle_stick_series_options(self)
+
+    def add_option(self, option):
+        return _py_interop_plot.candle_stick_series_add_option(self, option)
+
+    def color(self, *args):
+        return _py_interop_plot.candle_stick_series_color(self, *args)
+    __swig_destroy__ = _py_interop_plot.delete_candle_stick_series
+
+# Register candle_stick_series in _py_interop_plot:
+_py_interop_plot.candle_stick_series_swigregister(candle_stick_series)
+
+class bar_series(bar_collection):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    Candlestick = _py_interop_plot.bar_series_Candlestick
+    Line = _py_interop_plot.bar_series_Line
+    Bar = _py_interop_plot.bar_series_Bar
+
+    def __init__(self, *args):
+        _py_interop_plot.bar_series_swiginit(self, _py_interop_plot.new_bar_series(*args))
+
+    def title(self):
+        return _py_interop_plot.bar_series_title(self)
+
+    def series_type(self):
+        return _py_interop_plot.bar_series_series_type(self)
+
+    def options(self):
+        return _py_interop_plot.bar_series_options(self)
+
+    def add_option(self, option):
+        return _py_interop_plot.bar_series_add_option(self, option)
+
+    def color(self, *args):
+        return _py_interop_plot.bar_series_color(self, *args)
+    __swig_destroy__ = _py_interop_plot.delete_bar_series
+
+# Register bar_series in _py_interop_plot:
+_py_interop_plot.bar_series_swigregister(bar_series)
+
+class candle_stick_plot_data(chart_data):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def at(self, index):
+        return _py_interop_plot.candle_stick_plot_data_at(self, index)
+
+    def size(self):
+        return _py_interop_plot.candle_stick_plot_data_size(self)
+
+    def empty(self):
+        return _py_interop_plot.candle_stick_plot_data_empty(self)
+
+    def clear(self):
+        return _py_interop_plot.candle_stick_plot_data_clear(self)
+
+    def resize(self, n):
+        return _py_interop_plot.candle_stick_plot_data_resize(self, n)
+
+    def assign(self, n, val):
+        return _py_interop_plot.candle_stick_plot_data_assign(self, n, val)
+
+    def push_back(self, val):
+        return _py_interop_plot.candle_stick_plot_data_push_back(self, val)
+
+    def __init__(self):
+        _py_interop_plot.candle_stick_plot_data_swiginit(self, _py_interop_plot.new_candle_stick_plot_data())
+    __swig_destroy__ = _py_interop_plot.delete_candle_stick_plot_data
+
+# Register candle_stick_plot_data in _py_interop_plot:
+_py_interop_plot.candle_stick_plot_data_swigregister(candle_stick_plot_data)
+
+class bar_plot_data(chart_data):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def at(self, index):
+        return _py_interop_plot.bar_plot_data_at(self, index)
+
+    def size(self):
+        return _py_interop_plot.bar_plot_data_size(self)
+
+    def empty(self):
+        return _py_interop_plot.bar_plot_data_empty(self)
+
+    def clear(self):
+        return _py_interop_plot.bar_plot_data_clear(self)
+
+    def resize(self, n):
+        return _py_interop_plot.bar_plot_data_resize(self, n)
+
+    def assign(self, n, val):
+        return _py_interop_plot.bar_plot_data_assign(self, n, val)
+
+    def push_back(self, val):
+        return _py_interop_plot.bar_plot_data_push_back(self, val)
+
+    def __init__(self):
+        _py_interop_plot.bar_plot_data_swiginit(self, _py_interop_plot.new_bar_plot_data())
+    __swig_destroy__ = _py_interop_plot.delete_bar_plot_data
+
+# Register bar_plot_data in _py_interop_plot:
+_py_interop_plot.bar_plot_data_swigregister(bar_plot_data)
+
+
+def plot_by_cycle(*args):
+    return _py_interop_plot.plot_by_cycle(*args)
+
+def list_by_cycle_metrics(types, ignore_accumulated=False):
+    return _py_interop_plot.list_by_cycle_metrics(types, ignore_accumulated)
+
+def filter_by_cycle_metrics(types, ignore_accumulated=False):
+    return _py_interop_plot.filter_by_cycle_metrics(types, ignore_accumulated)
+
+def plot_by_lane(*args):
+    return _py_interop_plot.plot_by_lane(*args)
+
+def list_by_lane_metrics(types, ignore_pf=False):
+    return _py_interop_plot.list_by_lane_metrics(types, ignore_pf)
+
+def filter_by_lane_metrics(types, ignore_pf=False):
+    return _py_interop_plot.filter_by_lane_metrics(types, ignore_pf)
+
+def plot_qscore_histogram(metrics, options, data, boundary=0):
+    return _py_interop_plot.plot_qscore_histogram(metrics, options, data, boundary)
+
+def plot_qscore_heatmap(metrics, options, data, buffer=None):
+    return _py_interop_plot.plot_qscore_heatmap(metrics, options, data, buffer)
+
+def count_rows_for_heatmap(metrics):
+    return _py_interop_plot.count_rows_for_heatmap(metrics)
+
+def count_columns_for_heatmap(metrics):
+    return _py_interop_plot.count_columns_for_heatmap(metrics)
+
+def plot_flowcell_map(*args):
+    return _py_interop_plot.plot_flowcell_map(*args)
+
+def plot_flowcell_map2(*args):
+    return _py_interop_plot.plot_flowcell_map2(*args)
+
+def list_flowcell_metrics(types, ignore_accumulated=False):
+    return _py_interop_plot.list_flowcell_metrics(types, ignore_accumulated)
+
+def filter_flowcell_metrics(types, ignore_accumulated=False):
+    return _py_interop_plot.filter_flowcell_metrics(types, ignore_accumulated)
+
+def calculate_flowcell_buffer_size(metrics, options):
+    return _py_interop_plot.calculate_flowcell_buffer_size(metrics, options)
+
+def plot_sample_qc(metrics, lane, data):
+    return _py_interop_plot.plot_sample_qc(metrics, lane, data)
+
+def list_plot_metrics(types):
+    return _py_interop_plot.list_plot_metrics(types)
+
+def list_available_plot_metrics(metrics, types):
+    return _py_interop_plot.list_available_plot_metrics(metrics, types)
+
+
```

## interop/py_interop_run.py

```diff
@@ -1,1491 +1,1521 @@
-# This file was automatically generated by SWIG (https://www.swig.org).
-# Version 4.1.1
-#
-# Do not make changes to this file unless you know what you are doing - modify
-# the SWIG interface file instead.
-
-from sys import version_info as _swig_python_version_info
-# Import the low-level C/C++ module
-if __package__ or "." in __name__:
-    from . import _py_interop_run
-else:
-    import _py_interop_run
-
-try:
-    import builtins as __builtin__
-except ImportError:
-    import __builtin__
-
-def _swig_repr(self):
-    try:
-        strthis = "proxy of " + self.this.__repr__()
-    except __builtin__.Exception:
-        strthis = ""
-    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)
-
-
-def _swig_setattr_nondynamic_instance_variable(set):
-    def set_instance_attr(self, name, value):
-        if name == "this":
-            set(self, name, value)
-        elif name == "thisown":
-            self.this.own(value)
-        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
-            set(self, name, value)
-        else:
-            raise AttributeError("You cannot add instance attributes to %s" % self)
-    return set_instance_attr
-
-
-def _swig_setattr_nondynamic_class_variable(set):
-    def set_class_attr(cls, name, value):
-        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
-            set(cls, name, value)
-        else:
-            raise AttributeError("You cannot add class attributes to %s" % cls)
-    return set_class_attr
-
-
-def _swig_add_metaclass(metaclass):
-    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
-    def wrapper(cls):
-        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
-    return wrapper
-
-
-class _SwigNonDynamicMeta(type):
-    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
-    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)
-
-
-class SwigPyIterator(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined - class is abstract")
-    __repr__ = _swig_repr
-    __swig_destroy__ = _py_interop_run.delete_SwigPyIterator
-
-    def value(self):
-        return _py_interop_run.SwigPyIterator_value(self)
-
-    def incr(self, n=1):
-        return _py_interop_run.SwigPyIterator_incr(self, n)
-
-    def decr(self, n=1):
-        return _py_interop_run.SwigPyIterator_decr(self, n)
-
-    def distance(self, x):
-        return _py_interop_run.SwigPyIterator_distance(self, x)
-
-    def equal(self, x):
-        return _py_interop_run.SwigPyIterator_equal(self, x)
-
-    def copy(self):
-        return _py_interop_run.SwigPyIterator_copy(self)
-
-    def next(self):
-        return _py_interop_run.SwigPyIterator_next(self)
-
-    def __next__(self):
-        return _py_interop_run.SwigPyIterator___next__(self)
-
-    def previous(self):
-        return _py_interop_run.SwigPyIterator_previous(self)
-
-    def advance(self, n):
-        return _py_interop_run.SwigPyIterator_advance(self, n)
-
-    def __eq__(self, x):
-        return _py_interop_run.SwigPyIterator___eq__(self, x)
-
-    def __ne__(self, x):
-        return _py_interop_run.SwigPyIterator___ne__(self, x)
-
-    def __iadd__(self, n):
-        return _py_interop_run.SwigPyIterator___iadd__(self, n)
-
-    def __isub__(self, n):
-        return _py_interop_run.SwigPyIterator___isub__(self, n)
-
-    def __add__(self, n):
-        return _py_interop_run.SwigPyIterator___add__(self, n)
-
-    def __sub__(self, *args):
-        return _py_interop_run.SwigPyIterator___sub__(self, *args)
-    def __iter__(self):
-        return self
-
-# Register SwigPyIterator in _py_interop_run:
-_py_interop_run.SwigPyIterator_swigregister(SwigPyIterator)
-class base_exception(Exception):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, mesg):
-        _py_interop_run.base_exception_swiginit(self, _py_interop_run.new_base_exception(mesg))
-
-    def __str__(self):
-        return _py_interop_run.base_exception___str__(self)
-    __swig_destroy__ = _py_interop_run.delete_base_exception
-
-# Register base_exception in _py_interop_run:
-_py_interop_run.base_exception_swigregister(base_exception)
-class xml_format_exception(base_exception):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, mesg):
-        _py_interop_run.xml_format_exception_swiginit(self, _py_interop_run.new_xml_format_exception(mesg))
-
-    def __str__(self):
-        return _py_interop_run.xml_format_exception___str__(self)
-    __swig_destroy__ = _py_interop_run.delete_xml_format_exception
-
-# Register xml_format_exception in _py_interop_run:
-_py_interop_run.xml_format_exception_swigregister(xml_format_exception)
-class xml_file_not_found_exception(base_exception):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, mesg):
-        _py_interop_run.xml_file_not_found_exception_swiginit(self, _py_interop_run.new_xml_file_not_found_exception(mesg))
-
-    def __str__(self):
-        return _py_interop_run.xml_file_not_found_exception___str__(self)
-    __swig_destroy__ = _py_interop_run.delete_xml_file_not_found_exception
-
-# Register xml_file_not_found_exception in _py_interop_run:
-_py_interop_run.xml_file_not_found_exception_swigregister(xml_file_not_found_exception)
-class xml_parse_exception(xml_format_exception):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, mesg):
-        _py_interop_run.xml_parse_exception_swiginit(self, _py_interop_run.new_xml_parse_exception(mesg))
-
-    def __str__(self):
-        return _py_interop_run.xml_parse_exception___str__(self)
-    __swig_destroy__ = _py_interop_run.delete_xml_parse_exception
-
-# Register xml_parse_exception in _py_interop_run:
-_py_interop_run.xml_parse_exception_swigregister(xml_parse_exception)
-class bad_xml_format_exception(xml_format_exception):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, mesg):
-        _py_interop_run.bad_xml_format_exception_swiginit(self, _py_interop_run.new_bad_xml_format_exception(mesg))
-
-    def __str__(self):
-        return _py_interop_run.bad_xml_format_exception___str__(self)
-    __swig_destroy__ = _py_interop_run.delete_bad_xml_format_exception
-
-# Register bad_xml_format_exception in _py_interop_run:
-_py_interop_run.bad_xml_format_exception_swigregister(bad_xml_format_exception)
-class empty_xml_format_exception(xml_format_exception):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, mesg):
-        _py_interop_run.empty_xml_format_exception_swiginit(self, _py_interop_run.new_empty_xml_format_exception(mesg))
-
-    def __str__(self):
-        return _py_interop_run.empty_xml_format_exception___str__(self)
-    __swig_destroy__ = _py_interop_run.delete_empty_xml_format_exception
-
-# Register empty_xml_format_exception in _py_interop_run:
-_py_interop_run.empty_xml_format_exception_swigregister(empty_xml_format_exception)
-class missing_xml_element_exception(xml_format_exception):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, mesg):
-        _py_interop_run.missing_xml_element_exception_swiginit(self, _py_interop_run.new_missing_xml_element_exception(mesg))
-
-    def __str__(self):
-        return _py_interop_run.missing_xml_element_exception___str__(self)
-    __swig_destroy__ = _py_interop_run.delete_missing_xml_element_exception
-
-# Register missing_xml_element_exception in _py_interop_run:
-_py_interop_run.missing_xml_element_exception_swigregister(missing_xml_element_exception)
-class invalid_read_exception(base_exception):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, mesg):
-        _py_interop_run.invalid_read_exception_swiginit(self, _py_interop_run.new_invalid_read_exception(mesg))
-
-    def __str__(self):
-        return _py_interop_run.invalid_read_exception___str__(self)
-    __swig_destroy__ = _py_interop_run.delete_invalid_read_exception
-
-# Register invalid_read_exception in _py_interop_run:
-_py_interop_run.invalid_read_exception_swigregister(invalid_read_exception)
-class invalid_tile_naming_method(base_exception):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, mesg):
-        _py_interop_run.invalid_tile_naming_method_swiginit(self, _py_interop_run.new_invalid_tile_naming_method(mesg))
-
-    def __str__(self):
-        return _py_interop_run.invalid_tile_naming_method___str__(self)
-    __swig_destroy__ = _py_interop_run.delete_invalid_tile_naming_method
-
-# Register invalid_tile_naming_method in _py_interop_run:
-_py_interop_run.invalid_tile_naming_method_swigregister(invalid_tile_naming_method)
-class invalid_run_info_exception(base_exception):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, mesg):
-        _py_interop_run.invalid_run_info_exception_swiginit(self, _py_interop_run.new_invalid_run_info_exception(mesg))
-
-    def __str__(self):
-        return _py_interop_run.invalid_run_info_exception___str__(self)
-    __swig_destroy__ = _py_interop_run.delete_invalid_run_info_exception
-
-# Register invalid_run_info_exception in _py_interop_run:
-_py_interop_run.invalid_run_info_exception_swigregister(invalid_run_info_exception)
-class invalid_tile_list_exception(invalid_run_info_exception):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, mesg):
-        _py_interop_run.invalid_tile_list_exception_swiginit(self, _py_interop_run.new_invalid_tile_list_exception(mesg))
-
-    def __str__(self):
-        return _py_interop_run.invalid_tile_list_exception___str__(self)
-    __swig_destroy__ = _py_interop_run.delete_invalid_tile_list_exception
-
-# Register invalid_tile_list_exception in _py_interop_run:
-_py_interop_run.invalid_tile_list_exception_swigregister(invalid_tile_list_exception)
-class invalid_run_info_cycle_exception(base_exception):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, mesg):
-        _py_interop_run.invalid_run_info_cycle_exception_swiginit(self, _py_interop_run.new_invalid_run_info_cycle_exception(mesg))
-
-    def __str__(self):
-        return _py_interop_run.invalid_run_info_cycle_exception___str__(self)
-    __swig_destroy__ = _py_interop_run.delete_invalid_run_info_cycle_exception
-
-# Register invalid_run_info_cycle_exception in _py_interop_run:
-_py_interop_run.invalid_run_info_cycle_exception_swigregister(invalid_run_info_cycle_exception)
-class string_vector(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _py_interop_run.string_vector___nonzero__(self)
-
-    def __bool__(self):
-        return _py_interop_run.string_vector___bool__(self)
-
-    def __len__(self):
-        return _py_interop_run.string_vector___len__(self)
-
-    def __getslice__(self, i, j):
-        return _py_interop_run.string_vector___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _py_interop_run.string_vector___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _py_interop_run.string_vector___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _py_interop_run.string_vector___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _py_interop_run.string_vector___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _py_interop_run.string_vector___setitem__(self, *args)
-
-    def pop(self):
-        return _py_interop_run.string_vector_pop(self)
-
-    def append(self, x):
-        return _py_interop_run.string_vector_append(self, x)
-
-    def empty(self):
-        return _py_interop_run.string_vector_empty(self)
-
-    def size(self):
-        return _py_interop_run.string_vector_size(self)
-
-    def swap(self, v):
-        return _py_interop_run.string_vector_swap(self, v)
-
-    def rbegin(self):
-        return _py_interop_run.string_vector_rbegin(self)
-
-    def rend(self):
-        return _py_interop_run.string_vector_rend(self)
-
-    def clear(self):
-        return _py_interop_run.string_vector_clear(self)
-
-    def get_allocator(self):
-        return _py_interop_run.string_vector_get_allocator(self)
-
-    def pop_back(self):
-        return _py_interop_run.string_vector_pop_back(self)
-
-    def erase(self, *args):
-        return _py_interop_run.string_vector_erase(self, *args)
-
-    def __init__(self, *args):
-        _py_interop_run.string_vector_swiginit(self, _py_interop_run.new_string_vector(*args))
-
-    def push_back(self, x):
-        return _py_interop_run.string_vector_push_back(self, x)
-
-    def front(self):
-        return _py_interop_run.string_vector_front(self)
-
-    def back(self):
-        return _py_interop_run.string_vector_back(self)
-
-    def assign(self, n, x):
-        return _py_interop_run.string_vector_assign(self, n, x)
-
-    def resize(self, *args):
-        return _py_interop_run.string_vector_resize(self, *args)
-
-    def insert(self, *args):
-        return _py_interop_run.string_vector_insert(self, *args)
-
-    def reserve(self, n):
-        return _py_interop_run.string_vector_reserve(self, n)
-
-    def capacity(self):
-        return _py_interop_run.string_vector_capacity(self)
-    __swig_destroy__ = _py_interop_run.delete_string_vector
-
-# Register string_vector in _py_interop_run:
-_py_interop_run.string_vector_swigregister(string_vector)
-class ulong_vector(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _py_interop_run.ulong_vector___nonzero__(self)
-
-    def __bool__(self):
-        return _py_interop_run.ulong_vector___bool__(self)
-
-    def __len__(self):
-        return _py_interop_run.ulong_vector___len__(self)
-
-    def __getslice__(self, i, j):
-        return _py_interop_run.ulong_vector___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _py_interop_run.ulong_vector___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _py_interop_run.ulong_vector___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _py_interop_run.ulong_vector___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _py_interop_run.ulong_vector___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _py_interop_run.ulong_vector___setitem__(self, *args)
-
-    def pop(self):
-        return _py_interop_run.ulong_vector_pop(self)
-
-    def append(self, x):
-        return _py_interop_run.ulong_vector_append(self, x)
-
-    def empty(self):
-        return _py_interop_run.ulong_vector_empty(self)
-
-    def size(self):
-        return _py_interop_run.ulong_vector_size(self)
-
-    def swap(self, v):
-        return _py_interop_run.ulong_vector_swap(self, v)
-
-    def rbegin(self):
-        return _py_interop_run.ulong_vector_rbegin(self)
-
-    def rend(self):
-        return _py_interop_run.ulong_vector_rend(self)
-
-    def clear(self):
-        return _py_interop_run.ulong_vector_clear(self)
-
-    def get_allocator(self):
-        return _py_interop_run.ulong_vector_get_allocator(self)
-
-    def pop_back(self):
-        return _py_interop_run.ulong_vector_pop_back(self)
-
-    def erase(self, *args):
-        return _py_interop_run.ulong_vector_erase(self, *args)
-
-    def __init__(self, *args):
-        _py_interop_run.ulong_vector_swiginit(self, _py_interop_run.new_ulong_vector(*args))
-
-    def push_back(self, x):
-        return _py_interop_run.ulong_vector_push_back(self, x)
-
-    def front(self):
-        return _py_interop_run.ulong_vector_front(self)
-
-    def back(self):
-        return _py_interop_run.ulong_vector_back(self)
-
-    def assign(self, n, x):
-        return _py_interop_run.ulong_vector_assign(self, n, x)
-
-    def resize(self, *args):
-        return _py_interop_run.ulong_vector_resize(self, *args)
-
-    def insert(self, *args):
-        return _py_interop_run.ulong_vector_insert(self, *args)
-
-    def reserve(self, n):
-        return _py_interop_run.ulong_vector_reserve(self, n)
-
-    def capacity(self):
-        return _py_interop_run.ulong_vector_capacity(self)
-    __swig_destroy__ = _py_interop_run.delete_ulong_vector
-
-# Register ulong_vector in _py_interop_run:
-_py_interop_run.ulong_vector_swigregister(ulong_vector)
-class ushort_vector(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _py_interop_run.ushort_vector___nonzero__(self)
-
-    def __bool__(self):
-        return _py_interop_run.ushort_vector___bool__(self)
-
-    def __len__(self):
-        return _py_interop_run.ushort_vector___len__(self)
-
-    def __getslice__(self, i, j):
-        return _py_interop_run.ushort_vector___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _py_interop_run.ushort_vector___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _py_interop_run.ushort_vector___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _py_interop_run.ushort_vector___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _py_interop_run.ushort_vector___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _py_interop_run.ushort_vector___setitem__(self, *args)
-
-    def pop(self):
-        return _py_interop_run.ushort_vector_pop(self)
-
-    def append(self, x):
-        return _py_interop_run.ushort_vector_append(self, x)
-
-    def empty(self):
-        return _py_interop_run.ushort_vector_empty(self)
-
-    def size(self):
-        return _py_interop_run.ushort_vector_size(self)
-
-    def swap(self, v):
-        return _py_interop_run.ushort_vector_swap(self, v)
-
-    def rbegin(self):
-        return _py_interop_run.ushort_vector_rbegin(self)
-
-    def rend(self):
-        return _py_interop_run.ushort_vector_rend(self)
-
-    def clear(self):
-        return _py_interop_run.ushort_vector_clear(self)
-
-    def get_allocator(self):
-        return _py_interop_run.ushort_vector_get_allocator(self)
-
-    def pop_back(self):
-        return _py_interop_run.ushort_vector_pop_back(self)
-
-    def erase(self, *args):
-        return _py_interop_run.ushort_vector_erase(self, *args)
-
-    def __init__(self, *args):
-        _py_interop_run.ushort_vector_swiginit(self, _py_interop_run.new_ushort_vector(*args))
-
-    def push_back(self, x):
-        return _py_interop_run.ushort_vector_push_back(self, x)
-
-    def front(self):
-        return _py_interop_run.ushort_vector_front(self)
-
-    def back(self):
-        return _py_interop_run.ushort_vector_back(self)
-
-    def assign(self, n, x):
-        return _py_interop_run.ushort_vector_assign(self, n, x)
-
-    def resize(self, *args):
-        return _py_interop_run.ushort_vector_resize(self, *args)
-
-    def insert(self, *args):
-        return _py_interop_run.ushort_vector_insert(self, *args)
-
-    def reserve(self, n):
-        return _py_interop_run.ushort_vector_reserve(self, n)
-
-    def capacity(self):
-        return _py_interop_run.ushort_vector_capacity(self)
-    __swig_destroy__ = _py_interop_run.delete_ushort_vector
-
-# Register ushort_vector in _py_interop_run:
-_py_interop_run.ushort_vector_swigregister(ushort_vector)
-class uint_vector(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _py_interop_run.uint_vector___nonzero__(self)
-
-    def __bool__(self):
-        return _py_interop_run.uint_vector___bool__(self)
-
-    def __len__(self):
-        return _py_interop_run.uint_vector___len__(self)
-
-    def __getslice__(self, i, j):
-        return _py_interop_run.uint_vector___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _py_interop_run.uint_vector___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _py_interop_run.uint_vector___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _py_interop_run.uint_vector___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _py_interop_run.uint_vector___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _py_interop_run.uint_vector___setitem__(self, *args)
-
-    def pop(self):
-        return _py_interop_run.uint_vector_pop(self)
-
-    def append(self, x):
-        return _py_interop_run.uint_vector_append(self, x)
-
-    def empty(self):
-        return _py_interop_run.uint_vector_empty(self)
-
-    def size(self):
-        return _py_interop_run.uint_vector_size(self)
-
-    def swap(self, v):
-        return _py_interop_run.uint_vector_swap(self, v)
-
-    def rbegin(self):
-        return _py_interop_run.uint_vector_rbegin(self)
-
-    def rend(self):
-        return _py_interop_run.uint_vector_rend(self)
-
-    def clear(self):
-        return _py_interop_run.uint_vector_clear(self)
-
-    def get_allocator(self):
-        return _py_interop_run.uint_vector_get_allocator(self)
-
-    def pop_back(self):
-        return _py_interop_run.uint_vector_pop_back(self)
-
-    def erase(self, *args):
-        return _py_interop_run.uint_vector_erase(self, *args)
-
-    def __init__(self, *args):
-        _py_interop_run.uint_vector_swiginit(self, _py_interop_run.new_uint_vector(*args))
-
-    def push_back(self, x):
-        return _py_interop_run.uint_vector_push_back(self, x)
-
-    def front(self):
-        return _py_interop_run.uint_vector_front(self)
-
-    def back(self):
-        return _py_interop_run.uint_vector_back(self)
-
-    def assign(self, n, x):
-        return _py_interop_run.uint_vector_assign(self, n, x)
-
-    def resize(self, *args):
-        return _py_interop_run.uint_vector_resize(self, *args)
-
-    def insert(self, *args):
-        return _py_interop_run.uint_vector_insert(self, *args)
-
-    def reserve(self, n):
-        return _py_interop_run.uint_vector_reserve(self, n)
-
-    def capacity(self):
-        return _py_interop_run.uint_vector_capacity(self)
-    __swig_destroy__ = _py_interop_run.delete_uint_vector
-
-# Register uint_vector in _py_interop_run:
-_py_interop_run.uint_vector_swigregister(uint_vector)
-class float_vector(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _py_interop_run.float_vector___nonzero__(self)
-
-    def __bool__(self):
-        return _py_interop_run.float_vector___bool__(self)
-
-    def __len__(self):
-        return _py_interop_run.float_vector___len__(self)
-
-    def __getslice__(self, i, j):
-        return _py_interop_run.float_vector___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _py_interop_run.float_vector___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _py_interop_run.float_vector___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _py_interop_run.float_vector___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _py_interop_run.float_vector___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _py_interop_run.float_vector___setitem__(self, *args)
-
-    def pop(self):
-        return _py_interop_run.float_vector_pop(self)
-
-    def append(self, x):
-        return _py_interop_run.float_vector_append(self, x)
-
-    def empty(self):
-        return _py_interop_run.float_vector_empty(self)
-
-    def size(self):
-        return _py_interop_run.float_vector_size(self)
-
-    def swap(self, v):
-        return _py_interop_run.float_vector_swap(self, v)
-
-    def rbegin(self):
-        return _py_interop_run.float_vector_rbegin(self)
-
-    def rend(self):
-        return _py_interop_run.float_vector_rend(self)
-
-    def clear(self):
-        return _py_interop_run.float_vector_clear(self)
-
-    def get_allocator(self):
-        return _py_interop_run.float_vector_get_allocator(self)
-
-    def pop_back(self):
-        return _py_interop_run.float_vector_pop_back(self)
-
-    def erase(self, *args):
-        return _py_interop_run.float_vector_erase(self, *args)
-
-    def __init__(self, *args):
-        _py_interop_run.float_vector_swiginit(self, _py_interop_run.new_float_vector(*args))
-
-    def push_back(self, x):
-        return _py_interop_run.float_vector_push_back(self, x)
-
-    def front(self):
-        return _py_interop_run.float_vector_front(self)
-
-    def back(self):
-        return _py_interop_run.float_vector_back(self)
-
-    def assign(self, n, x):
-        return _py_interop_run.float_vector_assign(self, n, x)
-
-    def resize(self, *args):
-        return _py_interop_run.float_vector_resize(self, *args)
-
-    def insert(self, *args):
-        return _py_interop_run.float_vector_insert(self, *args)
-
-    def reserve(self, n):
-        return _py_interop_run.float_vector_reserve(self, n)
-
-    def capacity(self):
-        return _py_interop_run.float_vector_capacity(self)
-    __swig_destroy__ = _py_interop_run.delete_float_vector
-
-# Register float_vector in _py_interop_run:
-_py_interop_run.float_vector_swigregister(float_vector)
-class bool_vector(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _py_interop_run.bool_vector___nonzero__(self)
-
-    def __bool__(self):
-        return _py_interop_run.bool_vector___bool__(self)
-
-    def __len__(self):
-        return _py_interop_run.bool_vector___len__(self)
-
-    def __getslice__(self, i, j):
-        return _py_interop_run.bool_vector___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _py_interop_run.bool_vector___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _py_interop_run.bool_vector___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _py_interop_run.bool_vector___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _py_interop_run.bool_vector___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _py_interop_run.bool_vector___setitem__(self, *args)
-
-    def pop(self):
-        return _py_interop_run.bool_vector_pop(self)
-
-    def append(self, x):
-        return _py_interop_run.bool_vector_append(self, x)
-
-    def empty(self):
-        return _py_interop_run.bool_vector_empty(self)
-
-    def size(self):
-        return _py_interop_run.bool_vector_size(self)
-
-    def swap(self, v):
-        return _py_interop_run.bool_vector_swap(self, v)
-
-    def rbegin(self):
-        return _py_interop_run.bool_vector_rbegin(self)
-
-    def rend(self):
-        return _py_interop_run.bool_vector_rend(self)
-
-    def clear(self):
-        return _py_interop_run.bool_vector_clear(self)
-
-    def get_allocator(self):
-        return _py_interop_run.bool_vector_get_allocator(self)
-
-    def pop_back(self):
-        return _py_interop_run.bool_vector_pop_back(self)
-
-    def erase(self, *args):
-        return _py_interop_run.bool_vector_erase(self, *args)
-
-    def __init__(self, *args):
-        _py_interop_run.bool_vector_swiginit(self, _py_interop_run.new_bool_vector(*args))
-
-    def push_back(self, x):
-        return _py_interop_run.bool_vector_push_back(self, x)
-
-    def front(self):
-        return _py_interop_run.bool_vector_front(self)
-
-    def back(self):
-        return _py_interop_run.bool_vector_back(self)
-
-    def assign(self, n, x):
-        return _py_interop_run.bool_vector_assign(self, n, x)
-
-    def resize(self, *args):
-        return _py_interop_run.bool_vector_resize(self, *args)
-
-    def insert(self, *args):
-        return _py_interop_run.bool_vector_insert(self, *args)
-
-    def reserve(self, n):
-        return _py_interop_run.bool_vector_reserve(self, n)
-
-    def capacity(self):
-        return _py_interop_run.bool_vector_capacity(self)
-    __swig_destroy__ = _py_interop_run.delete_bool_vector
-
-# Register bool_vector in _py_interop_run:
-_py_interop_run.bool_vector_swigregister(bool_vector)
-class uchar_vector(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _py_interop_run.uchar_vector___nonzero__(self)
-
-    def __bool__(self):
-        return _py_interop_run.uchar_vector___bool__(self)
-
-    def __len__(self):
-        return _py_interop_run.uchar_vector___len__(self)
-
-    def __getslice__(self, i, j):
-        return _py_interop_run.uchar_vector___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _py_interop_run.uchar_vector___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _py_interop_run.uchar_vector___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _py_interop_run.uchar_vector___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _py_interop_run.uchar_vector___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _py_interop_run.uchar_vector___setitem__(self, *args)
-
-    def pop(self):
-        return _py_interop_run.uchar_vector_pop(self)
-
-    def append(self, x):
-        return _py_interop_run.uchar_vector_append(self, x)
-
-    def empty(self):
-        return _py_interop_run.uchar_vector_empty(self)
-
-    def size(self):
-        return _py_interop_run.uchar_vector_size(self)
-
-    def swap(self, v):
-        return _py_interop_run.uchar_vector_swap(self, v)
-
-    def rbegin(self):
-        return _py_interop_run.uchar_vector_rbegin(self)
-
-    def rend(self):
-        return _py_interop_run.uchar_vector_rend(self)
-
-    def clear(self):
-        return _py_interop_run.uchar_vector_clear(self)
-
-    def get_allocator(self):
-        return _py_interop_run.uchar_vector_get_allocator(self)
-
-    def pop_back(self):
-        return _py_interop_run.uchar_vector_pop_back(self)
-
-    def erase(self, *args):
-        return _py_interop_run.uchar_vector_erase(self, *args)
-
-    def __init__(self, *args):
-        _py_interop_run.uchar_vector_swiginit(self, _py_interop_run.new_uchar_vector(*args))
-
-    def push_back(self, x):
-        return _py_interop_run.uchar_vector_push_back(self, x)
-
-    def front(self):
-        return _py_interop_run.uchar_vector_front(self)
-
-    def back(self):
-        return _py_interop_run.uchar_vector_back(self)
-
-    def assign(self, n, x):
-        return _py_interop_run.uchar_vector_assign(self, n, x)
-
-    def resize(self, *args):
-        return _py_interop_run.uchar_vector_resize(self, *args)
-
-    def insert(self, *args):
-        return _py_interop_run.uchar_vector_insert(self, *args)
-
-    def reserve(self, n):
-        return _py_interop_run.uchar_vector_reserve(self, n)
-
-    def capacity(self):
-        return _py_interop_run.uchar_vector_capacity(self)
-    __swig_destroy__ = _py_interop_run.delete_uchar_vector
-
-# Register uchar_vector in _py_interop_run:
-_py_interop_run.uchar_vector_swigregister(uchar_vector)
-
-def library_version():
-    return _py_interop_run.library_version()
-INTEROP_UNKNOWN = _py_interop_run.INTEROP_UNKNOWN
-Unknown = _py_interop_run.Unknown
-Intensity = _py_interop_run.Intensity
-FWHM = _py_interop_run.FWHM
-BasePercent = _py_interop_run.BasePercent
-PercentNoCall = _py_interop_run.PercentNoCall
-Q20Percent = _py_interop_run.Q20Percent
-Q30Percent = _py_interop_run.Q30Percent
-AccumPercentQ20 = _py_interop_run.AccumPercentQ20
-AccumPercentQ30 = _py_interop_run.AccumPercentQ30
-QScore = _py_interop_run.QScore
-Clusters = _py_interop_run.Clusters
-ClustersPF = _py_interop_run.ClustersPF
-ClusterCount = _py_interop_run.ClusterCount
-ClusterCountPF = _py_interop_run.ClusterCountPF
-ErrorRate = _py_interop_run.ErrorRate
-PercentPhasing = _py_interop_run.PercentPhasing
-PercentPrephasing = _py_interop_run.PercentPrephasing
-PercentAligned = _py_interop_run.PercentAligned
-Phasing = _py_interop_run.Phasing
-PrePhasing = _py_interop_run.PrePhasing
-CorrectedIntensity = _py_interop_run.CorrectedIntensity
-CalledIntensity = _py_interop_run.CalledIntensity
-SignalToNoise = _py_interop_run.SignalToNoise
-OccupiedCountK = _py_interop_run.OccupiedCountK
-PercentOccupied = _py_interop_run.PercentOccupied
-PercentPF = _py_interop_run.PercentPF
-MetricTypeCount = _py_interop_run.MetricTypeCount
-UnknownMetricType = _py_interop_run.UnknownMetricType
-CorrectedInt = _py_interop_run.CorrectedInt
-Error = _py_interop_run.Error
-Extraction = _py_interop_run.Extraction
-Image = _py_interop_run.Image
-Index = _py_interop_run.Index
-Q = _py_interop_run.Q
-Tile = _py_interop_run.Tile
-QByLane = _py_interop_run.QByLane
-QCollapsed = _py_interop_run.QCollapsed
-EmpiricalPhasing = _py_interop_run.EmpiricalPhasing
-DynamicPhasing = _py_interop_run.DynamicPhasing
-ExtendedTile = _py_interop_run.ExtendedTile
-SummaryRun = _py_interop_run.SummaryRun
-MetricCount = _py_interop_run.MetricCount
-UnknownMetricGroup = _py_interop_run.UnknownMetricGroup
-FourDigit = _py_interop_run.FourDigit
-FiveDigit = _py_interop_run.FiveDigit
-Absolute = _py_interop_run.Absolute
-TileNamingMethodCount = _py_interop_run.TileNamingMethodCount
-UnknownTileNamingMethod = _py_interop_run.UnknownTileNamingMethod
-NC = _py_interop_run.NC
-A = _py_interop_run.A
-C = _py_interop_run.C
-G = _py_interop_run.G
-T = _py_interop_run.T
-NUM_OF_BASES = _py_interop_run.NUM_OF_BASES
-NUM_OF_BASES_AND_NC = _py_interop_run.NUM_OF_BASES_AND_NC
-UnknownBase = _py_interop_run.UnknownBase
-SentinelSurface = _py_interop_run.SentinelSurface
-Top = _py_interop_run.Top
-Bottom = _py_interop_run.Bottom
-UnknownSurface = _py_interop_run.UnknownSurface
-HiSeq = _py_interop_run.HiSeq
-HiScan = _py_interop_run.HiScan
-MiSeq = _py_interop_run.MiSeq
-NextSeq = _py_interop_run.NextSeq
-MiniSeq = _py_interop_run.MiniSeq
-NovaSeq = _py_interop_run.NovaSeq
-iSeq = _py_interop_run.iSeq
-NextSeq1k2k = _py_interop_run.NextSeq1k2k
-InstrumentCount = _py_interop_run.InstrumentCount
-UnknownInstrument = _py_interop_run.UnknownInstrument
-BaseTileType = _py_interop_run.BaseTileType
-BaseCycleType = _py_interop_run.BaseCycleType
-BaseReadType = _py_interop_run.BaseReadType
-BaseLaneType = _py_interop_run.BaseLaneType
-BaseRunType = _py_interop_run.BaseRunType
-BaseMetricCount = _py_interop_run.BaseMetricCount
-UnknownBaseType = _py_interop_run.UnknownBaseType
-Red = _py_interop_run.Red
-Green = _py_interop_run.Green
-Blue = _py_interop_run.Blue
-Black = _py_interop_run.Black
-PlotColorCount = _py_interop_run.PlotColorCount
-UnknownColor = _py_interop_run.UnknownColor
-Centered = _py_interop_run.Centered
-Shifted = _py_interop_run.Shifted
-UnknownBarPlotOption = _py_interop_run.UnknownBarPlotOption
-IdType = _py_interop_run.IdType
-ValueType = _py_interop_run.ValueType
-StructType = _py_interop_run.StructType
-ChannelArray = _py_interop_run.ChannelArray
-BaseArray = _py_interop_run.BaseArray
-MetricDataCount = _py_interop_run.MetricDataCount
-UnknownMetricData = _py_interop_run.UnknownMetricData
-TileFeature = _py_interop_run.TileFeature
-CycleFeature = _py_interop_run.CycleFeature
-ReadFeature = _py_interop_run.ReadFeature
-BaseFeature = _py_interop_run.BaseFeature
-ChannelFeature = _py_interop_run.ChannelFeature
-LaneFeature = _py_interop_run.LaneFeature
-DiskFeature = _py_interop_run.DiskFeature
-UnknownMetricFeature = _py_interop_run.UnknownMetricFeature
-FlowcellPlot = _py_interop_run.FlowcellPlot
-ByCyclePlot = _py_interop_run.ByCyclePlot
-ByLanePlot = _py_interop_run.ByLanePlot
-QHistogramPlot = _py_interop_run.QHistogramPlot
-QHeatmapPlot = _py_interop_run.QHeatmapPlot
-SampleQCPlot = _py_interop_run.SampleQCPlot
-UnknownPlotType = _py_interop_run.UnknownPlotType
-class cycle_range(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _py_interop_run.cycle_range_swiginit(self, _py_interop_run.new_cycle_range(*args))
-
-    def first_cycle(self, *args):
-        return _py_interop_run.cycle_range_first_cycle(self, *args)
-
-    def last_cycle(self, *args):
-        return _py_interop_run.cycle_range_last_cycle(self, *args)
-
-    def empty(self):
-        return _py_interop_run.cycle_range_empty(self)
-
-    def update(self, *args):
-        return _py_interop_run.cycle_range_update(self, *args)
-    __swig_destroy__ = _py_interop_run.delete_cycle_range
-
-# Register cycle_range in _py_interop_run:
-_py_interop_run.cycle_range_swigregister(cycle_range)
-
-def subtract(lhs, first_cycle_of_read):
-    return _py_interop_run.subtract(lhs, first_cycle_of_read)
-
-class read_info(cycle_range):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, number=0, first_cycle=0, last_cycle=0, is_index=False, is_reverse_complement=False):
-        _py_interop_run.read_info_swiginit(self, _py_interop_run.new_read_info(number, first_cycle, last_cycle, is_index, is_reverse_complement))
-
-    def number(self):
-        return _py_interop_run.read_info_number(self)
-
-    def is_index(self):
-        return _py_interop_run.read_info_is_index(self)
-
-    def is_reverse_complement(self):
-        return _py_interop_run.read_info_is_reverse_complement(self)
-
-    def total_cycles(self):
-        return _py_interop_run.read_info_total_cycles(self)
-
-    def useable_cycles(self):
-        return _py_interop_run.read_info_useable_cycles(self)
-    __swig_destroy__ = _py_interop_run.delete_read_info
-
-# Register read_info in _py_interop_run:
-_py_interop_run.read_info_swigregister(read_info)
-class flowcell_layout(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _py_interop_run.flowcell_layout_swiginit(self, _py_interop_run.new_flowcell_layout(*args))
-
-    def supports_multisurface(self):
-        return _py_interop_run.flowcell_layout_supports_multisurface(self)
-
-    def surface_list(self):
-        return _py_interop_run.flowcell_layout_surface_list(self)
-
-    def total_number_of_sections(self):
-        return _py_interop_run.flowcell_layout_total_number_of_sections(self)
-
-    def naming_method(self):
-        return _py_interop_run.flowcell_layout_naming_method(self)
-
-    def tiles(self):
-        return _py_interop_run.flowcell_layout_tiles(self)
-
-    def barcode(self):
-        return _py_interop_run.flowcell_layout_barcode(self)
-
-    def total_swaths(self, all_surfaces):
-        return _py_interop_run.flowcell_layout_total_swaths(self, all_surfaces)
-
-    def tiles_per_lane(self):
-        return _py_interop_run.flowcell_layout_tiles_per_lane(self)
-
-    def total_tiles(self):
-        return _py_interop_run.flowcell_layout_total_tiles(self)
-
-    def set_naming_method(self, naming_method):
-        return _py_interop_run.flowcell_layout_set_naming_method(self, naming_method)
-
-    def lane_count(self, *args):
-        return _py_interop_run.flowcell_layout_lane_count(self, *args)
-
-    def surface_count(self, *args):
-        return _py_interop_run.flowcell_layout_surface_count(self, *args)
-
-    def swath_count(self, *args):
-        return _py_interop_run.flowcell_layout_swath_count(self, *args)
-
-    def tile_count(self, *args):
-        return _py_interop_run.flowcell_layout_tile_count(self, *args)
-
-    def sections_per_lane(self, *args):
-        return _py_interop_run.flowcell_layout_sections_per_lane(self, *args)
-
-    def lanes_per_section(self, *args):
-        return _py_interop_run.flowcell_layout_lanes_per_section(self, *args)
-    __swig_destroy__ = _py_interop_run.delete_flowcell_layout
-
-# Register flowcell_layout in _py_interop_run:
-_py_interop_run.flowcell_layout_swigregister(flowcell_layout)
-class image_dimensions(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, width=0, height=0):
-        _py_interop_run.image_dimensions_swiginit(self, _py_interop_run.new_image_dimensions(width, height))
-
-    def width(self):
-        return _py_interop_run.image_dimensions_width(self)
-
-    def height(self):
-        return _py_interop_run.image_dimensions_height(self)
-    __swig_destroy__ = _py_interop_run.delete_image_dimensions
-
-# Register image_dimensions in _py_interop_run:
-_py_interop_run.image_dimensions_swigregister(image_dimensions)
-class info(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _py_interop_run.info_swiginit(self, _py_interop_run.new_info(*args))
-
-    def validate_tiles(self):
-        return _py_interop_run.info_validate_tiles(self)
-
-    def validate(self, *args):
-        return _py_interop_run.info_validate(self, *args)
-
-    def validate_cycle(self, lane, tile, cycle, metric_name):
-        return _py_interop_run.info_validate_cycle(self, lane, tile, cycle, metric_name)
-
-    def validate_read(self, lane, tile, read, metric_name):
-        return _py_interop_run.info_validate_read(self, lane, tile, read, metric_name)
-
-    def instrument_name(self):
-        return _py_interop_run.info_instrument_name(self)
-
-    def flowcell_id(self):
-        return _py_interop_run.info_flowcell_id(self)
-
-    def run_number(self):
-        return _py_interop_run.info_run_number(self)
-
-    def name(self):
-        return _py_interop_run.info_name(self)
-
-    def date(self):
-        return _py_interop_run.info_date(self)
-
-    def version(self):
-        return _py_interop_run.info_version(self)
-
-    def dimensions_of_image(self):
-        return _py_interop_run.info_dimensions_of_image(self)
-
-    def is_indexed(self):
-        return _py_interop_run.info_is_indexed(self)
-
-    def is_paired_end(self):
-        return _py_interop_run.info_is_paired_end(self)
-
-    def is_last_cycle_of_read(self, cycle):
-        return _py_interop_run.info_is_last_cycle_of_read(self, cycle)
-
-    def cycle_within_read(self, cycle):
-        return _py_interop_run.info_cycle_within_read(self, cycle)
-
-    def read(self, *args):
-        return _py_interop_run.info_read(self, *args)
-
-    def channels(self, *args):
-        return _py_interop_run.info_channels(self, *args)
-
-    def reads(self, *args):
-        return _py_interop_run.info_reads(self, *args)
-
-    def set_naming_method(self, naming_method):
-        return _py_interop_run.info_set_naming_method(self, naming_method)
-
-    def flowcell(self, *args):
-        return _py_interop_run.info_flowcell(self, *args)
-
-    def total_cycles(self):
-        return _py_interop_run.info_total_cycles(self)
-
-    def useable_cycles(self):
-        return _py_interop_run.info_useable_cycles(self)
-
-    def read_file(self, filename):
-        return _py_interop_run.info_read_file(self, filename)
-
-    def parse(self, data):
-        return _py_interop_run.info_parse(self, data)
-
-    def write(self, filename):
-        return _py_interop_run.info_write(self, filename)
-    __swig_destroy__ = _py_interop_run.delete_info
-
-# Register info in _py_interop_run:
-_py_interop_run.info_swigregister(info)
-class parameters(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _py_interop_run.parameters_swiginit(self, _py_interop_run.new_parameters(*args))
-
-    def instrument_type(self):
-        return _py_interop_run.parameters_instrument_type(self)
-
-    def version(self):
-        return _py_interop_run.parameters_version(self)
-
-    def read(self, run_folder):
-        return _py_interop_run.parameters_read(self, run_folder)
-
-    def read_file(self, filename):
-        return _py_interop_run.parameters_read_file(self, filename)
-
-    def parse(self, data):
-        return _py_interop_run.parameters_parse(self, data)
-    __swig_destroy__ = _py_interop_run.delete_parameters
-
-# Register parameters in _py_interop_run:
-_py_interop_run.parameters_swigregister(parameters)
-class read_info_vector(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _py_interop_run.read_info_vector___nonzero__(self)
-
-    def __bool__(self):
-        return _py_interop_run.read_info_vector___bool__(self)
-
-    def __len__(self):
-        return _py_interop_run.read_info_vector___len__(self)
-
-    def __getslice__(self, i, j):
-        return _py_interop_run.read_info_vector___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _py_interop_run.read_info_vector___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _py_interop_run.read_info_vector___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _py_interop_run.read_info_vector___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _py_interop_run.read_info_vector___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _py_interop_run.read_info_vector___setitem__(self, *args)
-
-    def pop(self):
-        return _py_interop_run.read_info_vector_pop(self)
-
-    def append(self, x):
-        return _py_interop_run.read_info_vector_append(self, x)
-
-    def empty(self):
-        return _py_interop_run.read_info_vector_empty(self)
-
-    def size(self):
-        return _py_interop_run.read_info_vector_size(self)
-
-    def swap(self, v):
-        return _py_interop_run.read_info_vector_swap(self, v)
-
-    def rbegin(self):
-        return _py_interop_run.read_info_vector_rbegin(self)
-
-    def rend(self):
-        return _py_interop_run.read_info_vector_rend(self)
-
-    def clear(self):
-        return _py_interop_run.read_info_vector_clear(self)
-
-    def get_allocator(self):
-        return _py_interop_run.read_info_vector_get_allocator(self)
-
-    def pop_back(self):
-        return _py_interop_run.read_info_vector_pop_back(self)
-
-    def erase(self, *args):
-        return _py_interop_run.read_info_vector_erase(self, *args)
-
-    def __init__(self, *args):
-        _py_interop_run.read_info_vector_swiginit(self, _py_interop_run.new_read_info_vector(*args))
-
-    def push_back(self, x):
-        return _py_interop_run.read_info_vector_push_back(self, x)
-
-    def front(self):
-        return _py_interop_run.read_info_vector_front(self)
-
-    def back(self):
-        return _py_interop_run.read_info_vector_back(self)
-
-    def assign(self, n, x):
-        return _py_interop_run.read_info_vector_assign(self, n, x)
-
-    def resize(self, *args):
-        return _py_interop_run.read_info_vector_resize(self, *args)
-
-    def insert(self, *args):
-        return _py_interop_run.read_info_vector_insert(self, *args)
-
-    def reserve(self, n):
-        return _py_interop_run.read_info_vector_reserve(self, n)
-
-    def capacity(self):
-        return _py_interop_run.read_info_vector_capacity(self)
-    __swig_destroy__ = _py_interop_run.delete_read_info_vector
-
-# Register read_info_vector in _py_interop_run:
-_py_interop_run.read_info_vector_swigregister(read_info_vector)
-
-def list_metric_type(vec, skip=0):
-    return _py_interop_run.list_metric_type(vec, skip)
-
-def parse_metric_type(name):
-    return _py_interop_run.parse_metric_type(name)
-
-def to_string_metric_type(value):
-    return _py_interop_run.to_string_metric_type(value)
-
-def list_metric_group(vec, skip=0):
-    return _py_interop_run.list_metric_group(vec, skip)
-
-def parse_metric_group(name):
-    return _py_interop_run.parse_metric_group(name)
-
-def to_string_metric_group(value):
-    return _py_interop_run.to_string_metric_group(value)
-
-def list_tile_naming_method(vec, skip=0):
-    return _py_interop_run.list_tile_naming_method(vec, skip)
-
-def parse_tile_naming_method(name):
-    return _py_interop_run.parse_tile_naming_method(name)
-
-def to_string_tile_naming_method(value):
-    return _py_interop_run.to_string_tile_naming_method(value)
-
-def list_dna_bases(vec, skip=0):
-    return _py_interop_run.list_dna_bases(vec, skip)
-
-def parse_dna_bases(name):
-    return _py_interop_run.parse_dna_bases(name)
-
-def to_string_dna_bases(value):
-    return _py_interop_run.to_string_dna_bases(value)
-
-def list_surface_type(vec, skip=0):
-    return _py_interop_run.list_surface_type(vec, skip)
-
-def parse_surface_type(name):
-    return _py_interop_run.parse_surface_type(name)
-
-def to_string_surface_type(value):
-    return _py_interop_run.to_string_surface_type(value)
-
-def list_instrument_type(vec, skip=0):
-    return _py_interop_run.list_instrument_type(vec, skip)
-
-def parse_instrument_type(name):
-    return _py_interop_run.parse_instrument_type(name)
-
-def to_string_instrument_type(value):
-    return _py_interop_run.to_string_instrument_type(value)
-
-def list_metric_base_type(vec, skip=0):
-    return _py_interop_run.list_metric_base_type(vec, skip)
-
-def parse_metric_base_type(name):
-    return _py_interop_run.parse_metric_base_type(name)
-
-def to_string_metric_base_type(value):
-    return _py_interop_run.to_string_metric_base_type(value)
-
-def list_plot_colors(vec, skip=0):
-    return _py_interop_run.list_plot_colors(vec, skip)
-
-def parse_plot_colors(name):
-    return _py_interop_run.parse_plot_colors(name)
-
-def to_string_plot_colors(value):
-    return _py_interop_run.to_string_plot_colors(value)
-
-def list_bar_plot_options(vec, skip=0):
-    return _py_interop_run.list_bar_plot_options(vec, skip)
-
-def parse_bar_plot_options(name):
-    return _py_interop_run.parse_bar_plot_options(name)
-
-def to_string_bar_plot_options(value):
-    return _py_interop_run.to_string_bar_plot_options(value)
-
-def list_metric_data(vec, skip=0):
-    return _py_interop_run.list_metric_data(vec, skip)
-
-def parse_metric_data(name):
-    return _py_interop_run.parse_metric_data(name)
-
-def to_string_metric_data(value):
-    return _py_interop_run.to_string_metric_data(value)
-
-def list_metric_feature_type(vec, skip=0):
-    return _py_interop_run.list_metric_feature_type(vec, skip)
-
-def parse_metric_feature_type(name):
-    return _py_interop_run.parse_metric_feature_type(name)
-
-def to_string_metric_feature_type(value):
-    return _py_interop_run.to_string_metric_feature_type(value)
-
+# This file was automatically generated by SWIG (http://www.swig.org).
+# Version 4.0.2
+#
+# Do not make changes to this file unless you know what you are doing--modify
+# the SWIG interface file instead.
+
+from sys import version_info as _swig_python_version_info
+if _swig_python_version_info < (2, 7, 0):
+    raise RuntimeError("Python 2.7 or later required")
+
+# Import the low-level C/C++ module
+if __package__ or "." in __name__:
+    from . import _py_interop_run
+else:
+    import _py_interop_run
+
+try:
+    import builtins as __builtin__
+except ImportError:
+    import __builtin__
+
+def _swig_repr(self):
+    try:
+        strthis = "proxy of " + self.this.__repr__()
+    except __builtin__.Exception:
+        strthis = ""
+    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)
+
+
+def _swig_setattr_nondynamic_instance_variable(set):
+    def set_instance_attr(self, name, value):
+        if name == "thisown":
+            self.this.own(value)
+        elif name == "this":
+            set(self, name, value)
+        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
+            set(self, name, value)
+        else:
+            raise AttributeError("You cannot add instance attributes to %s" % self)
+    return set_instance_attr
+
+
+def _swig_setattr_nondynamic_class_variable(set):
+    def set_class_attr(cls, name, value):
+        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
+            set(cls, name, value)
+        else:
+            raise AttributeError("You cannot add class attributes to %s" % cls)
+    return set_class_attr
+
+
+def _swig_add_metaclass(metaclass):
+    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
+    def wrapper(cls):
+        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
+    return wrapper
+
+
+class _SwigNonDynamicMeta(type):
+    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
+    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)
+
+
+class SwigPyIterator(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined - class is abstract")
+    __repr__ = _swig_repr
+    __swig_destroy__ = _py_interop_run.delete_SwigPyIterator
+
+    def value(self):
+        return _py_interop_run.SwigPyIterator_value(self)
+
+    def incr(self, n=1):
+        return _py_interop_run.SwigPyIterator_incr(self, n)
+
+    def decr(self, n=1):
+        return _py_interop_run.SwigPyIterator_decr(self, n)
+
+    def distance(self, x):
+        return _py_interop_run.SwigPyIterator_distance(self, x)
+
+    def equal(self, x):
+        return _py_interop_run.SwigPyIterator_equal(self, x)
+
+    def copy(self):
+        return _py_interop_run.SwigPyIterator_copy(self)
+
+    def next(self):
+        return _py_interop_run.SwigPyIterator_next(self)
+
+    def __next__(self):
+        return _py_interop_run.SwigPyIterator___next__(self)
+
+    def previous(self):
+        return _py_interop_run.SwigPyIterator_previous(self)
+
+    def advance(self, n):
+        return _py_interop_run.SwigPyIterator_advance(self, n)
+
+    def __eq__(self, x):
+        return _py_interop_run.SwigPyIterator___eq__(self, x)
+
+    def __ne__(self, x):
+        return _py_interop_run.SwigPyIterator___ne__(self, x)
+
+    def __iadd__(self, n):
+        return _py_interop_run.SwigPyIterator___iadd__(self, n)
+
+    def __isub__(self, n):
+        return _py_interop_run.SwigPyIterator___isub__(self, n)
+
+    def __add__(self, n):
+        return _py_interop_run.SwigPyIterator___add__(self, n)
+
+    def __sub__(self, *args):
+        return _py_interop_run.SwigPyIterator___sub__(self, *args)
+    def __iter__(self):
+        return self
+
+# Register SwigPyIterator in _py_interop_run:
+_py_interop_run.SwigPyIterator_swigregister(SwigPyIterator)
+
+class base_exception(Exception):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, mesg):
+        _py_interop_run.base_exception_swiginit(self, _py_interop_run.new_base_exception(mesg))
+
+    def __str__(self):
+        return _py_interop_run.base_exception___str__(self)
+    __swig_destroy__ = _py_interop_run.delete_base_exception
+
+# Register base_exception in _py_interop_run:
+_py_interop_run.base_exception_swigregister(base_exception)
+
+class xml_format_exception(base_exception):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, mesg):
+        _py_interop_run.xml_format_exception_swiginit(self, _py_interop_run.new_xml_format_exception(mesg))
+
+    def __str__(self):
+        return _py_interop_run.xml_format_exception___str__(self)
+    __swig_destroy__ = _py_interop_run.delete_xml_format_exception
+
+# Register xml_format_exception in _py_interop_run:
+_py_interop_run.xml_format_exception_swigregister(xml_format_exception)
+
+class xml_file_not_found_exception(base_exception):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, mesg):
+        _py_interop_run.xml_file_not_found_exception_swiginit(self, _py_interop_run.new_xml_file_not_found_exception(mesg))
+
+    def __str__(self):
+        return _py_interop_run.xml_file_not_found_exception___str__(self)
+    __swig_destroy__ = _py_interop_run.delete_xml_file_not_found_exception
+
+# Register xml_file_not_found_exception in _py_interop_run:
+_py_interop_run.xml_file_not_found_exception_swigregister(xml_file_not_found_exception)
+
+class xml_parse_exception(xml_format_exception):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, mesg):
+        _py_interop_run.xml_parse_exception_swiginit(self, _py_interop_run.new_xml_parse_exception(mesg))
+
+    def __str__(self):
+        return _py_interop_run.xml_parse_exception___str__(self)
+    __swig_destroy__ = _py_interop_run.delete_xml_parse_exception
+
+# Register xml_parse_exception in _py_interop_run:
+_py_interop_run.xml_parse_exception_swigregister(xml_parse_exception)
+
+class bad_xml_format_exception(xml_format_exception):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, mesg):
+        _py_interop_run.bad_xml_format_exception_swiginit(self, _py_interop_run.new_bad_xml_format_exception(mesg))
+
+    def __str__(self):
+        return _py_interop_run.bad_xml_format_exception___str__(self)
+    __swig_destroy__ = _py_interop_run.delete_bad_xml_format_exception
+
+# Register bad_xml_format_exception in _py_interop_run:
+_py_interop_run.bad_xml_format_exception_swigregister(bad_xml_format_exception)
+
+class empty_xml_format_exception(xml_format_exception):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, mesg):
+        _py_interop_run.empty_xml_format_exception_swiginit(self, _py_interop_run.new_empty_xml_format_exception(mesg))
+
+    def __str__(self):
+        return _py_interop_run.empty_xml_format_exception___str__(self)
+    __swig_destroy__ = _py_interop_run.delete_empty_xml_format_exception
+
+# Register empty_xml_format_exception in _py_interop_run:
+_py_interop_run.empty_xml_format_exception_swigregister(empty_xml_format_exception)
+
+class missing_xml_element_exception(xml_format_exception):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, mesg):
+        _py_interop_run.missing_xml_element_exception_swiginit(self, _py_interop_run.new_missing_xml_element_exception(mesg))
+
+    def __str__(self):
+        return _py_interop_run.missing_xml_element_exception___str__(self)
+    __swig_destroy__ = _py_interop_run.delete_missing_xml_element_exception
+
+# Register missing_xml_element_exception in _py_interop_run:
+_py_interop_run.missing_xml_element_exception_swigregister(missing_xml_element_exception)
+
+class invalid_read_exception(base_exception):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, mesg):
+        _py_interop_run.invalid_read_exception_swiginit(self, _py_interop_run.new_invalid_read_exception(mesg))
+
+    def __str__(self):
+        return _py_interop_run.invalid_read_exception___str__(self)
+    __swig_destroy__ = _py_interop_run.delete_invalid_read_exception
+
+# Register invalid_read_exception in _py_interop_run:
+_py_interop_run.invalid_read_exception_swigregister(invalid_read_exception)
+
+class invalid_tile_naming_method(base_exception):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, mesg):
+        _py_interop_run.invalid_tile_naming_method_swiginit(self, _py_interop_run.new_invalid_tile_naming_method(mesg))
+
+    def __str__(self):
+        return _py_interop_run.invalid_tile_naming_method___str__(self)
+    __swig_destroy__ = _py_interop_run.delete_invalid_tile_naming_method
+
+# Register invalid_tile_naming_method in _py_interop_run:
+_py_interop_run.invalid_tile_naming_method_swigregister(invalid_tile_naming_method)
+
+class invalid_run_info_exception(base_exception):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, mesg):
+        _py_interop_run.invalid_run_info_exception_swiginit(self, _py_interop_run.new_invalid_run_info_exception(mesg))
+
+    def __str__(self):
+        return _py_interop_run.invalid_run_info_exception___str__(self)
+    __swig_destroy__ = _py_interop_run.delete_invalid_run_info_exception
+
+# Register invalid_run_info_exception in _py_interop_run:
+_py_interop_run.invalid_run_info_exception_swigregister(invalid_run_info_exception)
+
+class invalid_tile_list_exception(invalid_run_info_exception):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, mesg):
+        _py_interop_run.invalid_tile_list_exception_swiginit(self, _py_interop_run.new_invalid_tile_list_exception(mesg))
+
+    def __str__(self):
+        return _py_interop_run.invalid_tile_list_exception___str__(self)
+    __swig_destroy__ = _py_interop_run.delete_invalid_tile_list_exception
+
+# Register invalid_tile_list_exception in _py_interop_run:
+_py_interop_run.invalid_tile_list_exception_swigregister(invalid_tile_list_exception)
+
+class invalid_run_info_cycle_exception(base_exception):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, mesg):
+        _py_interop_run.invalid_run_info_cycle_exception_swiginit(self, _py_interop_run.new_invalid_run_info_cycle_exception(mesg))
+
+    def __str__(self):
+        return _py_interop_run.invalid_run_info_cycle_exception___str__(self)
+    __swig_destroy__ = _py_interop_run.delete_invalid_run_info_cycle_exception
+
+# Register invalid_run_info_cycle_exception in _py_interop_run:
+_py_interop_run.invalid_run_info_cycle_exception_swigregister(invalid_run_info_cycle_exception)
+
+class string_vector(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _py_interop_run.string_vector___nonzero__(self)
+
+    def __bool__(self):
+        return _py_interop_run.string_vector___bool__(self)
+
+    def __len__(self):
+        return _py_interop_run.string_vector___len__(self)
+
+    def __getslice__(self, i, j):
+        return _py_interop_run.string_vector___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _py_interop_run.string_vector___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _py_interop_run.string_vector___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _py_interop_run.string_vector___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _py_interop_run.string_vector___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _py_interop_run.string_vector___setitem__(self, *args)
+
+    def pop(self):
+        return _py_interop_run.string_vector_pop(self)
+
+    def append(self, x):
+        return _py_interop_run.string_vector_append(self, x)
+
+    def empty(self):
+        return _py_interop_run.string_vector_empty(self)
+
+    def size(self):
+        return _py_interop_run.string_vector_size(self)
+
+    def swap(self, v):
+        return _py_interop_run.string_vector_swap(self, v)
+
+    def rbegin(self):
+        return _py_interop_run.string_vector_rbegin(self)
+
+    def rend(self):
+        return _py_interop_run.string_vector_rend(self)
+
+    def clear(self):
+        return _py_interop_run.string_vector_clear(self)
+
+    def get_allocator(self):
+        return _py_interop_run.string_vector_get_allocator(self)
+
+    def pop_back(self):
+        return _py_interop_run.string_vector_pop_back(self)
+
+    def erase(self, *args):
+        return _py_interop_run.string_vector_erase(self, *args)
+
+    def __init__(self, *args):
+        _py_interop_run.string_vector_swiginit(self, _py_interop_run.new_string_vector(*args))
+
+    def push_back(self, x):
+        return _py_interop_run.string_vector_push_back(self, x)
+
+    def front(self):
+        return _py_interop_run.string_vector_front(self)
+
+    def back(self):
+        return _py_interop_run.string_vector_back(self)
+
+    def assign(self, n, x):
+        return _py_interop_run.string_vector_assign(self, n, x)
+
+    def resize(self, *args):
+        return _py_interop_run.string_vector_resize(self, *args)
+
+    def insert(self, *args):
+        return _py_interop_run.string_vector_insert(self, *args)
+
+    def reserve(self, n):
+        return _py_interop_run.string_vector_reserve(self, n)
+
+    def capacity(self):
+        return _py_interop_run.string_vector_capacity(self)
+    __swig_destroy__ = _py_interop_run.delete_string_vector
+
+# Register string_vector in _py_interop_run:
+_py_interop_run.string_vector_swigregister(string_vector)
+
+class ulong_vector(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _py_interop_run.ulong_vector___nonzero__(self)
+
+    def __bool__(self):
+        return _py_interop_run.ulong_vector___bool__(self)
+
+    def __len__(self):
+        return _py_interop_run.ulong_vector___len__(self)
+
+    def __getslice__(self, i, j):
+        return _py_interop_run.ulong_vector___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _py_interop_run.ulong_vector___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _py_interop_run.ulong_vector___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _py_interop_run.ulong_vector___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _py_interop_run.ulong_vector___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _py_interop_run.ulong_vector___setitem__(self, *args)
+
+    def pop(self):
+        return _py_interop_run.ulong_vector_pop(self)
+
+    def append(self, x):
+        return _py_interop_run.ulong_vector_append(self, x)
+
+    def empty(self):
+        return _py_interop_run.ulong_vector_empty(self)
+
+    def size(self):
+        return _py_interop_run.ulong_vector_size(self)
+
+    def swap(self, v):
+        return _py_interop_run.ulong_vector_swap(self, v)
+
+    def rbegin(self):
+        return _py_interop_run.ulong_vector_rbegin(self)
+
+    def rend(self):
+        return _py_interop_run.ulong_vector_rend(self)
+
+    def clear(self):
+        return _py_interop_run.ulong_vector_clear(self)
+
+    def get_allocator(self):
+        return _py_interop_run.ulong_vector_get_allocator(self)
+
+    def pop_back(self):
+        return _py_interop_run.ulong_vector_pop_back(self)
+
+    def erase(self, *args):
+        return _py_interop_run.ulong_vector_erase(self, *args)
+
+    def __init__(self, *args):
+        _py_interop_run.ulong_vector_swiginit(self, _py_interop_run.new_ulong_vector(*args))
+
+    def push_back(self, x):
+        return _py_interop_run.ulong_vector_push_back(self, x)
+
+    def front(self):
+        return _py_interop_run.ulong_vector_front(self)
+
+    def back(self):
+        return _py_interop_run.ulong_vector_back(self)
+
+    def assign(self, n, x):
+        return _py_interop_run.ulong_vector_assign(self, n, x)
+
+    def resize(self, *args):
+        return _py_interop_run.ulong_vector_resize(self, *args)
+
+    def insert(self, *args):
+        return _py_interop_run.ulong_vector_insert(self, *args)
+
+    def reserve(self, n):
+        return _py_interop_run.ulong_vector_reserve(self, n)
+
+    def capacity(self):
+        return _py_interop_run.ulong_vector_capacity(self)
+    __swig_destroy__ = _py_interop_run.delete_ulong_vector
+
+# Register ulong_vector in _py_interop_run:
+_py_interop_run.ulong_vector_swigregister(ulong_vector)
+
+class ushort_vector(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _py_interop_run.ushort_vector___nonzero__(self)
+
+    def __bool__(self):
+        return _py_interop_run.ushort_vector___bool__(self)
+
+    def __len__(self):
+        return _py_interop_run.ushort_vector___len__(self)
+
+    def __getslice__(self, i, j):
+        return _py_interop_run.ushort_vector___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _py_interop_run.ushort_vector___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _py_interop_run.ushort_vector___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _py_interop_run.ushort_vector___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _py_interop_run.ushort_vector___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _py_interop_run.ushort_vector___setitem__(self, *args)
+
+    def pop(self):
+        return _py_interop_run.ushort_vector_pop(self)
+
+    def append(self, x):
+        return _py_interop_run.ushort_vector_append(self, x)
+
+    def empty(self):
+        return _py_interop_run.ushort_vector_empty(self)
+
+    def size(self):
+        return _py_interop_run.ushort_vector_size(self)
+
+    def swap(self, v):
+        return _py_interop_run.ushort_vector_swap(self, v)
+
+    def rbegin(self):
+        return _py_interop_run.ushort_vector_rbegin(self)
+
+    def rend(self):
+        return _py_interop_run.ushort_vector_rend(self)
+
+    def clear(self):
+        return _py_interop_run.ushort_vector_clear(self)
+
+    def get_allocator(self):
+        return _py_interop_run.ushort_vector_get_allocator(self)
+
+    def pop_back(self):
+        return _py_interop_run.ushort_vector_pop_back(self)
+
+    def erase(self, *args):
+        return _py_interop_run.ushort_vector_erase(self, *args)
+
+    def __init__(self, *args):
+        _py_interop_run.ushort_vector_swiginit(self, _py_interop_run.new_ushort_vector(*args))
+
+    def push_back(self, x):
+        return _py_interop_run.ushort_vector_push_back(self, x)
+
+    def front(self):
+        return _py_interop_run.ushort_vector_front(self)
+
+    def back(self):
+        return _py_interop_run.ushort_vector_back(self)
+
+    def assign(self, n, x):
+        return _py_interop_run.ushort_vector_assign(self, n, x)
+
+    def resize(self, *args):
+        return _py_interop_run.ushort_vector_resize(self, *args)
+
+    def insert(self, *args):
+        return _py_interop_run.ushort_vector_insert(self, *args)
+
+    def reserve(self, n):
+        return _py_interop_run.ushort_vector_reserve(self, n)
+
+    def capacity(self):
+        return _py_interop_run.ushort_vector_capacity(self)
+    __swig_destroy__ = _py_interop_run.delete_ushort_vector
+
+# Register ushort_vector in _py_interop_run:
+_py_interop_run.ushort_vector_swigregister(ushort_vector)
+
+class uint_vector(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _py_interop_run.uint_vector___nonzero__(self)
+
+    def __bool__(self):
+        return _py_interop_run.uint_vector___bool__(self)
+
+    def __len__(self):
+        return _py_interop_run.uint_vector___len__(self)
+
+    def __getslice__(self, i, j):
+        return _py_interop_run.uint_vector___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _py_interop_run.uint_vector___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _py_interop_run.uint_vector___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _py_interop_run.uint_vector___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _py_interop_run.uint_vector___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _py_interop_run.uint_vector___setitem__(self, *args)
+
+    def pop(self):
+        return _py_interop_run.uint_vector_pop(self)
+
+    def append(self, x):
+        return _py_interop_run.uint_vector_append(self, x)
+
+    def empty(self):
+        return _py_interop_run.uint_vector_empty(self)
+
+    def size(self):
+        return _py_interop_run.uint_vector_size(self)
+
+    def swap(self, v):
+        return _py_interop_run.uint_vector_swap(self, v)
+
+    def rbegin(self):
+        return _py_interop_run.uint_vector_rbegin(self)
+
+    def rend(self):
+        return _py_interop_run.uint_vector_rend(self)
+
+    def clear(self):
+        return _py_interop_run.uint_vector_clear(self)
+
+    def get_allocator(self):
+        return _py_interop_run.uint_vector_get_allocator(self)
+
+    def pop_back(self):
+        return _py_interop_run.uint_vector_pop_back(self)
+
+    def erase(self, *args):
+        return _py_interop_run.uint_vector_erase(self, *args)
+
+    def __init__(self, *args):
+        _py_interop_run.uint_vector_swiginit(self, _py_interop_run.new_uint_vector(*args))
+
+    def push_back(self, x):
+        return _py_interop_run.uint_vector_push_back(self, x)
+
+    def front(self):
+        return _py_interop_run.uint_vector_front(self)
+
+    def back(self):
+        return _py_interop_run.uint_vector_back(self)
+
+    def assign(self, n, x):
+        return _py_interop_run.uint_vector_assign(self, n, x)
+
+    def resize(self, *args):
+        return _py_interop_run.uint_vector_resize(self, *args)
+
+    def insert(self, *args):
+        return _py_interop_run.uint_vector_insert(self, *args)
+
+    def reserve(self, n):
+        return _py_interop_run.uint_vector_reserve(self, n)
+
+    def capacity(self):
+        return _py_interop_run.uint_vector_capacity(self)
+    __swig_destroy__ = _py_interop_run.delete_uint_vector
+
+# Register uint_vector in _py_interop_run:
+_py_interop_run.uint_vector_swigregister(uint_vector)
+
+class float_vector(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _py_interop_run.float_vector___nonzero__(self)
+
+    def __bool__(self):
+        return _py_interop_run.float_vector___bool__(self)
+
+    def __len__(self):
+        return _py_interop_run.float_vector___len__(self)
+
+    def __getslice__(self, i, j):
+        return _py_interop_run.float_vector___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _py_interop_run.float_vector___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _py_interop_run.float_vector___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _py_interop_run.float_vector___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _py_interop_run.float_vector___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _py_interop_run.float_vector___setitem__(self, *args)
+
+    def pop(self):
+        return _py_interop_run.float_vector_pop(self)
+
+    def append(self, x):
+        return _py_interop_run.float_vector_append(self, x)
+
+    def empty(self):
+        return _py_interop_run.float_vector_empty(self)
+
+    def size(self):
+        return _py_interop_run.float_vector_size(self)
+
+    def swap(self, v):
+        return _py_interop_run.float_vector_swap(self, v)
+
+    def rbegin(self):
+        return _py_interop_run.float_vector_rbegin(self)
+
+    def rend(self):
+        return _py_interop_run.float_vector_rend(self)
+
+    def clear(self):
+        return _py_interop_run.float_vector_clear(self)
+
+    def get_allocator(self):
+        return _py_interop_run.float_vector_get_allocator(self)
+
+    def pop_back(self):
+        return _py_interop_run.float_vector_pop_back(self)
+
+    def erase(self, *args):
+        return _py_interop_run.float_vector_erase(self, *args)
+
+    def __init__(self, *args):
+        _py_interop_run.float_vector_swiginit(self, _py_interop_run.new_float_vector(*args))
+
+    def push_back(self, x):
+        return _py_interop_run.float_vector_push_back(self, x)
+
+    def front(self):
+        return _py_interop_run.float_vector_front(self)
+
+    def back(self):
+        return _py_interop_run.float_vector_back(self)
+
+    def assign(self, n, x):
+        return _py_interop_run.float_vector_assign(self, n, x)
+
+    def resize(self, *args):
+        return _py_interop_run.float_vector_resize(self, *args)
+
+    def insert(self, *args):
+        return _py_interop_run.float_vector_insert(self, *args)
+
+    def reserve(self, n):
+        return _py_interop_run.float_vector_reserve(self, n)
+
+    def capacity(self):
+        return _py_interop_run.float_vector_capacity(self)
+    __swig_destroy__ = _py_interop_run.delete_float_vector
+
+# Register float_vector in _py_interop_run:
+_py_interop_run.float_vector_swigregister(float_vector)
+
+class bool_vector(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _py_interop_run.bool_vector___nonzero__(self)
+
+    def __bool__(self):
+        return _py_interop_run.bool_vector___bool__(self)
+
+    def __len__(self):
+        return _py_interop_run.bool_vector___len__(self)
+
+    def __getslice__(self, i, j):
+        return _py_interop_run.bool_vector___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _py_interop_run.bool_vector___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _py_interop_run.bool_vector___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _py_interop_run.bool_vector___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _py_interop_run.bool_vector___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _py_interop_run.bool_vector___setitem__(self, *args)
+
+    def pop(self):
+        return _py_interop_run.bool_vector_pop(self)
+
+    def append(self, x):
+        return _py_interop_run.bool_vector_append(self, x)
+
+    def empty(self):
+        return _py_interop_run.bool_vector_empty(self)
+
+    def size(self):
+        return _py_interop_run.bool_vector_size(self)
+
+    def swap(self, v):
+        return _py_interop_run.bool_vector_swap(self, v)
+
+    def rbegin(self):
+        return _py_interop_run.bool_vector_rbegin(self)
+
+    def rend(self):
+        return _py_interop_run.bool_vector_rend(self)
+
+    def clear(self):
+        return _py_interop_run.bool_vector_clear(self)
+
+    def get_allocator(self):
+        return _py_interop_run.bool_vector_get_allocator(self)
+
+    def pop_back(self):
+        return _py_interop_run.bool_vector_pop_back(self)
+
+    def erase(self, *args):
+        return _py_interop_run.bool_vector_erase(self, *args)
+
+    def __init__(self, *args):
+        _py_interop_run.bool_vector_swiginit(self, _py_interop_run.new_bool_vector(*args))
+
+    def push_back(self, x):
+        return _py_interop_run.bool_vector_push_back(self, x)
+
+    def front(self):
+        return _py_interop_run.bool_vector_front(self)
+
+    def back(self):
+        return _py_interop_run.bool_vector_back(self)
+
+    def assign(self, n, x):
+        return _py_interop_run.bool_vector_assign(self, n, x)
+
+    def resize(self, *args):
+        return _py_interop_run.bool_vector_resize(self, *args)
+
+    def insert(self, *args):
+        return _py_interop_run.bool_vector_insert(self, *args)
+
+    def reserve(self, n):
+        return _py_interop_run.bool_vector_reserve(self, n)
+
+    def capacity(self):
+        return _py_interop_run.bool_vector_capacity(self)
+    __swig_destroy__ = _py_interop_run.delete_bool_vector
+
+# Register bool_vector in _py_interop_run:
+_py_interop_run.bool_vector_swigregister(bool_vector)
+
+class uchar_vector(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _py_interop_run.uchar_vector___nonzero__(self)
+
+    def __bool__(self):
+        return _py_interop_run.uchar_vector___bool__(self)
+
+    def __len__(self):
+        return _py_interop_run.uchar_vector___len__(self)
+
+    def __getslice__(self, i, j):
+        return _py_interop_run.uchar_vector___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _py_interop_run.uchar_vector___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _py_interop_run.uchar_vector___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _py_interop_run.uchar_vector___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _py_interop_run.uchar_vector___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _py_interop_run.uchar_vector___setitem__(self, *args)
+
+    def pop(self):
+        return _py_interop_run.uchar_vector_pop(self)
+
+    def append(self, x):
+        return _py_interop_run.uchar_vector_append(self, x)
+
+    def empty(self):
+        return _py_interop_run.uchar_vector_empty(self)
+
+    def size(self):
+        return _py_interop_run.uchar_vector_size(self)
+
+    def swap(self, v):
+        return _py_interop_run.uchar_vector_swap(self, v)
+
+    def rbegin(self):
+        return _py_interop_run.uchar_vector_rbegin(self)
+
+    def rend(self):
+        return _py_interop_run.uchar_vector_rend(self)
+
+    def clear(self):
+        return _py_interop_run.uchar_vector_clear(self)
+
+    def get_allocator(self):
+        return _py_interop_run.uchar_vector_get_allocator(self)
+
+    def pop_back(self):
+        return _py_interop_run.uchar_vector_pop_back(self)
+
+    def erase(self, *args):
+        return _py_interop_run.uchar_vector_erase(self, *args)
+
+    def __init__(self, *args):
+        _py_interop_run.uchar_vector_swiginit(self, _py_interop_run.new_uchar_vector(*args))
+
+    def push_back(self, x):
+        return _py_interop_run.uchar_vector_push_back(self, x)
+
+    def front(self):
+        return _py_interop_run.uchar_vector_front(self)
+
+    def back(self):
+        return _py_interop_run.uchar_vector_back(self)
+
+    def assign(self, n, x):
+        return _py_interop_run.uchar_vector_assign(self, n, x)
+
+    def resize(self, *args):
+        return _py_interop_run.uchar_vector_resize(self, *args)
+
+    def insert(self, *args):
+        return _py_interop_run.uchar_vector_insert(self, *args)
+
+    def reserve(self, n):
+        return _py_interop_run.uchar_vector_reserve(self, n)
+
+    def capacity(self):
+        return _py_interop_run.uchar_vector_capacity(self)
+    __swig_destroy__ = _py_interop_run.delete_uchar_vector
+
+# Register uchar_vector in _py_interop_run:
+_py_interop_run.uchar_vector_swigregister(uchar_vector)
+
+
+def library_version():
+    return _py_interop_run.library_version()
+INTEROP_UNKNOWN = _py_interop_run.INTEROP_UNKNOWN
+Unknown = _py_interop_run.Unknown
+Intensity = _py_interop_run.Intensity
+FWHM = _py_interop_run.FWHM
+BasePercent = _py_interop_run.BasePercent
+PercentNoCall = _py_interop_run.PercentNoCall
+Q20Percent = _py_interop_run.Q20Percent
+Q30Percent = _py_interop_run.Q30Percent
+AccumPercentQ20 = _py_interop_run.AccumPercentQ20
+AccumPercentQ30 = _py_interop_run.AccumPercentQ30
+QScore = _py_interop_run.QScore
+Clusters = _py_interop_run.Clusters
+ClustersPF = _py_interop_run.ClustersPF
+ClusterCount = _py_interop_run.ClusterCount
+ClusterCountPF = _py_interop_run.ClusterCountPF
+ErrorRate = _py_interop_run.ErrorRate
+PercentPhasing = _py_interop_run.PercentPhasing
+PercentPrephasing = _py_interop_run.PercentPrephasing
+PercentAligned = _py_interop_run.PercentAligned
+Phasing = _py_interop_run.Phasing
+PrePhasing = _py_interop_run.PrePhasing
+CorrectedIntensity = _py_interop_run.CorrectedIntensity
+CalledIntensity = _py_interop_run.CalledIntensity
+SignalToNoise = _py_interop_run.SignalToNoise
+OccupiedCountK = _py_interop_run.OccupiedCountK
+PercentOccupied = _py_interop_run.PercentOccupied
+PercentPF = _py_interop_run.PercentPF
+MetricTypeCount = _py_interop_run.MetricTypeCount
+UnknownMetricType = _py_interop_run.UnknownMetricType
+CorrectedInt = _py_interop_run.CorrectedInt
+Error = _py_interop_run.Error
+Extraction = _py_interop_run.Extraction
+Image = _py_interop_run.Image
+Index = _py_interop_run.Index
+Q = _py_interop_run.Q
+Tile = _py_interop_run.Tile
+QByLane = _py_interop_run.QByLane
+QCollapsed = _py_interop_run.QCollapsed
+EmpiricalPhasing = _py_interop_run.EmpiricalPhasing
+DynamicPhasing = _py_interop_run.DynamicPhasing
+ExtendedTile = _py_interop_run.ExtendedTile
+SummaryRun = _py_interop_run.SummaryRun
+MetricCount = _py_interop_run.MetricCount
+UnknownMetricGroup = _py_interop_run.UnknownMetricGroup
+FourDigit = _py_interop_run.FourDigit
+FiveDigit = _py_interop_run.FiveDigit
+Absolute = _py_interop_run.Absolute
+TileNamingMethodCount = _py_interop_run.TileNamingMethodCount
+UnknownTileNamingMethod = _py_interop_run.UnknownTileNamingMethod
+NC = _py_interop_run.NC
+A = _py_interop_run.A
+C = _py_interop_run.C
+G = _py_interop_run.G
+T = _py_interop_run.T
+NUM_OF_BASES = _py_interop_run.NUM_OF_BASES
+NUM_OF_BASES_AND_NC = _py_interop_run.NUM_OF_BASES_AND_NC
+UnknownBase = _py_interop_run.UnknownBase
+SentinelSurface = _py_interop_run.SentinelSurface
+Top = _py_interop_run.Top
+Bottom = _py_interop_run.Bottom
+UnknownSurface = _py_interop_run.UnknownSurface
+HiSeq = _py_interop_run.HiSeq
+HiScan = _py_interop_run.HiScan
+MiSeq = _py_interop_run.MiSeq
+NextSeq = _py_interop_run.NextSeq
+MiniSeq = _py_interop_run.MiniSeq
+NovaSeq = _py_interop_run.NovaSeq
+iSeq = _py_interop_run.iSeq
+NextSeq1k2k = _py_interop_run.NextSeq1k2k
+InstrumentCount = _py_interop_run.InstrumentCount
+UnknownInstrument = _py_interop_run.UnknownInstrument
+BaseTileType = _py_interop_run.BaseTileType
+BaseCycleType = _py_interop_run.BaseCycleType
+BaseReadType = _py_interop_run.BaseReadType
+BaseLaneType = _py_interop_run.BaseLaneType
+BaseRunType = _py_interop_run.BaseRunType
+BaseMetricCount = _py_interop_run.BaseMetricCount
+UnknownBaseType = _py_interop_run.UnknownBaseType
+Red = _py_interop_run.Red
+Green = _py_interop_run.Green
+Blue = _py_interop_run.Blue
+Black = _py_interop_run.Black
+PlotColorCount = _py_interop_run.PlotColorCount
+UnknownColor = _py_interop_run.UnknownColor
+Centered = _py_interop_run.Centered
+Shifted = _py_interop_run.Shifted
+UnknownBarPlotOption = _py_interop_run.UnknownBarPlotOption
+IdType = _py_interop_run.IdType
+ValueType = _py_interop_run.ValueType
+StructType = _py_interop_run.StructType
+ChannelArray = _py_interop_run.ChannelArray
+BaseArray = _py_interop_run.BaseArray
+MetricDataCount = _py_interop_run.MetricDataCount
+UnknownMetricData = _py_interop_run.UnknownMetricData
+TileFeature = _py_interop_run.TileFeature
+CycleFeature = _py_interop_run.CycleFeature
+ReadFeature = _py_interop_run.ReadFeature
+BaseFeature = _py_interop_run.BaseFeature
+ChannelFeature = _py_interop_run.ChannelFeature
+LaneFeature = _py_interop_run.LaneFeature
+DiskFeature = _py_interop_run.DiskFeature
+UnknownMetricFeature = _py_interop_run.UnknownMetricFeature
+FlowcellPlot = _py_interop_run.FlowcellPlot
+ByCyclePlot = _py_interop_run.ByCyclePlot
+ByLanePlot = _py_interop_run.ByLanePlot
+QHistogramPlot = _py_interop_run.QHistogramPlot
+QHeatmapPlot = _py_interop_run.QHeatmapPlot
+SampleQCPlot = _py_interop_run.SampleQCPlot
+UnknownPlotType = _py_interop_run.UnknownPlotType
+class cycle_range(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _py_interop_run.cycle_range_swiginit(self, _py_interop_run.new_cycle_range(*args))
+
+    def first_cycle(self, *args):
+        return _py_interop_run.cycle_range_first_cycle(self, *args)
+
+    def last_cycle(self, *args):
+        return _py_interop_run.cycle_range_last_cycle(self, *args)
+
+    def empty(self):
+        return _py_interop_run.cycle_range_empty(self)
+
+    def update(self, *args):
+        return _py_interop_run.cycle_range_update(self, *args)
+    __swig_destroy__ = _py_interop_run.delete_cycle_range
+
+# Register cycle_range in _py_interop_run:
+_py_interop_run.cycle_range_swigregister(cycle_range)
+
+def subtract(lhs, first_cycle_of_read):
+    return _py_interop_run.subtract(lhs, first_cycle_of_read)
+
+class read_info(cycle_range):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, number=0, first_cycle=0, last_cycle=0, is_index=False, is_reverse_complement=False):
+        _py_interop_run.read_info_swiginit(self, _py_interop_run.new_read_info(number, first_cycle, last_cycle, is_index, is_reverse_complement))
+
+    def number(self):
+        return _py_interop_run.read_info_number(self)
+
+    def is_index(self):
+        return _py_interop_run.read_info_is_index(self)
+
+    def is_reverse_complement(self):
+        return _py_interop_run.read_info_is_reverse_complement(self)
+
+    def total_cycles(self):
+        return _py_interop_run.read_info_total_cycles(self)
+
+    def useable_cycles(self):
+        return _py_interop_run.read_info_useable_cycles(self)
+    __swig_destroy__ = _py_interop_run.delete_read_info
+
+# Register read_info in _py_interop_run:
+_py_interop_run.read_info_swigregister(read_info)
+
+class flowcell_layout(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _py_interop_run.flowcell_layout_swiginit(self, _py_interop_run.new_flowcell_layout(*args))
+
+    def supports_multisurface(self):
+        return _py_interop_run.flowcell_layout_supports_multisurface(self)
+
+    def surface_list(self):
+        return _py_interop_run.flowcell_layout_surface_list(self)
+
+    def total_number_of_sections(self):
+        return _py_interop_run.flowcell_layout_total_number_of_sections(self)
+
+    def naming_method(self):
+        return _py_interop_run.flowcell_layout_naming_method(self)
+
+    def tiles(self):
+        return _py_interop_run.flowcell_layout_tiles(self)
+
+    def barcode(self):
+        return _py_interop_run.flowcell_layout_barcode(self)
+
+    def total_swaths(self, all_surfaces):
+        return _py_interop_run.flowcell_layout_total_swaths(self, all_surfaces)
+
+    def tiles_per_lane(self):
+        return _py_interop_run.flowcell_layout_tiles_per_lane(self)
+
+    def total_tiles(self):
+        return _py_interop_run.flowcell_layout_total_tiles(self)
+
+    def set_naming_method(self, naming_method):
+        return _py_interop_run.flowcell_layout_set_naming_method(self, naming_method)
+
+    def lane_count(self, *args):
+        return _py_interop_run.flowcell_layout_lane_count(self, *args)
+
+    def surface_count(self, *args):
+        return _py_interop_run.flowcell_layout_surface_count(self, *args)
+
+    def swath_count(self, *args):
+        return _py_interop_run.flowcell_layout_swath_count(self, *args)
+
+    def tile_count(self, *args):
+        return _py_interop_run.flowcell_layout_tile_count(self, *args)
+
+    def sections_per_lane(self, *args):
+        return _py_interop_run.flowcell_layout_sections_per_lane(self, *args)
+
+    def lanes_per_section(self, *args):
+        return _py_interop_run.flowcell_layout_lanes_per_section(self, *args)
+    __swig_destroy__ = _py_interop_run.delete_flowcell_layout
+
+# Register flowcell_layout in _py_interop_run:
+_py_interop_run.flowcell_layout_swigregister(flowcell_layout)
+
+class image_dimensions(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, width=0, height=0):
+        _py_interop_run.image_dimensions_swiginit(self, _py_interop_run.new_image_dimensions(width, height))
+
+    def width(self):
+        return _py_interop_run.image_dimensions_width(self)
+
+    def height(self):
+        return _py_interop_run.image_dimensions_height(self)
+    __swig_destroy__ = _py_interop_run.delete_image_dimensions
+
+# Register image_dimensions in _py_interop_run:
+_py_interop_run.image_dimensions_swigregister(image_dimensions)
+
+class info(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _py_interop_run.info_swiginit(self, _py_interop_run.new_info(*args))
+
+    def validate_tiles(self):
+        return _py_interop_run.info_validate_tiles(self)
+
+    def validate(self, *args):
+        return _py_interop_run.info_validate(self, *args)
+
+    def validate_cycle(self, lane, tile, cycle, metric_name):
+        return _py_interop_run.info_validate_cycle(self, lane, tile, cycle, metric_name)
+
+    def validate_read(self, lane, tile, read, metric_name):
+        return _py_interop_run.info_validate_read(self, lane, tile, read, metric_name)
+
+    def instrument_name(self):
+        return _py_interop_run.info_instrument_name(self)
+
+    def flowcell_id(self):
+        return _py_interop_run.info_flowcell_id(self)
+
+    def run_number(self):
+        return _py_interop_run.info_run_number(self)
+
+    def name(self):
+        return _py_interop_run.info_name(self)
+
+    def date(self):
+        return _py_interop_run.info_date(self)
+
+    def version(self):
+        return _py_interop_run.info_version(self)
+
+    def dimensions_of_image(self):
+        return _py_interop_run.info_dimensions_of_image(self)
+
+    def is_indexed(self):
+        return _py_interop_run.info_is_indexed(self)
+
+    def is_paired_end(self):
+        return _py_interop_run.info_is_paired_end(self)
+
+    def is_last_cycle_of_read(self, cycle):
+        return _py_interop_run.info_is_last_cycle_of_read(self, cycle)
+
+    def cycle_within_read(self, cycle):
+        return _py_interop_run.info_cycle_within_read(self, cycle)
+
+    def read(self, *args):
+        return _py_interop_run.info_read(self, *args)
+
+    def channels(self, *args):
+        return _py_interop_run.info_channels(self, *args)
+
+    def reads(self, *args):
+        return _py_interop_run.info_reads(self, *args)
+
+    def set_naming_method(self, naming_method):
+        return _py_interop_run.info_set_naming_method(self, naming_method)
+
+    def flowcell(self, *args):
+        return _py_interop_run.info_flowcell(self, *args)
+
+    def total_cycles(self):
+        return _py_interop_run.info_total_cycles(self)
+
+    def useable_cycles(self):
+        return _py_interop_run.info_useable_cycles(self)
+
+    def read_file(self, filename):
+        return _py_interop_run.info_read_file(self, filename)
+
+    def parse(self, data):
+        return _py_interop_run.info_parse(self, data)
+
+    def write(self, filename):
+        return _py_interop_run.info_write(self, filename)
+    __swig_destroy__ = _py_interop_run.delete_info
+
+# Register info in _py_interop_run:
+_py_interop_run.info_swigregister(info)
+
+class parameters(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _py_interop_run.parameters_swiginit(self, _py_interop_run.new_parameters(*args))
+
+    def instrument_type(self):
+        return _py_interop_run.parameters_instrument_type(self)
+
+    def version(self):
+        return _py_interop_run.parameters_version(self)
+
+    def read(self, run_folder):
+        return _py_interop_run.parameters_read(self, run_folder)
+
+    def read_file(self, filename):
+        return _py_interop_run.parameters_read_file(self, filename)
+
+    def parse(self, data):
+        return _py_interop_run.parameters_parse(self, data)
+    __swig_destroy__ = _py_interop_run.delete_parameters
+
+# Register parameters in _py_interop_run:
+_py_interop_run.parameters_swigregister(parameters)
+
+class read_info_vector(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _py_interop_run.read_info_vector___nonzero__(self)
+
+    def __bool__(self):
+        return _py_interop_run.read_info_vector___bool__(self)
+
+    def __len__(self):
+        return _py_interop_run.read_info_vector___len__(self)
+
+    def __getslice__(self, i, j):
+        return _py_interop_run.read_info_vector___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _py_interop_run.read_info_vector___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _py_interop_run.read_info_vector___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _py_interop_run.read_info_vector___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _py_interop_run.read_info_vector___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _py_interop_run.read_info_vector___setitem__(self, *args)
+
+    def pop(self):
+        return _py_interop_run.read_info_vector_pop(self)
+
+    def append(self, x):
+        return _py_interop_run.read_info_vector_append(self, x)
+
+    def empty(self):
+        return _py_interop_run.read_info_vector_empty(self)
+
+    def size(self):
+        return _py_interop_run.read_info_vector_size(self)
+
+    def swap(self, v):
+        return _py_interop_run.read_info_vector_swap(self, v)
+
+    def rbegin(self):
+        return _py_interop_run.read_info_vector_rbegin(self)
+
+    def rend(self):
+        return _py_interop_run.read_info_vector_rend(self)
+
+    def clear(self):
+        return _py_interop_run.read_info_vector_clear(self)
+
+    def get_allocator(self):
+        return _py_interop_run.read_info_vector_get_allocator(self)
+
+    def pop_back(self):
+        return _py_interop_run.read_info_vector_pop_back(self)
+
+    def erase(self, *args):
+        return _py_interop_run.read_info_vector_erase(self, *args)
+
+    def __init__(self, *args):
+        _py_interop_run.read_info_vector_swiginit(self, _py_interop_run.new_read_info_vector(*args))
+
+    def push_back(self, x):
+        return _py_interop_run.read_info_vector_push_back(self, x)
+
+    def front(self):
+        return _py_interop_run.read_info_vector_front(self)
+
+    def back(self):
+        return _py_interop_run.read_info_vector_back(self)
+
+    def assign(self, n, x):
+        return _py_interop_run.read_info_vector_assign(self, n, x)
+
+    def resize(self, *args):
+        return _py_interop_run.read_info_vector_resize(self, *args)
+
+    def insert(self, *args):
+        return _py_interop_run.read_info_vector_insert(self, *args)
+
+    def reserve(self, n):
+        return _py_interop_run.read_info_vector_reserve(self, n)
+
+    def capacity(self):
+        return _py_interop_run.read_info_vector_capacity(self)
+    __swig_destroy__ = _py_interop_run.delete_read_info_vector
+
+# Register read_info_vector in _py_interop_run:
+_py_interop_run.read_info_vector_swigregister(read_info_vector)
+
+
+def list_metric_type(vec, skip=0):
+    return _py_interop_run.list_metric_type(vec, skip)
+
+def parse_metric_type(name):
+    return _py_interop_run.parse_metric_type(name)
+
+def to_string_metric_type(value):
+    return _py_interop_run.to_string_metric_type(value)
+
+def list_metric_group(vec, skip=0):
+    return _py_interop_run.list_metric_group(vec, skip)
+
+def parse_metric_group(name):
+    return _py_interop_run.parse_metric_group(name)
+
+def to_string_metric_group(value):
+    return _py_interop_run.to_string_metric_group(value)
+
+def list_tile_naming_method(vec, skip=0):
+    return _py_interop_run.list_tile_naming_method(vec, skip)
+
+def parse_tile_naming_method(name):
+    return _py_interop_run.parse_tile_naming_method(name)
+
+def to_string_tile_naming_method(value):
+    return _py_interop_run.to_string_tile_naming_method(value)
+
+def list_dna_bases(vec, skip=0):
+    return _py_interop_run.list_dna_bases(vec, skip)
+
+def parse_dna_bases(name):
+    return _py_interop_run.parse_dna_bases(name)
+
+def to_string_dna_bases(value):
+    return _py_interop_run.to_string_dna_bases(value)
+
+def list_surface_type(vec, skip=0):
+    return _py_interop_run.list_surface_type(vec, skip)
+
+def parse_surface_type(name):
+    return _py_interop_run.parse_surface_type(name)
+
+def to_string_surface_type(value):
+    return _py_interop_run.to_string_surface_type(value)
+
+def list_instrument_type(vec, skip=0):
+    return _py_interop_run.list_instrument_type(vec, skip)
+
+def parse_instrument_type(name):
+    return _py_interop_run.parse_instrument_type(name)
+
+def to_string_instrument_type(value):
+    return _py_interop_run.to_string_instrument_type(value)
+
+def list_metric_base_type(vec, skip=0):
+    return _py_interop_run.list_metric_base_type(vec, skip)
+
+def parse_metric_base_type(name):
+    return _py_interop_run.parse_metric_base_type(name)
+
+def to_string_metric_base_type(value):
+    return _py_interop_run.to_string_metric_base_type(value)
+
+def list_plot_colors(vec, skip=0):
+    return _py_interop_run.list_plot_colors(vec, skip)
+
+def parse_plot_colors(name):
+    return _py_interop_run.parse_plot_colors(name)
+
+def to_string_plot_colors(value):
+    return _py_interop_run.to_string_plot_colors(value)
+
+def list_bar_plot_options(vec, skip=0):
+    return _py_interop_run.list_bar_plot_options(vec, skip)
+
+def parse_bar_plot_options(name):
+    return _py_interop_run.parse_bar_plot_options(name)
+
+def to_string_bar_plot_options(value):
+    return _py_interop_run.to_string_bar_plot_options(value)
+
+def list_metric_data(vec, skip=0):
+    return _py_interop_run.list_metric_data(vec, skip)
+
+def parse_metric_data(name):
+    return _py_interop_run.parse_metric_data(name)
+
+def to_string_metric_data(value):
+    return _py_interop_run.to_string_metric_data(value)
+
+def list_metric_feature_type(vec, skip=0):
+    return _py_interop_run.list_metric_feature_type(vec, skip)
+
+def parse_metric_feature_type(name):
+    return _py_interop_run.parse_metric_feature_type(name)
+
+def to_string_metric_feature_type(value):
+    return _py_interop_run.to_string_metric_feature_type(value)
+
+
```

## interop/py_interop_run_metrics.py

```diff
@@ -1,419 +1,428 @@
-# This file was automatically generated by SWIG (https://www.swig.org).
-# Version 4.1.1
-#
-# Do not make changes to this file unless you know what you are doing - modify
-# the SWIG interface file instead.
-
-from sys import version_info as _swig_python_version_info
-# Import the low-level C/C++ module
-if __package__ or "." in __name__:
-    from . import _py_interop_run_metrics
-else:
-    import _py_interop_run_metrics
-
-try:
-    import builtins as __builtin__
-except ImportError:
-    import __builtin__
-
-def _swig_repr(self):
-    try:
-        strthis = "proxy of " + self.this.__repr__()
-    except __builtin__.Exception:
-        strthis = ""
-    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)
-
-
-def _swig_setattr_nondynamic_instance_variable(set):
-    def set_instance_attr(self, name, value):
-        if name == "this":
-            set(self, name, value)
-        elif name == "thisown":
-            self.this.own(value)
-        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
-            set(self, name, value)
-        else:
-            raise AttributeError("You cannot add instance attributes to %s" % self)
-    return set_instance_attr
-
-
-def _swig_setattr_nondynamic_class_variable(set):
-    def set_class_attr(cls, name, value):
-        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
-            set(cls, name, value)
-        else:
-            raise AttributeError("You cannot add class attributes to %s" % cls)
-    return set_class_attr
-
-
-def _swig_add_metaclass(metaclass):
-    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
-    def wrapper(cls):
-        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
-    return wrapper
-
-
-class _SwigNonDynamicMeta(type):
-    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
-    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)
-
-
-class SwigPyIterator(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined - class is abstract")
-    __repr__ = _swig_repr
-    __swig_destroy__ = _py_interop_run_metrics.delete_SwigPyIterator
-
-    def value(self):
-        return _py_interop_run_metrics.SwigPyIterator_value(self)
-
-    def incr(self, n=1):
-        return _py_interop_run_metrics.SwigPyIterator_incr(self, n)
-
-    def decr(self, n=1):
-        return _py_interop_run_metrics.SwigPyIterator_decr(self, n)
-
-    def distance(self, x):
-        return _py_interop_run_metrics.SwigPyIterator_distance(self, x)
-
-    def equal(self, x):
-        return _py_interop_run_metrics.SwigPyIterator_equal(self, x)
-
-    def copy(self):
-        return _py_interop_run_metrics.SwigPyIterator_copy(self)
-
-    def next(self):
-        return _py_interop_run_metrics.SwigPyIterator_next(self)
-
-    def __next__(self):
-        return _py_interop_run_metrics.SwigPyIterator___next__(self)
-
-    def previous(self):
-        return _py_interop_run_metrics.SwigPyIterator_previous(self)
-
-    def advance(self, n):
-        return _py_interop_run_metrics.SwigPyIterator_advance(self, n)
-
-    def __eq__(self, x):
-        return _py_interop_run_metrics.SwigPyIterator___eq__(self, x)
-
-    def __ne__(self, x):
-        return _py_interop_run_metrics.SwigPyIterator___ne__(self, x)
-
-    def __iadd__(self, n):
-        return _py_interop_run_metrics.SwigPyIterator___iadd__(self, n)
-
-    def __isub__(self, n):
-        return _py_interop_run_metrics.SwigPyIterator___isub__(self, n)
-
-    def __add__(self, n):
-        return _py_interop_run_metrics.SwigPyIterator___add__(self, n)
-
-    def __sub__(self, *args):
-        return _py_interop_run_metrics.SwigPyIterator___sub__(self, *args)
-    def __iter__(self):
-        return self
-
-# Register SwigPyIterator in _py_interop_run_metrics:
-_py_interop_run_metrics.SwigPyIterator_swigregister(SwigPyIterator)
-import interop.py_interop_run
-import interop.py_interop_comm
-import interop.py_interop_metrics
-class invalid_channel_exception(interop.py_interop_run.base_exception):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, mesg):
-        _py_interop_run_metrics.invalid_channel_exception_swiginit(self, _py_interop_run_metrics.new_invalid_channel_exception(mesg))
-
-    def __str__(self):
-        return _py_interop_run_metrics.invalid_channel_exception___str__(self)
-    __swig_destroy__ = _py_interop_run_metrics.delete_invalid_channel_exception
-
-# Register invalid_channel_exception in _py_interop_run_metrics:
-_py_interop_run_metrics.invalid_channel_exception_swigregister(invalid_channel_exception)
-class invalid_metric_type(interop.py_interop_run.base_exception):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, mesg):
-        _py_interop_run_metrics.invalid_metric_type_swiginit(self, _py_interop_run_metrics.new_invalid_metric_type(mesg))
-
-    def __str__(self):
-        return _py_interop_run_metrics.invalid_metric_type___str__(self)
-    __swig_destroy__ = _py_interop_run_metrics.delete_invalid_metric_type
-
-# Register invalid_metric_type in _py_interop_run_metrics:
-_py_interop_run_metrics.invalid_metric_type_swigregister(invalid_metric_type)
-class invalid_parameter(interop.py_interop_run.base_exception):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, mesg):
-        _py_interop_run_metrics.invalid_parameter_swiginit(self, _py_interop_run_metrics.new_invalid_parameter(mesg))
-
-    def __str__(self):
-        return _py_interop_run_metrics.invalid_parameter___str__(self)
-    __swig_destroy__ = _py_interop_run_metrics.delete_invalid_parameter
-
-# Register invalid_parameter in _py_interop_run_metrics:
-_py_interop_run_metrics.invalid_parameter_swigregister(invalid_parameter)
-
-def copy_focus(metrics, focus_scores, channel, n):
-    return _py_interop_run_metrics.copy_focus(metrics, focus_scores, channel, n)
-
-def count_q_metric_bins(*args):
-    return _py_interop_run_metrics.count_q_metric_bins(*args)
-
-def populate_cumulative_distribution(*args):
-    return _py_interop_run_metrics.populate_cumulative_distribution(*args)
-
-def requires_legacy_bins(count):
-    return _py_interop_run_metrics.requires_legacy_bins(count)
-
-def compress_q_metrics(*args):
-    return _py_interop_run_metrics.compress_q_metrics(*args)
-
-def populate_legacy_q_score_bins(*args):
-    return _py_interop_run_metrics.populate_legacy_q_score_bins(*args)
-
-def count_qvals(*args):
-    return _py_interop_run_metrics.count_qvals(*args)
-
-def is_compressed(*args):
-    return _py_interop_run_metrics.is_compressed(*args)
-
-def max_qval(*args):
-    return _py_interop_run_metrics.max_qval(*args)
-
-def index_for_q_value(*args):
-    return _py_interop_run_metrics.index_for_q_value(*args)
-
-def create_collapse_q_metrics(metric_set, collapsed):
-    return _py_interop_run_metrics.create_collapse_q_metrics(metric_set, collapsed)
-
-def create_q_metrics_by_lane(metric_set, bylane, instrument):
-    return _py_interop_run_metrics.create_q_metrics_by_lane(metric_set, bylane, instrument)
-
-def to_group(type):
-    return _py_interop_run_metrics.to_group(type)
-
-def to_description(type):
-    return _py_interop_run_metrics.to_description(type)
-
-def list_descriptions(types):
-    return _py_interop_run_metrics.list_descriptions(types)
-
-def to_feature(type):
-    return _py_interop_run_metrics.to_feature(type)
-
-def to_group_feature(type):
-    return _py_interop_run_metrics.to_group_feature(type)
-
-def is_base_metric(type):
-    return _py_interop_run_metrics.is_base_metric(type)
-
-def is_channel_metric(type):
-    return _py_interop_run_metrics.is_channel_metric(type)
-
-def is_read_metric(type):
-    return _py_interop_run_metrics.is_read_metric(type)
-
-def is_cycle_metric(type):
-    return _py_interop_run_metrics.is_cycle_metric(type)
-
-def is_tile_metric(type):
-    return _py_interop_run_metrics.is_tile_metric(type)
-
-def list_metrics_to_load_metric_group(*args):
-    return _py_interop_run_metrics.list_metrics_to_load_metric_group(*args)
-
-def list_metrics_to_load_by_group(*args):
-    return _py_interop_run_metrics.list_metrics_to_load_by_group(*args)
-
-def list_metrics_to_load_by_type(*args):
-    return _py_interop_run_metrics.list_metrics_to_load_by_type(*args)
-
-def list_metrics_to_load_metric_groups(*args):
-    return _py_interop_run_metrics.list_metrics_to_load_metric_groups(*args)
-
-def list_metrics_to_load_by_groups(*args):
-    return _py_interop_run_metrics.list_metrics_to_load_by_groups(*args)
-
-def list_metrics_to_load_by_types(*args):
-    return _py_interop_run_metrics.list_metrics_to_load_by_types(*args)
-
-def list_metrics_to_load(*args):
-    return _py_interop_run_metrics.list_metrics_to_load(*args)
-
-def list_summary_metric_groups(*args):
-    return _py_interop_run_metrics.list_summary_metric_groups(*args)
-
-def list_index_summary_metric_groups(groups):
-    return _py_interop_run_metrics.list_index_summary_metric_groups(groups)
-
-def list_summary_metrics_to_load(*args):
-    return _py_interop_run_metrics.list_summary_metrics_to_load(*args)
-
-def list_index_metrics_to_load(valid_to_load):
-    return _py_interop_run_metrics.list_index_metrics_to_load(valid_to_load)
-
-def list_analysis_metrics_to_load(valid_to_load):
-    return _py_interop_run_metrics.list_analysis_metrics_to_load(valid_to_load)
-class run_metrics(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _py_interop_run_metrics.run_metrics_swiginit(self, _py_interop_run_metrics.new_run_metrics(*args))
-
-    def read(self, *args):
-        return _py_interop_run_metrics.run_metrics_read(self, *args)
-
-    def read_xml(self, run_folder):
-        return _py_interop_run_metrics.run_metrics_read_xml(self, run_folder)
-
-    def read_run_info(self, run_folder):
-        return _py_interop_run_metrics.run_metrics_read_run_info(self, run_folder)
-
-    def read_run_parameters(self, run_folder, force_load=False):
-        return _py_interop_run_metrics.run_metrics_read_run_parameters(self, run_folder, force_load)
-
-    def finalize_after_load(self, *args):
-        return _py_interop_run_metrics.run_metrics_finalize_after_load(self, *args)
-
-    def empty(self):
-        return _py_interop_run_metrics.run_metrics_empty(self)
-
-    def legacy_channel_update(self, type):
-        return _py_interop_run_metrics.run_metrics_legacy_channel_update(self, type)
-
-    def set_naming_method(self, naming_method):
-        return _py_interop_run_metrics.run_metrics_set_naming_method(self, naming_method)
-
-    def count_legacy_bins(self, *args):
-        return _py_interop_run_metrics.run_metrics_count_legacy_bins(self, *args)
-
-    def is_run_parameters_required(self, *args):
-        return _py_interop_run_metrics.run_metrics_is_run_parameters_required(self, *args)
-
-    def run_info(self, *args):
-        return _py_interop_run_metrics.run_metrics_run_info(self, *args)
-
-    def run_parameters(self, *args):
-        return _py_interop_run_metrics.run_metrics_run_parameters(self, *args)
-
-    def list_filenames(self, *args):
-        return _py_interop_run_metrics.run_metrics_list_filenames(self, *args)
-
-    def copy_tile(self, metrics, tile_id):
-        return _py_interop_run_metrics.run_metrics_copy_tile(self, metrics, tile_id)
-
-    def append_tiles(self, metrics, tile_id):
-        return _py_interop_run_metrics.run_metrics_append_tiles(self, metrics, tile_id)
-
-    def check_for_data_sources(self, run_folder, last_cycle):
-        return _py_interop_run_metrics.run_metrics_check_for_data_sources(self, run_folder, last_cycle)
-
-    def read_metrics(self, *args):
-        return _py_interop_run_metrics.run_metrics_read_metrics(self, *args)
-
-    def write_metrics(self, run_folder, use_out=True):
-        return _py_interop_run_metrics.run_metrics_write_metrics(self, run_folder, use_out)
-
-    def read_metrics_from_buffer(self, group, buffer):
-        return _py_interop_run_metrics.run_metrics_read_metrics_from_buffer(self, group, buffer)
-
-    def write_metrics_to_buffer(self, group, buffer):
-        return _py_interop_run_metrics.run_metrics_write_metrics_to_buffer(self, group, buffer)
-
-    def calculate_buffer_size(self, group):
-        return _py_interop_run_metrics.run_metrics_calculate_buffer_size(self, group)
-
-    def validate(self):
-        return _py_interop_run_metrics.run_metrics_validate(self)
-
-    def is_group_empty(self, *args):
-        return _py_interop_run_metrics.run_metrics_is_group_empty(self, *args)
-
-    def populate_id_map(self, *args):
-        return _py_interop_run_metrics.run_metrics_populate_id_map(self, *args)
-
-    def sort(self):
-        return _py_interop_run_metrics.run_metrics_sort(self)
-
-    def clear(self):
-        return _py_interop_run_metrics.run_metrics_clear(self)
-
-    def set_corrected_intensity_metric_set(self, metrics):
-        return _py_interop_run_metrics.run_metrics_set_corrected_intensity_metric_set(self, metrics)
-
-    def corrected_intensity_metric_set(self):
-        return _py_interop_run_metrics.run_metrics_corrected_intensity_metric_set(self)
-
-    def set_error_metric_set(self, metrics):
-        return _py_interop_run_metrics.run_metrics_set_error_metric_set(self, metrics)
-
-    def error_metric_set(self):
-        return _py_interop_run_metrics.run_metrics_error_metric_set(self)
-
-    def set_extended_tile_metric_set(self, metrics):
-        return _py_interop_run_metrics.run_metrics_set_extended_tile_metric_set(self, metrics)
-
-    def extended_tile_metric_set(self):
-        return _py_interop_run_metrics.run_metrics_extended_tile_metric_set(self)
-
-    def set_extraction_metric_set(self, metrics):
-        return _py_interop_run_metrics.run_metrics_set_extraction_metric_set(self, metrics)
-
-    def extraction_metric_set(self):
-        return _py_interop_run_metrics.run_metrics_extraction_metric_set(self)
-
-    def set_image_metric_set(self, metrics):
-        return _py_interop_run_metrics.run_metrics_set_image_metric_set(self, metrics)
-
-    def image_metric_set(self):
-        return _py_interop_run_metrics.run_metrics_image_metric_set(self)
-
-    def set_q_metric_set(self, metrics):
-        return _py_interop_run_metrics.run_metrics_set_q_metric_set(self, metrics)
-
-    def q_metric_set(self):
-        return _py_interop_run_metrics.run_metrics_q_metric_set(self)
-
-    def set_tile_metric_set(self, metrics):
-        return _py_interop_run_metrics.run_metrics_set_tile_metric_set(self, metrics)
-
-    def tile_metric_set(self):
-        return _py_interop_run_metrics.run_metrics_tile_metric_set(self)
-
-    def set_index_metric_set(self, metrics):
-        return _py_interop_run_metrics.run_metrics_set_index_metric_set(self, metrics)
-
-    def index_metric_set(self):
-        return _py_interop_run_metrics.run_metrics_index_metric_set(self)
-
-    def set_q_collapsed_metric_set(self, metrics):
-        return _py_interop_run_metrics.run_metrics_set_q_collapsed_metric_set(self, metrics)
-
-    def q_collapsed_metric_set(self):
-        return _py_interop_run_metrics.run_metrics_q_collapsed_metric_set(self)
-
-    def set_q_by_lane_metric_set(self, metrics):
-        return _py_interop_run_metrics.run_metrics_set_q_by_lane_metric_set(self, metrics)
-
-    def q_by_lane_metric_set(self):
-        return _py_interop_run_metrics.run_metrics_q_by_lane_metric_set(self)
-
-    def set_summary_run_metric_set(self, metrics):
-        return _py_interop_run_metrics.run_metrics_set_summary_run_metric_set(self, metrics)
-
-    def summary_run_metric_set(self):
-        return _py_interop_run_metrics.run_metrics_summary_run_metric_set(self)
-    __swig_destroy__ = _py_interop_run_metrics.delete_run_metrics
-
-# Register run_metrics in _py_interop_run_metrics:
-_py_interop_run_metrics.run_metrics_swigregister(run_metrics)
-
+# This file was automatically generated by SWIG (http://www.swig.org).
+# Version 4.0.2
+#
+# Do not make changes to this file unless you know what you are doing--modify
+# the SWIG interface file instead.
+
+from sys import version_info as _swig_python_version_info
+if _swig_python_version_info < (2, 7, 0):
+    raise RuntimeError("Python 2.7 or later required")
+
+# Import the low-level C/C++ module
+if __package__ or "." in __name__:
+    from . import _py_interop_run_metrics
+else:
+    import _py_interop_run_metrics
+
+try:
+    import builtins as __builtin__
+except ImportError:
+    import __builtin__
+
+def _swig_repr(self):
+    try:
+        strthis = "proxy of " + self.this.__repr__()
+    except __builtin__.Exception:
+        strthis = ""
+    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)
+
+
+def _swig_setattr_nondynamic_instance_variable(set):
+    def set_instance_attr(self, name, value):
+        if name == "thisown":
+            self.this.own(value)
+        elif name == "this":
+            set(self, name, value)
+        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
+            set(self, name, value)
+        else:
+            raise AttributeError("You cannot add instance attributes to %s" % self)
+    return set_instance_attr
+
+
+def _swig_setattr_nondynamic_class_variable(set):
+    def set_class_attr(cls, name, value):
+        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
+            set(cls, name, value)
+        else:
+            raise AttributeError("You cannot add class attributes to %s" % cls)
+    return set_class_attr
+
+
+def _swig_add_metaclass(metaclass):
+    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
+    def wrapper(cls):
+        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
+    return wrapper
+
+
+class _SwigNonDynamicMeta(type):
+    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
+    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)
+
+
+class SwigPyIterator(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined - class is abstract")
+    __repr__ = _swig_repr
+    __swig_destroy__ = _py_interop_run_metrics.delete_SwigPyIterator
+
+    def value(self):
+        return _py_interop_run_metrics.SwigPyIterator_value(self)
+
+    def incr(self, n=1):
+        return _py_interop_run_metrics.SwigPyIterator_incr(self, n)
+
+    def decr(self, n=1):
+        return _py_interop_run_metrics.SwigPyIterator_decr(self, n)
+
+    def distance(self, x):
+        return _py_interop_run_metrics.SwigPyIterator_distance(self, x)
+
+    def equal(self, x):
+        return _py_interop_run_metrics.SwigPyIterator_equal(self, x)
+
+    def copy(self):
+        return _py_interop_run_metrics.SwigPyIterator_copy(self)
+
+    def next(self):
+        return _py_interop_run_metrics.SwigPyIterator_next(self)
+
+    def __next__(self):
+        return _py_interop_run_metrics.SwigPyIterator___next__(self)
+
+    def previous(self):
+        return _py_interop_run_metrics.SwigPyIterator_previous(self)
+
+    def advance(self, n):
+        return _py_interop_run_metrics.SwigPyIterator_advance(self, n)
+
+    def __eq__(self, x):
+        return _py_interop_run_metrics.SwigPyIterator___eq__(self, x)
+
+    def __ne__(self, x):
+        return _py_interop_run_metrics.SwigPyIterator___ne__(self, x)
+
+    def __iadd__(self, n):
+        return _py_interop_run_metrics.SwigPyIterator___iadd__(self, n)
+
+    def __isub__(self, n):
+        return _py_interop_run_metrics.SwigPyIterator___isub__(self, n)
+
+    def __add__(self, n):
+        return _py_interop_run_metrics.SwigPyIterator___add__(self, n)
+
+    def __sub__(self, *args):
+        return _py_interop_run_metrics.SwigPyIterator___sub__(self, *args)
+    def __iter__(self):
+        return self
+
+# Register SwigPyIterator in _py_interop_run_metrics:
+_py_interop_run_metrics.SwigPyIterator_swigregister(SwigPyIterator)
+
+import interop.py_interop_run
+import interop.py_interop_comm
+import interop.py_interop_metrics
+class invalid_channel_exception(interop.py_interop_run.base_exception):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, mesg):
+        _py_interop_run_metrics.invalid_channel_exception_swiginit(self, _py_interop_run_metrics.new_invalid_channel_exception(mesg))
+
+    def __str__(self):
+        return _py_interop_run_metrics.invalid_channel_exception___str__(self)
+    __swig_destroy__ = _py_interop_run_metrics.delete_invalid_channel_exception
+
+# Register invalid_channel_exception in _py_interop_run_metrics:
+_py_interop_run_metrics.invalid_channel_exception_swigregister(invalid_channel_exception)
+
+class invalid_metric_type(interop.py_interop_run.base_exception):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, mesg):
+        _py_interop_run_metrics.invalid_metric_type_swiginit(self, _py_interop_run_metrics.new_invalid_metric_type(mesg))
+
+    def __str__(self):
+        return _py_interop_run_metrics.invalid_metric_type___str__(self)
+    __swig_destroy__ = _py_interop_run_metrics.delete_invalid_metric_type
+
+# Register invalid_metric_type in _py_interop_run_metrics:
+_py_interop_run_metrics.invalid_metric_type_swigregister(invalid_metric_type)
+
+class invalid_parameter(interop.py_interop_run.base_exception):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, mesg):
+        _py_interop_run_metrics.invalid_parameter_swiginit(self, _py_interop_run_metrics.new_invalid_parameter(mesg))
+
+    def __str__(self):
+        return _py_interop_run_metrics.invalid_parameter___str__(self)
+    __swig_destroy__ = _py_interop_run_metrics.delete_invalid_parameter
+
+# Register invalid_parameter in _py_interop_run_metrics:
+_py_interop_run_metrics.invalid_parameter_swigregister(invalid_parameter)
+
+
+def copy_focus(metrics, focus_scores, channel, n):
+    return _py_interop_run_metrics.copy_focus(metrics, focus_scores, channel, n)
+
+def count_q_metric_bins(*args):
+    return _py_interop_run_metrics.count_q_metric_bins(*args)
+
+def populate_cumulative_distribution(*args):
+    return _py_interop_run_metrics.populate_cumulative_distribution(*args)
+
+def requires_legacy_bins(count):
+    return _py_interop_run_metrics.requires_legacy_bins(count)
+
+def compress_q_metrics(*args):
+    return _py_interop_run_metrics.compress_q_metrics(*args)
+
+def populate_legacy_q_score_bins(*args):
+    return _py_interop_run_metrics.populate_legacy_q_score_bins(*args)
+
+def count_qvals(*args):
+    return _py_interop_run_metrics.count_qvals(*args)
+
+def is_compressed(*args):
+    return _py_interop_run_metrics.is_compressed(*args)
+
+def max_qval(*args):
+    return _py_interop_run_metrics.max_qval(*args)
+
+def index_for_q_value(*args):
+    return _py_interop_run_metrics.index_for_q_value(*args)
+
+def create_collapse_q_metrics(metric_set, collapsed):
+    return _py_interop_run_metrics.create_collapse_q_metrics(metric_set, collapsed)
+
+def create_q_metrics_by_lane(metric_set, bylane, instrument):
+    return _py_interop_run_metrics.create_q_metrics_by_lane(metric_set, bylane, instrument)
+
+def to_group(type):
+    return _py_interop_run_metrics.to_group(type)
+
+def to_description(type):
+    return _py_interop_run_metrics.to_description(type)
+
+def list_descriptions(types):
+    return _py_interop_run_metrics.list_descriptions(types)
+
+def to_feature(type):
+    return _py_interop_run_metrics.to_feature(type)
+
+def to_group_feature(type):
+    return _py_interop_run_metrics.to_group_feature(type)
+
+def is_base_metric(type):
+    return _py_interop_run_metrics.is_base_metric(type)
+
+def is_channel_metric(type):
+    return _py_interop_run_metrics.is_channel_metric(type)
+
+def is_read_metric(type):
+    return _py_interop_run_metrics.is_read_metric(type)
+
+def is_cycle_metric(type):
+    return _py_interop_run_metrics.is_cycle_metric(type)
+
+def is_tile_metric(type):
+    return _py_interop_run_metrics.is_tile_metric(type)
+
+def list_metrics_to_load_metric_group(*args):
+    return _py_interop_run_metrics.list_metrics_to_load_metric_group(*args)
+
+def list_metrics_to_load_by_group(*args):
+    return _py_interop_run_metrics.list_metrics_to_load_by_group(*args)
+
+def list_metrics_to_load_by_type(*args):
+    return _py_interop_run_metrics.list_metrics_to_load_by_type(*args)
+
+def list_metrics_to_load_metric_groups(*args):
+    return _py_interop_run_metrics.list_metrics_to_load_metric_groups(*args)
+
+def list_metrics_to_load_by_groups(*args):
+    return _py_interop_run_metrics.list_metrics_to_load_by_groups(*args)
+
+def list_metrics_to_load_by_types(*args):
+    return _py_interop_run_metrics.list_metrics_to_load_by_types(*args)
+
+def list_metrics_to_load(*args):
+    return _py_interop_run_metrics.list_metrics_to_load(*args)
+
+def list_summary_metric_groups(*args):
+    return _py_interop_run_metrics.list_summary_metric_groups(*args)
+
+def list_index_summary_metric_groups(groups):
+    return _py_interop_run_metrics.list_index_summary_metric_groups(groups)
+
+def list_summary_metrics_to_load(*args):
+    return _py_interop_run_metrics.list_summary_metrics_to_load(*args)
+
+def list_index_metrics_to_load(valid_to_load):
+    return _py_interop_run_metrics.list_index_metrics_to_load(valid_to_load)
+
+def list_analysis_metrics_to_load(valid_to_load):
+    return _py_interop_run_metrics.list_analysis_metrics_to_load(valid_to_load)
+class run_metrics(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _py_interop_run_metrics.run_metrics_swiginit(self, _py_interop_run_metrics.new_run_metrics(*args))
+
+    def read(self, *args):
+        return _py_interop_run_metrics.run_metrics_read(self, *args)
+
+    def read_xml(self, run_folder):
+        return _py_interop_run_metrics.run_metrics_read_xml(self, run_folder)
+
+    def read_run_info(self, run_folder):
+        return _py_interop_run_metrics.run_metrics_read_run_info(self, run_folder)
+
+    def read_run_parameters(self, run_folder, force_load=False):
+        return _py_interop_run_metrics.run_metrics_read_run_parameters(self, run_folder, force_load)
+
+    def finalize_after_load(self, *args):
+        return _py_interop_run_metrics.run_metrics_finalize_after_load(self, *args)
+
+    def empty(self):
+        return _py_interop_run_metrics.run_metrics_empty(self)
+
+    def legacy_channel_update(self, type):
+        return _py_interop_run_metrics.run_metrics_legacy_channel_update(self, type)
+
+    def set_naming_method(self, naming_method):
+        return _py_interop_run_metrics.run_metrics_set_naming_method(self, naming_method)
+
+    def count_legacy_bins(self, *args):
+        return _py_interop_run_metrics.run_metrics_count_legacy_bins(self, *args)
+
+    def is_run_parameters_required(self, *args):
+        return _py_interop_run_metrics.run_metrics_is_run_parameters_required(self, *args)
+
+    def run_info(self, *args):
+        return _py_interop_run_metrics.run_metrics_run_info(self, *args)
+
+    def run_parameters(self, *args):
+        return _py_interop_run_metrics.run_metrics_run_parameters(self, *args)
+
+    def list_filenames(self, *args):
+        return _py_interop_run_metrics.run_metrics_list_filenames(self, *args)
+
+    def copy_tile(self, metrics, tile_id):
+        return _py_interop_run_metrics.run_metrics_copy_tile(self, metrics, tile_id)
+
+    def append_tiles(self, metrics, tile_id):
+        return _py_interop_run_metrics.run_metrics_append_tiles(self, metrics, tile_id)
+
+    def check_for_data_sources(self, run_folder, last_cycle):
+        return _py_interop_run_metrics.run_metrics_check_for_data_sources(self, run_folder, last_cycle)
+
+    def read_metrics(self, *args):
+        return _py_interop_run_metrics.run_metrics_read_metrics(self, *args)
+
+    def write_metrics(self, run_folder, use_out=True):
+        return _py_interop_run_metrics.run_metrics_write_metrics(self, run_folder, use_out)
+
+    def read_metrics_from_buffer(self, group, buffer):
+        return _py_interop_run_metrics.run_metrics_read_metrics_from_buffer(self, group, buffer)
+
+    def write_metrics_to_buffer(self, group, buffer):
+        return _py_interop_run_metrics.run_metrics_write_metrics_to_buffer(self, group, buffer)
+
+    def calculate_buffer_size(self, group):
+        return _py_interop_run_metrics.run_metrics_calculate_buffer_size(self, group)
+
+    def validate(self):
+        return _py_interop_run_metrics.run_metrics_validate(self)
+
+    def is_group_empty(self, *args):
+        return _py_interop_run_metrics.run_metrics_is_group_empty(self, *args)
+
+    def populate_id_map(self, *args):
+        return _py_interop_run_metrics.run_metrics_populate_id_map(self, *args)
+
+    def sort(self):
+        return _py_interop_run_metrics.run_metrics_sort(self)
+
+    def clear(self):
+        return _py_interop_run_metrics.run_metrics_clear(self)
+
+    def set_corrected_intensity_metric_set(self, metrics):
+        return _py_interop_run_metrics.run_metrics_set_corrected_intensity_metric_set(self, metrics)
+
+    def corrected_intensity_metric_set(self):
+        return _py_interop_run_metrics.run_metrics_corrected_intensity_metric_set(self)
+
+    def set_error_metric_set(self, metrics):
+        return _py_interop_run_metrics.run_metrics_set_error_metric_set(self, metrics)
+
+    def error_metric_set(self):
+        return _py_interop_run_metrics.run_metrics_error_metric_set(self)
+
+    def set_extended_tile_metric_set(self, metrics):
+        return _py_interop_run_metrics.run_metrics_set_extended_tile_metric_set(self, metrics)
+
+    def extended_tile_metric_set(self):
+        return _py_interop_run_metrics.run_metrics_extended_tile_metric_set(self)
+
+    def set_extraction_metric_set(self, metrics):
+        return _py_interop_run_metrics.run_metrics_set_extraction_metric_set(self, metrics)
+
+    def extraction_metric_set(self):
+        return _py_interop_run_metrics.run_metrics_extraction_metric_set(self)
+
+    def set_image_metric_set(self, metrics):
+        return _py_interop_run_metrics.run_metrics_set_image_metric_set(self, metrics)
+
+    def image_metric_set(self):
+        return _py_interop_run_metrics.run_metrics_image_metric_set(self)
+
+    def set_q_metric_set(self, metrics):
+        return _py_interop_run_metrics.run_metrics_set_q_metric_set(self, metrics)
+
+    def q_metric_set(self):
+        return _py_interop_run_metrics.run_metrics_q_metric_set(self)
+
+    def set_tile_metric_set(self, metrics):
+        return _py_interop_run_metrics.run_metrics_set_tile_metric_set(self, metrics)
+
+    def tile_metric_set(self):
+        return _py_interop_run_metrics.run_metrics_tile_metric_set(self)
+
+    def set_index_metric_set(self, metrics):
+        return _py_interop_run_metrics.run_metrics_set_index_metric_set(self, metrics)
+
+    def index_metric_set(self):
+        return _py_interop_run_metrics.run_metrics_index_metric_set(self)
+
+    def set_q_collapsed_metric_set(self, metrics):
+        return _py_interop_run_metrics.run_metrics_set_q_collapsed_metric_set(self, metrics)
+
+    def q_collapsed_metric_set(self):
+        return _py_interop_run_metrics.run_metrics_q_collapsed_metric_set(self)
+
+    def set_q_by_lane_metric_set(self, metrics):
+        return _py_interop_run_metrics.run_metrics_set_q_by_lane_metric_set(self, metrics)
+
+    def q_by_lane_metric_set(self):
+        return _py_interop_run_metrics.run_metrics_q_by_lane_metric_set(self)
+
+    def set_summary_run_metric_set(self, metrics):
+        return _py_interop_run_metrics.run_metrics_set_summary_run_metric_set(self, metrics)
+
+    def summary_run_metric_set(self):
+        return _py_interop_run_metrics.run_metrics_summary_run_metric_set(self)
+    __swig_destroy__ = _py_interop_run_metrics.delete_run_metrics
+
+# Register run_metrics in _py_interop_run_metrics:
+_py_interop_run_metrics.run_metrics_swigregister(run_metrics)
+
+
+
```

## interop/py_interop_summary.py

```diff
@@ -1,1024 +1,1045 @@
-# This file was automatically generated by SWIG (https://www.swig.org).
-# Version 4.1.1
-#
-# Do not make changes to this file unless you know what you are doing - modify
-# the SWIG interface file instead.
-
-from sys import version_info as _swig_python_version_info
-# Import the low-level C/C++ module
-if __package__ or "." in __name__:
-    from . import _py_interop_summary
-else:
-    import _py_interop_summary
-
-try:
-    import builtins as __builtin__
-except ImportError:
-    import __builtin__
-
-def _swig_repr(self):
-    try:
-        strthis = "proxy of " + self.this.__repr__()
-    except __builtin__.Exception:
-        strthis = ""
-    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)
-
-
-def _swig_setattr_nondynamic_instance_variable(set):
-    def set_instance_attr(self, name, value):
-        if name == "this":
-            set(self, name, value)
-        elif name == "thisown":
-            self.this.own(value)
-        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
-            set(self, name, value)
-        else:
-            raise AttributeError("You cannot add instance attributes to %s" % self)
-    return set_instance_attr
-
-
-def _swig_setattr_nondynamic_class_variable(set):
-    def set_class_attr(cls, name, value):
-        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
-            set(cls, name, value)
-        else:
-            raise AttributeError("You cannot add class attributes to %s" % cls)
-    return set_class_attr
-
-
-def _swig_add_metaclass(metaclass):
-    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
-    def wrapper(cls):
-        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
-    return wrapper
-
-
-class _SwigNonDynamicMeta(type):
-    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
-    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)
-
-
-class SwigPyIterator(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined - class is abstract")
-    __repr__ = _swig_repr
-    __swig_destroy__ = _py_interop_summary.delete_SwigPyIterator
-
-    def value(self):
-        return _py_interop_summary.SwigPyIterator_value(self)
-
-    def incr(self, n=1):
-        return _py_interop_summary.SwigPyIterator_incr(self, n)
-
-    def decr(self, n=1):
-        return _py_interop_summary.SwigPyIterator_decr(self, n)
-
-    def distance(self, x):
-        return _py_interop_summary.SwigPyIterator_distance(self, x)
-
-    def equal(self, x):
-        return _py_interop_summary.SwigPyIterator_equal(self, x)
-
-    def copy(self):
-        return _py_interop_summary.SwigPyIterator_copy(self)
-
-    def next(self):
-        return _py_interop_summary.SwigPyIterator_next(self)
-
-    def __next__(self):
-        return _py_interop_summary.SwigPyIterator___next__(self)
-
-    def previous(self):
-        return _py_interop_summary.SwigPyIterator_previous(self)
-
-    def advance(self, n):
-        return _py_interop_summary.SwigPyIterator_advance(self, n)
-
-    def __eq__(self, x):
-        return _py_interop_summary.SwigPyIterator___eq__(self, x)
-
-    def __ne__(self, x):
-        return _py_interop_summary.SwigPyIterator___ne__(self, x)
-
-    def __iadd__(self, n):
-        return _py_interop_summary.SwigPyIterator___iadd__(self, n)
-
-    def __isub__(self, n):
-        return _py_interop_summary.SwigPyIterator___isub__(self, n)
-
-    def __add__(self, n):
-        return _py_interop_summary.SwigPyIterator___add__(self, n)
-
-    def __sub__(self, *args):
-        return _py_interop_summary.SwigPyIterator___sub__(self, *args)
-    def __iter__(self):
-        return self
-
-# Register SwigPyIterator in _py_interop_summary:
-_py_interop_summary.SwigPyIterator_swigregister(SwigPyIterator)
-import interop.py_interop_run
-import interop.py_interop_metrics
-import interop.py_interop_run_metrics
-import interop.py_interop_comm
-class cycle_state_summary(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self):
-        _py_interop_summary.cycle_state_summary_swiginit(self, _py_interop_summary.new_cycle_state_summary())
-
-    def empty(self):
-        return _py_interop_summary.cycle_state_summary_empty(self)
-
-    def extracted_cycle_range(self, *args):
-        return _py_interop_summary.cycle_state_summary_extracted_cycle_range(self, *args)
-
-    def called_cycle_range(self, *args):
-        return _py_interop_summary.cycle_state_summary_called_cycle_range(self, *args)
-
-    def qscored_cycle_range(self, *args):
-        return _py_interop_summary.cycle_state_summary_qscored_cycle_range(self, *args)
-
-    def error_cycle_range(self, *args):
-        return _py_interop_summary.cycle_state_summary_error_cycle_range(self, *args)
-    __swig_destroy__ = _py_interop_summary.delete_cycle_state_summary
-
-# Register cycle_state_summary in _py_interop_summary:
-_py_interop_summary.cycle_state_summary_swigregister(cycle_state_summary)
-class stat_summary(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, arg2):
-        _py_interop_summary.stat_summary_swiginit(self, _py_interop_summary.new_stat_summary(arg2))
-
-    def percent_gt_q30(self, *args):
-        return _py_interop_summary.stat_summary_percent_gt_q30(self, *args)
-
-    def yield_g(self, *args):
-        return _py_interop_summary.stat_summary_yield_g(self, *args)
-
-    def projected_yield_g(self, *args):
-        return _py_interop_summary.stat_summary_projected_yield_g(self, *args)
-
-    def reads(self, *args):
-        return _py_interop_summary.stat_summary_reads(self, *args)
-
-    def reads_pf(self, *args):
-        return _py_interop_summary.stat_summary_reads_pf(self, *args)
-
-    def density(self, *args):
-        return _py_interop_summary.stat_summary_density(self, *args)
-
-    def density_pf(self, *args):
-        return _py_interop_summary.stat_summary_density_pf(self, *args)
-
-    def cluster_count(self, *args):
-        return _py_interop_summary.stat_summary_cluster_count(self, *args)
-
-    def cluster_count_pf(self, *args):
-        return _py_interop_summary.stat_summary_cluster_count_pf(self, *args)
-
-    def percent_pf(self, *args):
-        return _py_interop_summary.stat_summary_percent_pf(self, *args)
-
-    def phasing(self, *args):
-        return _py_interop_summary.stat_summary_phasing(self, *args)
-
-    def prephasing(self, *args):
-        return _py_interop_summary.stat_summary_prephasing(self, *args)
-
-    def percent_aligned(self, *args):
-        return _py_interop_summary.stat_summary_percent_aligned(self, *args)
-
-    def error_rate(self, *args):
-        return _py_interop_summary.stat_summary_error_rate(self, *args)
-
-    def error_rate_35(self, *args):
-        return _py_interop_summary.stat_summary_error_rate_35(self, *args)
-
-    def error_rate_50(self, *args):
-        return _py_interop_summary.stat_summary_error_rate_50(self, *args)
-
-    def error_rate_75(self, *args):
-        return _py_interop_summary.stat_summary_error_rate_75(self, *args)
-
-    def error_rate_100(self, *args):
-        return _py_interop_summary.stat_summary_error_rate_100(self, *args)
-
-    def first_cycle_intensity(self, *args):
-        return _py_interop_summary.stat_summary_first_cycle_intensity(self, *args)
-
-    def phasing_slope(self, *args):
-        return _py_interop_summary.stat_summary_phasing_slope(self, *args)
-
-    def phasing_offset(self, *args):
-        return _py_interop_summary.stat_summary_phasing_offset(self, *args)
-
-    def prephasing_slope(self, *args):
-        return _py_interop_summary.stat_summary_prephasing_slope(self, *args)
-
-    def prephasing_offset(self, *args):
-        return _py_interop_summary.stat_summary_prephasing_offset(self, *args)
-
-    def percent_occupied(self, *args):
-        return _py_interop_summary.stat_summary_percent_occupied(self, *args)
-
-    def resize_stat(self, arg2):
-        return _py_interop_summary.stat_summary_resize_stat(self, arg2)
-    __swig_destroy__ = _py_interop_summary.delete_stat_summary
-
-# Register stat_summary in _py_interop_summary:
-_py_interop_summary.stat_summary_swigregister(stat_summary)
-class surface_summary(stat_summary):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, surface=0, channel_count=0):
-        _py_interop_summary.surface_summary_swiginit(self, _py_interop_summary.new_surface_summary(surface, channel_count))
-
-    def surface(self, *args):
-        return _py_interop_summary.surface_summary_surface(self, *args)
-
-    def tile_count(self, *args):
-        return _py_interop_summary.surface_summary_tile_count(self, *args)
-    __swig_destroy__ = _py_interop_summary.delete_surface_summary
-
-# Register surface_summary in _py_interop_summary:
-_py_interop_summary.surface_summary_swigregister(surface_summary)
-class metric_summary(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, arg2):
-        _py_interop_summary.metric_summary_swiginit(self, _py_interop_summary.new_metric_summary(arg2))
-
-    def first_cycle_intensity(self, *args):
-        return _py_interop_summary.metric_summary_first_cycle_intensity(self, *args)
-
-    def error_rate(self, *args):
-        return _py_interop_summary.metric_summary_error_rate(self, *args)
-
-    def percent_aligned(self, *args):
-        return _py_interop_summary.metric_summary_percent_aligned(self, *args)
-
-    def percent_gt_q30(self, *args):
-        return _py_interop_summary.metric_summary_percent_gt_q30(self, *args)
-
-    def yield_g(self, *args):
-        return _py_interop_summary.metric_summary_yield_g(self, *args)
-
-    def projected_yield_g(self, *args):
-        return _py_interop_summary.metric_summary_projected_yield_g(self, *args)
-
-    def percent_occupied(self, *args):
-        return _py_interop_summary.metric_summary_percent_occupied(self, *args)
-
-    def percent_occupancy_proxy(self, *args):
-        return _py_interop_summary.metric_summary_percent_occupancy_proxy(self, *args)
-
-    def resize(self, arg2):
-        return _py_interop_summary.metric_summary_resize(self, arg2)
-
-    def cluster_count(self, *args):
-        return _py_interop_summary.metric_summary_cluster_count(self, *args)
-
-    def cluster_count_pf(self, *args):
-        return _py_interop_summary.metric_summary_cluster_count_pf(self, *args)
-
-    def reads(self, *args):
-        return _py_interop_summary.metric_summary_reads(self, *args)
-
-    def reads_pf(self, *args):
-        return _py_interop_summary.metric_summary_reads_pf(self, *args)
-    __swig_destroy__ = _py_interop_summary.delete_metric_summary
-
-# Register metric_summary in _py_interop_summary:
-_py_interop_summary.metric_summary_swigregister(metric_summary)
-class lane_summary(stat_summary):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, lane=0, channel_count=0):
-        _py_interop_summary.lane_summary_swiginit(self, _py_interop_summary.new_lane_summary(lane, channel_count))
-
-    def at(self, n):
-        return _py_interop_summary.lane_summary_at(self, n)
-
-    def resize(self, n):
-        return _py_interop_summary.lane_summary_resize(self, n)
-
-    def cycle_state(self):
-        return _py_interop_summary.lane_summary_cycle_state(self)
-
-    def lane(self, *args):
-        return _py_interop_summary.lane_summary_lane(self, *args)
-
-    def tile_count(self, *args):
-        return _py_interop_summary.lane_summary_tile_count(self, *args)
-
-    def size(self):
-        return _py_interop_summary.lane_summary_size(self)
-    __swig_destroy__ = _py_interop_summary.delete_lane_summary
-
-# Register lane_summary in _py_interop_summary:
-_py_interop_summary.lane_summary_swigregister(lane_summary)
-class metric_stat(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _py_interop_summary.metric_stat_swiginit(self, _py_interop_summary.new_metric_stat(*args))
-
-    def clear(self):
-        return _py_interop_summary.metric_stat_clear(self)
-
-    def mean(self, *args):
-        return _py_interop_summary.metric_stat_mean(self, *args)
-
-    def stddev(self, *args):
-        return _py_interop_summary.metric_stat_stddev(self, *args)
-
-    def median(self, *args):
-        return _py_interop_summary.metric_stat_median(self, *args)
-    __swig_destroy__ = _py_interop_summary.delete_metric_stat
-
-# Register metric_stat in _py_interop_summary:
-_py_interop_summary.metric_stat_swigregister(metric_stat)
-class read_summary(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _py_interop_summary.read_summary_swiginit(self, _py_interop_summary.new_read_summary(*args))
-
-    def at(self, n):
-        return _py_interop_summary.read_summary_at(self, n)
-
-    def resize(self, n):
-        return _py_interop_summary.read_summary_resize(self, n)
-
-    def read(self):
-        return _py_interop_summary.read_summary_read(self)
-
-    def summary(self, *args):
-        return _py_interop_summary.read_summary_summary(self, *args)
-
-    def size(self):
-        return _py_interop_summary.read_summary_size(self)
-
-    def lane_count(self):
-        return _py_interop_summary.read_summary_lane_count(self)
-    __swig_destroy__ = _py_interop_summary.delete_read_summary
-
-# Register read_summary in _py_interop_summary:
-_py_interop_summary.read_summary_swigregister(read_summary)
-class run_summary(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _py_interop_summary.run_summary_swiginit(self, _py_interop_summary.new_run_summary(*args))
-
-    def initialize(self, *args):
-        return _py_interop_summary.run_summary_initialize(self, *args)
-
-    def copy_reads(self, dst):
-        return _py_interop_summary.run_summary_copy_reads(self, dst)
-
-    def at(self, n):
-        return _py_interop_summary.run_summary_at(self, n)
-
-    def size(self):
-        return _py_interop_summary.run_summary_size(self)
-
-    def lane_count(self, *args):
-        return _py_interop_summary.run_summary_lane_count(self, *args)
-
-    def channel_count(self):
-        return _py_interop_summary.run_summary_channel_count(self)
-
-    def surface_count(self, *args):
-        return _py_interop_summary.run_summary_surface_count(self, *args)
-
-    def total_summary(self, *args):
-        return _py_interop_summary.run_summary_total_summary(self, *args)
-
-    def nonindex_summary(self, *args):
-        return _py_interop_summary.run_summary_nonindex_summary(self, *args)
-
-    def cycle_state(self):
-        return _py_interop_summary.run_summary_cycle_state(self)
-
-    def clear(self):
-        return _py_interop_summary.run_summary_clear(self)
-    __swig_destroy__ = _py_interop_summary.delete_run_summary
-
-# Register run_summary in _py_interop_summary:
-_py_interop_summary.run_summary_swigregister(run_summary)
-class surface_summary_vector(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _py_interop_summary.surface_summary_vector___nonzero__(self)
-
-    def __bool__(self):
-        return _py_interop_summary.surface_summary_vector___bool__(self)
-
-    def __len__(self):
-        return _py_interop_summary.surface_summary_vector___len__(self)
-
-    def __getslice__(self, i, j):
-        return _py_interop_summary.surface_summary_vector___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _py_interop_summary.surface_summary_vector___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _py_interop_summary.surface_summary_vector___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _py_interop_summary.surface_summary_vector___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _py_interop_summary.surface_summary_vector___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _py_interop_summary.surface_summary_vector___setitem__(self, *args)
-
-    def pop(self):
-        return _py_interop_summary.surface_summary_vector_pop(self)
-
-    def append(self, x):
-        return _py_interop_summary.surface_summary_vector_append(self, x)
-
-    def empty(self):
-        return _py_interop_summary.surface_summary_vector_empty(self)
-
-    def size(self):
-        return _py_interop_summary.surface_summary_vector_size(self)
-
-    def swap(self, v):
-        return _py_interop_summary.surface_summary_vector_swap(self, v)
-
-    def rbegin(self):
-        return _py_interop_summary.surface_summary_vector_rbegin(self)
-
-    def rend(self):
-        return _py_interop_summary.surface_summary_vector_rend(self)
-
-    def clear(self):
-        return _py_interop_summary.surface_summary_vector_clear(self)
-
-    def get_allocator(self):
-        return _py_interop_summary.surface_summary_vector_get_allocator(self)
-
-    def pop_back(self):
-        return _py_interop_summary.surface_summary_vector_pop_back(self)
-
-    def erase(self, *args):
-        return _py_interop_summary.surface_summary_vector_erase(self, *args)
-
-    def __init__(self, *args):
-        _py_interop_summary.surface_summary_vector_swiginit(self, _py_interop_summary.new_surface_summary_vector(*args))
-
-    def push_back(self, x):
-        return _py_interop_summary.surface_summary_vector_push_back(self, x)
-
-    def front(self):
-        return _py_interop_summary.surface_summary_vector_front(self)
-
-    def back(self):
-        return _py_interop_summary.surface_summary_vector_back(self)
-
-    def assign(self, n, x):
-        return _py_interop_summary.surface_summary_vector_assign(self, n, x)
-
-    def resize(self, *args):
-        return _py_interop_summary.surface_summary_vector_resize(self, *args)
-
-    def insert(self, *args):
-        return _py_interop_summary.surface_summary_vector_insert(self, *args)
-
-    def reserve(self, n):
-        return _py_interop_summary.surface_summary_vector_reserve(self, n)
-
-    def capacity(self):
-        return _py_interop_summary.surface_summary_vector_capacity(self)
-    __swig_destroy__ = _py_interop_summary.delete_surface_summary_vector
-
-# Register surface_summary_vector in _py_interop_summary:
-_py_interop_summary.surface_summary_vector_swigregister(surface_summary_vector)
-class lane_summary_vector(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _py_interop_summary.lane_summary_vector___nonzero__(self)
-
-    def __bool__(self):
-        return _py_interop_summary.lane_summary_vector___bool__(self)
-
-    def __len__(self):
-        return _py_interop_summary.lane_summary_vector___len__(self)
-
-    def __getslice__(self, i, j):
-        return _py_interop_summary.lane_summary_vector___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _py_interop_summary.lane_summary_vector___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _py_interop_summary.lane_summary_vector___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _py_interop_summary.lane_summary_vector___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _py_interop_summary.lane_summary_vector___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _py_interop_summary.lane_summary_vector___setitem__(self, *args)
-
-    def pop(self):
-        return _py_interop_summary.lane_summary_vector_pop(self)
-
-    def append(self, x):
-        return _py_interop_summary.lane_summary_vector_append(self, x)
-
-    def empty(self):
-        return _py_interop_summary.lane_summary_vector_empty(self)
-
-    def size(self):
-        return _py_interop_summary.lane_summary_vector_size(self)
-
-    def swap(self, v):
-        return _py_interop_summary.lane_summary_vector_swap(self, v)
-
-    def rbegin(self):
-        return _py_interop_summary.lane_summary_vector_rbegin(self)
-
-    def rend(self):
-        return _py_interop_summary.lane_summary_vector_rend(self)
-
-    def clear(self):
-        return _py_interop_summary.lane_summary_vector_clear(self)
-
-    def get_allocator(self):
-        return _py_interop_summary.lane_summary_vector_get_allocator(self)
-
-    def pop_back(self):
-        return _py_interop_summary.lane_summary_vector_pop_back(self)
-
-    def erase(self, *args):
-        return _py_interop_summary.lane_summary_vector_erase(self, *args)
-
-    def __init__(self, *args):
-        _py_interop_summary.lane_summary_vector_swiginit(self, _py_interop_summary.new_lane_summary_vector(*args))
-
-    def push_back(self, x):
-        return _py_interop_summary.lane_summary_vector_push_back(self, x)
-
-    def front(self):
-        return _py_interop_summary.lane_summary_vector_front(self)
-
-    def back(self):
-        return _py_interop_summary.lane_summary_vector_back(self)
-
-    def assign(self, n, x):
-        return _py_interop_summary.lane_summary_vector_assign(self, n, x)
-
-    def resize(self, *args):
-        return _py_interop_summary.lane_summary_vector_resize(self, *args)
-
-    def insert(self, *args):
-        return _py_interop_summary.lane_summary_vector_insert(self, *args)
-
-    def reserve(self, n):
-        return _py_interop_summary.lane_summary_vector_reserve(self, n)
-
-    def capacity(self):
-        return _py_interop_summary.lane_summary_vector_capacity(self)
-    __swig_destroy__ = _py_interop_summary.delete_lane_summary_vector
-
-# Register lane_summary_vector in _py_interop_summary:
-_py_interop_summary.lane_summary_vector_swigregister(lane_summary_vector)
-class read_summary_vector(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _py_interop_summary.read_summary_vector___nonzero__(self)
-
-    def __bool__(self):
-        return _py_interop_summary.read_summary_vector___bool__(self)
-
-    def __len__(self):
-        return _py_interop_summary.read_summary_vector___len__(self)
-
-    def __getslice__(self, i, j):
-        return _py_interop_summary.read_summary_vector___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _py_interop_summary.read_summary_vector___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _py_interop_summary.read_summary_vector___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _py_interop_summary.read_summary_vector___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _py_interop_summary.read_summary_vector___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _py_interop_summary.read_summary_vector___setitem__(self, *args)
-
-    def pop(self):
-        return _py_interop_summary.read_summary_vector_pop(self)
-
-    def append(self, x):
-        return _py_interop_summary.read_summary_vector_append(self, x)
-
-    def empty(self):
-        return _py_interop_summary.read_summary_vector_empty(self)
-
-    def size(self):
-        return _py_interop_summary.read_summary_vector_size(self)
-
-    def swap(self, v):
-        return _py_interop_summary.read_summary_vector_swap(self, v)
-
-    def rbegin(self):
-        return _py_interop_summary.read_summary_vector_rbegin(self)
-
-    def rend(self):
-        return _py_interop_summary.read_summary_vector_rend(self)
-
-    def clear(self):
-        return _py_interop_summary.read_summary_vector_clear(self)
-
-    def get_allocator(self):
-        return _py_interop_summary.read_summary_vector_get_allocator(self)
-
-    def pop_back(self):
-        return _py_interop_summary.read_summary_vector_pop_back(self)
-
-    def erase(self, *args):
-        return _py_interop_summary.read_summary_vector_erase(self, *args)
-
-    def __init__(self, *args):
-        _py_interop_summary.read_summary_vector_swiginit(self, _py_interop_summary.new_read_summary_vector(*args))
-
-    def push_back(self, x):
-        return _py_interop_summary.read_summary_vector_push_back(self, x)
-
-    def front(self):
-        return _py_interop_summary.read_summary_vector_front(self)
-
-    def back(self):
-        return _py_interop_summary.read_summary_vector_back(self)
-
-    def assign(self, n, x):
-        return _py_interop_summary.read_summary_vector_assign(self, n, x)
-
-    def resize(self, *args):
-        return _py_interop_summary.read_summary_vector_resize(self, *args)
-
-    def insert(self, *args):
-        return _py_interop_summary.read_summary_vector_insert(self, *args)
-
-    def reserve(self, n):
-        return _py_interop_summary.read_summary_vector_reserve(self, n)
-
-    def capacity(self):
-        return _py_interop_summary.read_summary_vector_capacity(self)
-    __swig_destroy__ = _py_interop_summary.delete_read_summary_vector
-
-# Register read_summary_vector in _py_interop_summary:
-_py_interop_summary.read_summary_vector_swigregister(read_summary_vector)
-
-def summarize_run_metrics(metrics, summary, skip_median=False, trim=True):
-    return _py_interop_summary.summarize_run_metrics(metrics, summary, skip_median, trim)
-class index_count_summary(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _py_interop_summary.index_count_summary_swiginit(self, _py_interop_summary.new_index_count_summary(*args))
-
-    def index1(self):
-        return _py_interop_summary.index_count_summary_index1(self)
-
-    def index2(self):
-        return _py_interop_summary.index_count_summary_index2(self)
-
-    def fraction_mapped(self):
-        return _py_interop_summary.index_count_summary_fraction_mapped(self)
-
-    def cluster_count(self):
-        return _py_interop_summary.index_count_summary_cluster_count(self)
-
-    def sample_id(self):
-        return _py_interop_summary.index_count_summary_sample_id(self)
-
-    def project_name(self):
-        return _py_interop_summary.index_count_summary_project_name(self)
-
-    def id(self, *args):
-        return _py_interop_summary.index_count_summary_id(self, *args)
-
-    def add(self, cluster_count):
-        return _py_interop_summary.index_count_summary_add(self, cluster_count)
-
-    def update_fraction_mapped(self, total_pf_cluster_count):
-        return _py_interop_summary.index_count_summary_update_fraction_mapped(self, total_pf_cluster_count)
-
-    def __lt__(self, rhs):
-        return _py_interop_summary.index_count_summary___lt__(self, rhs)
-    __swig_destroy__ = _py_interop_summary.delete_index_count_summary
-
-# Register index_count_summary in _py_interop_summary:
-_py_interop_summary.index_count_summary_swigregister(index_count_summary)
-class index_lane_summary(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, total_reads=0, total_pf_reads=0, total_fraction_mapped_reads=0, mapped_reads_cv=0, min_mapped_reads=0, max_mapped_reads=0):
-        _py_interop_summary.index_lane_summary_swiginit(self, _py_interop_summary.new_index_lane_summary(total_reads, total_pf_reads, total_fraction_mapped_reads, mapped_reads_cv, min_mapped_reads, max_mapped_reads))
-
-    def resize(self, n):
-        return _py_interop_summary.index_lane_summary_resize(self, n)
-
-    def reserve(self, n):
-        return _py_interop_summary.index_lane_summary_reserve(self, n)
-
-    def push_back(self, count_summary):
-        return _py_interop_summary.index_lane_summary_push_back(self, count_summary)
-
-    def size(self):
-        return _py_interop_summary.index_lane_summary_size(self)
-
-    def at(self, n):
-        return _py_interop_summary.index_lane_summary_at(self, n)
-
-    def total_reads(self):
-        return _py_interop_summary.index_lane_summary_total_reads(self)
-
-    def total_pf_reads(self):
-        return _py_interop_summary.index_lane_summary_total_pf_reads(self)
-
-    def total_fraction_mapped_reads(self):
-        return _py_interop_summary.index_lane_summary_total_fraction_mapped_reads(self)
-
-    def mapped_reads_cv(self):
-        return _py_interop_summary.index_lane_summary_mapped_reads_cv(self)
-
-    def min_mapped_reads(self):
-        return _py_interop_summary.index_lane_summary_min_mapped_reads(self)
-
-    def max_mapped_reads(self):
-        return _py_interop_summary.index_lane_summary_max_mapped_reads(self)
-
-    def sort(self):
-        return _py_interop_summary.index_lane_summary_sort(self)
-
-    def set(self, total_mapped_reads, pf_cluster_count_total, cluster_count_total, min_fraction_mapped, max_fraction_mapped, cv_fraction_mapped):
-        return _py_interop_summary.index_lane_summary_set(self, total_mapped_reads, pf_cluster_count_total, cluster_count_total, min_fraction_mapped, max_fraction_mapped, cv_fraction_mapped)
-
-    def clear(self):
-        return _py_interop_summary.index_lane_summary_clear(self)
-    __swig_destroy__ = _py_interop_summary.delete_index_lane_summary
-
-# Register index_lane_summary in _py_interop_summary:
-_py_interop_summary.index_lane_summary_swigregister(index_lane_summary)
-class index_flowcell_summary(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, n=0):
-        _py_interop_summary.index_flowcell_summary_swiginit(self, _py_interop_summary.new_index_flowcell_summary(n))
-
-    def at(self, n):
-        return _py_interop_summary.index_flowcell_summary_at(self, n)
-
-    def size(self):
-        return _py_interop_summary.index_flowcell_summary_size(self)
-
-    def resize(self, n):
-        return _py_interop_summary.index_flowcell_summary_resize(self, n)
-
-    def sort(self):
-        return _py_interop_summary.index_flowcell_summary_sort(self)
-
-    def clear(self):
-        return _py_interop_summary.index_flowcell_summary_clear(self)
-    __swig_destroy__ = _py_interop_summary.delete_index_flowcell_summary
-
-# Register index_flowcell_summary in _py_interop_summary:
-_py_interop_summary.index_flowcell_summary_swigregister(index_flowcell_summary)
-class index_count_summary_vector(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _py_interop_summary.index_count_summary_vector___nonzero__(self)
-
-    def __bool__(self):
-        return _py_interop_summary.index_count_summary_vector___bool__(self)
-
-    def __len__(self):
-        return _py_interop_summary.index_count_summary_vector___len__(self)
-
-    def __getslice__(self, i, j):
-        return _py_interop_summary.index_count_summary_vector___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _py_interop_summary.index_count_summary_vector___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _py_interop_summary.index_count_summary_vector___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _py_interop_summary.index_count_summary_vector___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _py_interop_summary.index_count_summary_vector___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _py_interop_summary.index_count_summary_vector___setitem__(self, *args)
-
-    def pop(self):
-        return _py_interop_summary.index_count_summary_vector_pop(self)
-
-    def append(self, x):
-        return _py_interop_summary.index_count_summary_vector_append(self, x)
-
-    def empty(self):
-        return _py_interop_summary.index_count_summary_vector_empty(self)
-
-    def size(self):
-        return _py_interop_summary.index_count_summary_vector_size(self)
-
-    def swap(self, v):
-        return _py_interop_summary.index_count_summary_vector_swap(self, v)
-
-    def rbegin(self):
-        return _py_interop_summary.index_count_summary_vector_rbegin(self)
-
-    def rend(self):
-        return _py_interop_summary.index_count_summary_vector_rend(self)
-
-    def clear(self):
-        return _py_interop_summary.index_count_summary_vector_clear(self)
-
-    def get_allocator(self):
-        return _py_interop_summary.index_count_summary_vector_get_allocator(self)
-
-    def pop_back(self):
-        return _py_interop_summary.index_count_summary_vector_pop_back(self)
-
-    def erase(self, *args):
-        return _py_interop_summary.index_count_summary_vector_erase(self, *args)
-
-    def __init__(self, *args):
-        _py_interop_summary.index_count_summary_vector_swiginit(self, _py_interop_summary.new_index_count_summary_vector(*args))
-
-    def push_back(self, x):
-        return _py_interop_summary.index_count_summary_vector_push_back(self, x)
-
-    def front(self):
-        return _py_interop_summary.index_count_summary_vector_front(self)
-
-    def back(self):
-        return _py_interop_summary.index_count_summary_vector_back(self)
-
-    def assign(self, n, x):
-        return _py_interop_summary.index_count_summary_vector_assign(self, n, x)
-
-    def resize(self, *args):
-        return _py_interop_summary.index_count_summary_vector_resize(self, *args)
-
-    def insert(self, *args):
-        return _py_interop_summary.index_count_summary_vector_insert(self, *args)
-
-    def reserve(self, n):
-        return _py_interop_summary.index_count_summary_vector_reserve(self, n)
-
-    def capacity(self):
-        return _py_interop_summary.index_count_summary_vector_capacity(self)
-    __swig_destroy__ = _py_interop_summary.delete_index_count_summary_vector
-
-# Register index_count_summary_vector in _py_interop_summary:
-_py_interop_summary.index_count_summary_vector_swigregister(index_count_summary_vector)
-class index_lane_summary_vector(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _py_interop_summary.index_lane_summary_vector___nonzero__(self)
-
-    def __bool__(self):
-        return _py_interop_summary.index_lane_summary_vector___bool__(self)
-
-    def __len__(self):
-        return _py_interop_summary.index_lane_summary_vector___len__(self)
-
-    def __getslice__(self, i, j):
-        return _py_interop_summary.index_lane_summary_vector___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _py_interop_summary.index_lane_summary_vector___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _py_interop_summary.index_lane_summary_vector___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _py_interop_summary.index_lane_summary_vector___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _py_interop_summary.index_lane_summary_vector___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _py_interop_summary.index_lane_summary_vector___setitem__(self, *args)
-
-    def pop(self):
-        return _py_interop_summary.index_lane_summary_vector_pop(self)
-
-    def append(self, x):
-        return _py_interop_summary.index_lane_summary_vector_append(self, x)
-
-    def empty(self):
-        return _py_interop_summary.index_lane_summary_vector_empty(self)
-
-    def size(self):
-        return _py_interop_summary.index_lane_summary_vector_size(self)
-
-    def swap(self, v):
-        return _py_interop_summary.index_lane_summary_vector_swap(self, v)
-
-    def rbegin(self):
-        return _py_interop_summary.index_lane_summary_vector_rbegin(self)
-
-    def rend(self):
-        return _py_interop_summary.index_lane_summary_vector_rend(self)
-
-    def clear(self):
-        return _py_interop_summary.index_lane_summary_vector_clear(self)
-
-    def get_allocator(self):
-        return _py_interop_summary.index_lane_summary_vector_get_allocator(self)
-
-    def pop_back(self):
-        return _py_interop_summary.index_lane_summary_vector_pop_back(self)
-
-    def erase(self, *args):
-        return _py_interop_summary.index_lane_summary_vector_erase(self, *args)
-
-    def __init__(self, *args):
-        _py_interop_summary.index_lane_summary_vector_swiginit(self, _py_interop_summary.new_index_lane_summary_vector(*args))
-
-    def push_back(self, x):
-        return _py_interop_summary.index_lane_summary_vector_push_back(self, x)
-
-    def front(self):
-        return _py_interop_summary.index_lane_summary_vector_front(self)
-
-    def back(self):
-        return _py_interop_summary.index_lane_summary_vector_back(self)
-
-    def assign(self, n, x):
-        return _py_interop_summary.index_lane_summary_vector_assign(self, n, x)
-
-    def resize(self, *args):
-        return _py_interop_summary.index_lane_summary_vector_resize(self, *args)
-
-    def insert(self, *args):
-        return _py_interop_summary.index_lane_summary_vector_insert(self, *args)
-
-    def reserve(self, n):
-        return _py_interop_summary.index_lane_summary_vector_reserve(self, n)
-
-    def capacity(self):
-        return _py_interop_summary.index_lane_summary_vector_capacity(self)
-    __swig_destroy__ = _py_interop_summary.delete_index_lane_summary_vector
-
-# Register index_lane_summary_vector in _py_interop_summary:
-_py_interop_summary.index_lane_summary_vector_swigregister(index_lane_summary_vector)
-
-def summarize_index_metrics(*args):
-    return _py_interop_summary.summarize_index_metrics(*args)
-
+# This file was automatically generated by SWIG (http://www.swig.org).
+# Version 4.0.2
+#
+# Do not make changes to this file unless you know what you are doing--modify
+# the SWIG interface file instead.
+
+from sys import version_info as _swig_python_version_info
+if _swig_python_version_info < (2, 7, 0):
+    raise RuntimeError("Python 2.7 or later required")
+
+# Import the low-level C/C++ module
+if __package__ or "." in __name__:
+    from . import _py_interop_summary
+else:
+    import _py_interop_summary
+
+try:
+    import builtins as __builtin__
+except ImportError:
+    import __builtin__
+
+def _swig_repr(self):
+    try:
+        strthis = "proxy of " + self.this.__repr__()
+    except __builtin__.Exception:
+        strthis = ""
+    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)
+
+
+def _swig_setattr_nondynamic_instance_variable(set):
+    def set_instance_attr(self, name, value):
+        if name == "thisown":
+            self.this.own(value)
+        elif name == "this":
+            set(self, name, value)
+        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
+            set(self, name, value)
+        else:
+            raise AttributeError("You cannot add instance attributes to %s" % self)
+    return set_instance_attr
+
+
+def _swig_setattr_nondynamic_class_variable(set):
+    def set_class_attr(cls, name, value):
+        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
+            set(cls, name, value)
+        else:
+            raise AttributeError("You cannot add class attributes to %s" % cls)
+    return set_class_attr
+
+
+def _swig_add_metaclass(metaclass):
+    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
+    def wrapper(cls):
+        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
+    return wrapper
+
+
+class _SwigNonDynamicMeta(type):
+    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
+    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)
+
+
+class SwigPyIterator(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined - class is abstract")
+    __repr__ = _swig_repr
+    __swig_destroy__ = _py_interop_summary.delete_SwigPyIterator
+
+    def value(self):
+        return _py_interop_summary.SwigPyIterator_value(self)
+
+    def incr(self, n=1):
+        return _py_interop_summary.SwigPyIterator_incr(self, n)
+
+    def decr(self, n=1):
+        return _py_interop_summary.SwigPyIterator_decr(self, n)
+
+    def distance(self, x):
+        return _py_interop_summary.SwigPyIterator_distance(self, x)
+
+    def equal(self, x):
+        return _py_interop_summary.SwigPyIterator_equal(self, x)
+
+    def copy(self):
+        return _py_interop_summary.SwigPyIterator_copy(self)
+
+    def next(self):
+        return _py_interop_summary.SwigPyIterator_next(self)
+
+    def __next__(self):
+        return _py_interop_summary.SwigPyIterator___next__(self)
+
+    def previous(self):
+        return _py_interop_summary.SwigPyIterator_previous(self)
+
+    def advance(self, n):
+        return _py_interop_summary.SwigPyIterator_advance(self, n)
+
+    def __eq__(self, x):
+        return _py_interop_summary.SwigPyIterator___eq__(self, x)
+
+    def __ne__(self, x):
+        return _py_interop_summary.SwigPyIterator___ne__(self, x)
+
+    def __iadd__(self, n):
+        return _py_interop_summary.SwigPyIterator___iadd__(self, n)
+
+    def __isub__(self, n):
+        return _py_interop_summary.SwigPyIterator___isub__(self, n)
+
+    def __add__(self, n):
+        return _py_interop_summary.SwigPyIterator___add__(self, n)
+
+    def __sub__(self, *args):
+        return _py_interop_summary.SwigPyIterator___sub__(self, *args)
+    def __iter__(self):
+        return self
+
+# Register SwigPyIterator in _py_interop_summary:
+_py_interop_summary.SwigPyIterator_swigregister(SwigPyIterator)
+
+import interop.py_interop_run
+import interop.py_interop_metrics
+import interop.py_interop_run_metrics
+import interop.py_interop_comm
+class cycle_state_summary(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self):
+        _py_interop_summary.cycle_state_summary_swiginit(self, _py_interop_summary.new_cycle_state_summary())
+
+    def empty(self):
+        return _py_interop_summary.cycle_state_summary_empty(self)
+
+    def extracted_cycle_range(self, *args):
+        return _py_interop_summary.cycle_state_summary_extracted_cycle_range(self, *args)
+
+    def called_cycle_range(self, *args):
+        return _py_interop_summary.cycle_state_summary_called_cycle_range(self, *args)
+
+    def qscored_cycle_range(self, *args):
+        return _py_interop_summary.cycle_state_summary_qscored_cycle_range(self, *args)
+
+    def error_cycle_range(self, *args):
+        return _py_interop_summary.cycle_state_summary_error_cycle_range(self, *args)
+    __swig_destroy__ = _py_interop_summary.delete_cycle_state_summary
+
+# Register cycle_state_summary in _py_interop_summary:
+_py_interop_summary.cycle_state_summary_swigregister(cycle_state_summary)
+
+class stat_summary(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, arg2):
+        _py_interop_summary.stat_summary_swiginit(self, _py_interop_summary.new_stat_summary(arg2))
+
+    def percent_gt_q30(self, *args):
+        return _py_interop_summary.stat_summary_percent_gt_q30(self, *args)
+
+    def yield_g(self, *args):
+        return _py_interop_summary.stat_summary_yield_g(self, *args)
+
+    def projected_yield_g(self, *args):
+        return _py_interop_summary.stat_summary_projected_yield_g(self, *args)
+
+    def reads(self, *args):
+        return _py_interop_summary.stat_summary_reads(self, *args)
+
+    def reads_pf(self, *args):
+        return _py_interop_summary.stat_summary_reads_pf(self, *args)
+
+    def density(self, *args):
+        return _py_interop_summary.stat_summary_density(self, *args)
+
+    def density_pf(self, *args):
+        return _py_interop_summary.stat_summary_density_pf(self, *args)
+
+    def cluster_count(self, *args):
+        return _py_interop_summary.stat_summary_cluster_count(self, *args)
+
+    def cluster_count_pf(self, *args):
+        return _py_interop_summary.stat_summary_cluster_count_pf(self, *args)
+
+    def percent_pf(self, *args):
+        return _py_interop_summary.stat_summary_percent_pf(self, *args)
+
+    def phasing(self, *args):
+        return _py_interop_summary.stat_summary_phasing(self, *args)
+
+    def prephasing(self, *args):
+        return _py_interop_summary.stat_summary_prephasing(self, *args)
+
+    def percent_aligned(self, *args):
+        return _py_interop_summary.stat_summary_percent_aligned(self, *args)
+
+    def error_rate(self, *args):
+        return _py_interop_summary.stat_summary_error_rate(self, *args)
+
+    def error_rate_35(self, *args):
+        return _py_interop_summary.stat_summary_error_rate_35(self, *args)
+
+    def error_rate_50(self, *args):
+        return _py_interop_summary.stat_summary_error_rate_50(self, *args)
+
+    def error_rate_75(self, *args):
+        return _py_interop_summary.stat_summary_error_rate_75(self, *args)
+
+    def error_rate_100(self, *args):
+        return _py_interop_summary.stat_summary_error_rate_100(self, *args)
+
+    def first_cycle_intensity(self, *args):
+        return _py_interop_summary.stat_summary_first_cycle_intensity(self, *args)
+
+    def phasing_slope(self, *args):
+        return _py_interop_summary.stat_summary_phasing_slope(self, *args)
+
+    def phasing_offset(self, *args):
+        return _py_interop_summary.stat_summary_phasing_offset(self, *args)
+
+    def prephasing_slope(self, *args):
+        return _py_interop_summary.stat_summary_prephasing_slope(self, *args)
+
+    def prephasing_offset(self, *args):
+        return _py_interop_summary.stat_summary_prephasing_offset(self, *args)
+
+    def percent_occupied(self, *args):
+        return _py_interop_summary.stat_summary_percent_occupied(self, *args)
+
+    def resize_stat(self, arg2):
+        return _py_interop_summary.stat_summary_resize_stat(self, arg2)
+    __swig_destroy__ = _py_interop_summary.delete_stat_summary
+
+# Register stat_summary in _py_interop_summary:
+_py_interop_summary.stat_summary_swigregister(stat_summary)
+
+class surface_summary(stat_summary):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, surface=0, channel_count=0):
+        _py_interop_summary.surface_summary_swiginit(self, _py_interop_summary.new_surface_summary(surface, channel_count))
+
+    def surface(self, *args):
+        return _py_interop_summary.surface_summary_surface(self, *args)
+
+    def tile_count(self, *args):
+        return _py_interop_summary.surface_summary_tile_count(self, *args)
+    __swig_destroy__ = _py_interop_summary.delete_surface_summary
+
+# Register surface_summary in _py_interop_summary:
+_py_interop_summary.surface_summary_swigregister(surface_summary)
+
+class metric_summary(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, arg2):
+        _py_interop_summary.metric_summary_swiginit(self, _py_interop_summary.new_metric_summary(arg2))
+
+    def first_cycle_intensity(self, *args):
+        return _py_interop_summary.metric_summary_first_cycle_intensity(self, *args)
+
+    def error_rate(self, *args):
+        return _py_interop_summary.metric_summary_error_rate(self, *args)
+
+    def percent_aligned(self, *args):
+        return _py_interop_summary.metric_summary_percent_aligned(self, *args)
+
+    def percent_gt_q30(self, *args):
+        return _py_interop_summary.metric_summary_percent_gt_q30(self, *args)
+
+    def yield_g(self, *args):
+        return _py_interop_summary.metric_summary_yield_g(self, *args)
+
+    def projected_yield_g(self, *args):
+        return _py_interop_summary.metric_summary_projected_yield_g(self, *args)
+
+    def percent_occupied(self, *args):
+        return _py_interop_summary.metric_summary_percent_occupied(self, *args)
+
+    def percent_occupancy_proxy(self, *args):
+        return _py_interop_summary.metric_summary_percent_occupancy_proxy(self, *args)
+
+    def resize(self, arg2):
+        return _py_interop_summary.metric_summary_resize(self, arg2)
+
+    def cluster_count(self, *args):
+        return _py_interop_summary.metric_summary_cluster_count(self, *args)
+
+    def cluster_count_pf(self, *args):
+        return _py_interop_summary.metric_summary_cluster_count_pf(self, *args)
+
+    def reads(self, *args):
+        return _py_interop_summary.metric_summary_reads(self, *args)
+
+    def reads_pf(self, *args):
+        return _py_interop_summary.metric_summary_reads_pf(self, *args)
+    __swig_destroy__ = _py_interop_summary.delete_metric_summary
+
+# Register metric_summary in _py_interop_summary:
+_py_interop_summary.metric_summary_swigregister(metric_summary)
+
+class lane_summary(stat_summary):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, lane=0, channel_count=0):
+        _py_interop_summary.lane_summary_swiginit(self, _py_interop_summary.new_lane_summary(lane, channel_count))
+
+    def at(self, n):
+        return _py_interop_summary.lane_summary_at(self, n)
+
+    def resize(self, n):
+        return _py_interop_summary.lane_summary_resize(self, n)
+
+    def cycle_state(self):
+        return _py_interop_summary.lane_summary_cycle_state(self)
+
+    def lane(self, *args):
+        return _py_interop_summary.lane_summary_lane(self, *args)
+
+    def tile_count(self, *args):
+        return _py_interop_summary.lane_summary_tile_count(self, *args)
+
+    def size(self):
+        return _py_interop_summary.lane_summary_size(self)
+    __swig_destroy__ = _py_interop_summary.delete_lane_summary
+
+# Register lane_summary in _py_interop_summary:
+_py_interop_summary.lane_summary_swigregister(lane_summary)
+
+class metric_stat(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _py_interop_summary.metric_stat_swiginit(self, _py_interop_summary.new_metric_stat(*args))
+
+    def clear(self):
+        return _py_interop_summary.metric_stat_clear(self)
+
+    def mean(self, *args):
+        return _py_interop_summary.metric_stat_mean(self, *args)
+
+    def stddev(self, *args):
+        return _py_interop_summary.metric_stat_stddev(self, *args)
+
+    def median(self, *args):
+        return _py_interop_summary.metric_stat_median(self, *args)
+    __swig_destroy__ = _py_interop_summary.delete_metric_stat
+
+# Register metric_stat in _py_interop_summary:
+_py_interop_summary.metric_stat_swigregister(metric_stat)
+
+class read_summary(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _py_interop_summary.read_summary_swiginit(self, _py_interop_summary.new_read_summary(*args))
+
+    def at(self, n):
+        return _py_interop_summary.read_summary_at(self, n)
+
+    def resize(self, n):
+        return _py_interop_summary.read_summary_resize(self, n)
+
+    def read(self):
+        return _py_interop_summary.read_summary_read(self)
+
+    def summary(self, *args):
+        return _py_interop_summary.read_summary_summary(self, *args)
+
+    def size(self):
+        return _py_interop_summary.read_summary_size(self)
+
+    def lane_count(self):
+        return _py_interop_summary.read_summary_lane_count(self)
+    __swig_destroy__ = _py_interop_summary.delete_read_summary
+
+# Register read_summary in _py_interop_summary:
+_py_interop_summary.read_summary_swigregister(read_summary)
+
+class run_summary(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _py_interop_summary.run_summary_swiginit(self, _py_interop_summary.new_run_summary(*args))
+
+    def initialize(self, *args):
+        return _py_interop_summary.run_summary_initialize(self, *args)
+
+    def copy_reads(self, dst):
+        return _py_interop_summary.run_summary_copy_reads(self, dst)
+
+    def at(self, n):
+        return _py_interop_summary.run_summary_at(self, n)
+
+    def size(self):
+        return _py_interop_summary.run_summary_size(self)
+
+    def lane_count(self, *args):
+        return _py_interop_summary.run_summary_lane_count(self, *args)
+
+    def channel_count(self):
+        return _py_interop_summary.run_summary_channel_count(self)
+
+    def surface_count(self, *args):
+        return _py_interop_summary.run_summary_surface_count(self, *args)
+
+    def total_summary(self, *args):
+        return _py_interop_summary.run_summary_total_summary(self, *args)
+
+    def nonindex_summary(self, *args):
+        return _py_interop_summary.run_summary_nonindex_summary(self, *args)
+
+    def cycle_state(self):
+        return _py_interop_summary.run_summary_cycle_state(self)
+
+    def clear(self):
+        return _py_interop_summary.run_summary_clear(self)
+    __swig_destroy__ = _py_interop_summary.delete_run_summary
+
+# Register run_summary in _py_interop_summary:
+_py_interop_summary.run_summary_swigregister(run_summary)
+
+class surface_summary_vector(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _py_interop_summary.surface_summary_vector___nonzero__(self)
+
+    def __bool__(self):
+        return _py_interop_summary.surface_summary_vector___bool__(self)
+
+    def __len__(self):
+        return _py_interop_summary.surface_summary_vector___len__(self)
+
+    def __getslice__(self, i, j):
+        return _py_interop_summary.surface_summary_vector___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _py_interop_summary.surface_summary_vector___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _py_interop_summary.surface_summary_vector___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _py_interop_summary.surface_summary_vector___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _py_interop_summary.surface_summary_vector___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _py_interop_summary.surface_summary_vector___setitem__(self, *args)
+
+    def pop(self):
+        return _py_interop_summary.surface_summary_vector_pop(self)
+
+    def append(self, x):
+        return _py_interop_summary.surface_summary_vector_append(self, x)
+
+    def empty(self):
+        return _py_interop_summary.surface_summary_vector_empty(self)
+
+    def size(self):
+        return _py_interop_summary.surface_summary_vector_size(self)
+
+    def swap(self, v):
+        return _py_interop_summary.surface_summary_vector_swap(self, v)
+
+    def rbegin(self):
+        return _py_interop_summary.surface_summary_vector_rbegin(self)
+
+    def rend(self):
+        return _py_interop_summary.surface_summary_vector_rend(self)
+
+    def clear(self):
+        return _py_interop_summary.surface_summary_vector_clear(self)
+
+    def get_allocator(self):
+        return _py_interop_summary.surface_summary_vector_get_allocator(self)
+
+    def pop_back(self):
+        return _py_interop_summary.surface_summary_vector_pop_back(self)
+
+    def erase(self, *args):
+        return _py_interop_summary.surface_summary_vector_erase(self, *args)
+
+    def __init__(self, *args):
+        _py_interop_summary.surface_summary_vector_swiginit(self, _py_interop_summary.new_surface_summary_vector(*args))
+
+    def push_back(self, x):
+        return _py_interop_summary.surface_summary_vector_push_back(self, x)
+
+    def front(self):
+        return _py_interop_summary.surface_summary_vector_front(self)
+
+    def back(self):
+        return _py_interop_summary.surface_summary_vector_back(self)
+
+    def assign(self, n, x):
+        return _py_interop_summary.surface_summary_vector_assign(self, n, x)
+
+    def resize(self, *args):
+        return _py_interop_summary.surface_summary_vector_resize(self, *args)
+
+    def insert(self, *args):
+        return _py_interop_summary.surface_summary_vector_insert(self, *args)
+
+    def reserve(self, n):
+        return _py_interop_summary.surface_summary_vector_reserve(self, n)
+
+    def capacity(self):
+        return _py_interop_summary.surface_summary_vector_capacity(self)
+    __swig_destroy__ = _py_interop_summary.delete_surface_summary_vector
+
+# Register surface_summary_vector in _py_interop_summary:
+_py_interop_summary.surface_summary_vector_swigregister(surface_summary_vector)
+
+class lane_summary_vector(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _py_interop_summary.lane_summary_vector___nonzero__(self)
+
+    def __bool__(self):
+        return _py_interop_summary.lane_summary_vector___bool__(self)
+
+    def __len__(self):
+        return _py_interop_summary.lane_summary_vector___len__(self)
+
+    def __getslice__(self, i, j):
+        return _py_interop_summary.lane_summary_vector___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _py_interop_summary.lane_summary_vector___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _py_interop_summary.lane_summary_vector___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _py_interop_summary.lane_summary_vector___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _py_interop_summary.lane_summary_vector___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _py_interop_summary.lane_summary_vector___setitem__(self, *args)
+
+    def pop(self):
+        return _py_interop_summary.lane_summary_vector_pop(self)
+
+    def append(self, x):
+        return _py_interop_summary.lane_summary_vector_append(self, x)
+
+    def empty(self):
+        return _py_interop_summary.lane_summary_vector_empty(self)
+
+    def size(self):
+        return _py_interop_summary.lane_summary_vector_size(self)
+
+    def swap(self, v):
+        return _py_interop_summary.lane_summary_vector_swap(self, v)
+
+    def rbegin(self):
+        return _py_interop_summary.lane_summary_vector_rbegin(self)
+
+    def rend(self):
+        return _py_interop_summary.lane_summary_vector_rend(self)
+
+    def clear(self):
+        return _py_interop_summary.lane_summary_vector_clear(self)
+
+    def get_allocator(self):
+        return _py_interop_summary.lane_summary_vector_get_allocator(self)
+
+    def pop_back(self):
+        return _py_interop_summary.lane_summary_vector_pop_back(self)
+
+    def erase(self, *args):
+        return _py_interop_summary.lane_summary_vector_erase(self, *args)
+
+    def __init__(self, *args):
+        _py_interop_summary.lane_summary_vector_swiginit(self, _py_interop_summary.new_lane_summary_vector(*args))
+
+    def push_back(self, x):
+        return _py_interop_summary.lane_summary_vector_push_back(self, x)
+
+    def front(self):
+        return _py_interop_summary.lane_summary_vector_front(self)
+
+    def back(self):
+        return _py_interop_summary.lane_summary_vector_back(self)
+
+    def assign(self, n, x):
+        return _py_interop_summary.lane_summary_vector_assign(self, n, x)
+
+    def resize(self, *args):
+        return _py_interop_summary.lane_summary_vector_resize(self, *args)
+
+    def insert(self, *args):
+        return _py_interop_summary.lane_summary_vector_insert(self, *args)
+
+    def reserve(self, n):
+        return _py_interop_summary.lane_summary_vector_reserve(self, n)
+
+    def capacity(self):
+        return _py_interop_summary.lane_summary_vector_capacity(self)
+    __swig_destroy__ = _py_interop_summary.delete_lane_summary_vector
+
+# Register lane_summary_vector in _py_interop_summary:
+_py_interop_summary.lane_summary_vector_swigregister(lane_summary_vector)
+
+class read_summary_vector(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _py_interop_summary.read_summary_vector___nonzero__(self)
+
+    def __bool__(self):
+        return _py_interop_summary.read_summary_vector___bool__(self)
+
+    def __len__(self):
+        return _py_interop_summary.read_summary_vector___len__(self)
+
+    def __getslice__(self, i, j):
+        return _py_interop_summary.read_summary_vector___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _py_interop_summary.read_summary_vector___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _py_interop_summary.read_summary_vector___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _py_interop_summary.read_summary_vector___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _py_interop_summary.read_summary_vector___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _py_interop_summary.read_summary_vector___setitem__(self, *args)
+
+    def pop(self):
+        return _py_interop_summary.read_summary_vector_pop(self)
+
+    def append(self, x):
+        return _py_interop_summary.read_summary_vector_append(self, x)
+
+    def empty(self):
+        return _py_interop_summary.read_summary_vector_empty(self)
+
+    def size(self):
+        return _py_interop_summary.read_summary_vector_size(self)
+
+    def swap(self, v):
+        return _py_interop_summary.read_summary_vector_swap(self, v)
+
+    def rbegin(self):
+        return _py_interop_summary.read_summary_vector_rbegin(self)
+
+    def rend(self):
+        return _py_interop_summary.read_summary_vector_rend(self)
+
+    def clear(self):
+        return _py_interop_summary.read_summary_vector_clear(self)
+
+    def get_allocator(self):
+        return _py_interop_summary.read_summary_vector_get_allocator(self)
+
+    def pop_back(self):
+        return _py_interop_summary.read_summary_vector_pop_back(self)
+
+    def erase(self, *args):
+        return _py_interop_summary.read_summary_vector_erase(self, *args)
+
+    def __init__(self, *args):
+        _py_interop_summary.read_summary_vector_swiginit(self, _py_interop_summary.new_read_summary_vector(*args))
+
+    def push_back(self, x):
+        return _py_interop_summary.read_summary_vector_push_back(self, x)
+
+    def front(self):
+        return _py_interop_summary.read_summary_vector_front(self)
+
+    def back(self):
+        return _py_interop_summary.read_summary_vector_back(self)
+
+    def assign(self, n, x):
+        return _py_interop_summary.read_summary_vector_assign(self, n, x)
+
+    def resize(self, *args):
+        return _py_interop_summary.read_summary_vector_resize(self, *args)
+
+    def insert(self, *args):
+        return _py_interop_summary.read_summary_vector_insert(self, *args)
+
+    def reserve(self, n):
+        return _py_interop_summary.read_summary_vector_reserve(self, n)
+
+    def capacity(self):
+        return _py_interop_summary.read_summary_vector_capacity(self)
+    __swig_destroy__ = _py_interop_summary.delete_read_summary_vector
+
+# Register read_summary_vector in _py_interop_summary:
+_py_interop_summary.read_summary_vector_swigregister(read_summary_vector)
+
+
+def summarize_run_metrics(metrics, summary, skip_median=False, trim=True):
+    return _py_interop_summary.summarize_run_metrics(metrics, summary, skip_median, trim)
+class index_count_summary(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _py_interop_summary.index_count_summary_swiginit(self, _py_interop_summary.new_index_count_summary(*args))
+
+    def index1(self):
+        return _py_interop_summary.index_count_summary_index1(self)
+
+    def index2(self):
+        return _py_interop_summary.index_count_summary_index2(self)
+
+    def fraction_mapped(self):
+        return _py_interop_summary.index_count_summary_fraction_mapped(self)
+
+    def cluster_count(self):
+        return _py_interop_summary.index_count_summary_cluster_count(self)
+
+    def sample_id(self):
+        return _py_interop_summary.index_count_summary_sample_id(self)
+
+    def project_name(self):
+        return _py_interop_summary.index_count_summary_project_name(self)
+
+    def id(self, *args):
+        return _py_interop_summary.index_count_summary_id(self, *args)
+
+    def add(self, cluster_count):
+        return _py_interop_summary.index_count_summary_add(self, cluster_count)
+
+    def update_fraction_mapped(self, total_pf_cluster_count):
+        return _py_interop_summary.index_count_summary_update_fraction_mapped(self, total_pf_cluster_count)
+
+    def __lt__(self, rhs):
+        return _py_interop_summary.index_count_summary___lt__(self, rhs)
+    __swig_destroy__ = _py_interop_summary.delete_index_count_summary
+
+# Register index_count_summary in _py_interop_summary:
+_py_interop_summary.index_count_summary_swigregister(index_count_summary)
+
+class index_lane_summary(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, total_reads=0, total_pf_reads=0, total_fraction_mapped_reads=0, mapped_reads_cv=0, min_mapped_reads=0, max_mapped_reads=0):
+        _py_interop_summary.index_lane_summary_swiginit(self, _py_interop_summary.new_index_lane_summary(total_reads, total_pf_reads, total_fraction_mapped_reads, mapped_reads_cv, min_mapped_reads, max_mapped_reads))
+
+    def resize(self, n):
+        return _py_interop_summary.index_lane_summary_resize(self, n)
+
+    def reserve(self, n):
+        return _py_interop_summary.index_lane_summary_reserve(self, n)
+
+    def push_back(self, count_summary):
+        return _py_interop_summary.index_lane_summary_push_back(self, count_summary)
+
+    def size(self):
+        return _py_interop_summary.index_lane_summary_size(self)
+
+    def at(self, n):
+        return _py_interop_summary.index_lane_summary_at(self, n)
+
+    def total_reads(self):
+        return _py_interop_summary.index_lane_summary_total_reads(self)
+
+    def total_pf_reads(self):
+        return _py_interop_summary.index_lane_summary_total_pf_reads(self)
+
+    def total_fraction_mapped_reads(self):
+        return _py_interop_summary.index_lane_summary_total_fraction_mapped_reads(self)
+
+    def mapped_reads_cv(self):
+        return _py_interop_summary.index_lane_summary_mapped_reads_cv(self)
+
+    def min_mapped_reads(self):
+        return _py_interop_summary.index_lane_summary_min_mapped_reads(self)
+
+    def max_mapped_reads(self):
+        return _py_interop_summary.index_lane_summary_max_mapped_reads(self)
+
+    def sort(self):
+        return _py_interop_summary.index_lane_summary_sort(self)
+
+    def set(self, total_mapped_reads, pf_cluster_count_total, cluster_count_total, min_fraction_mapped, max_fraction_mapped, cv_fraction_mapped):
+        return _py_interop_summary.index_lane_summary_set(self, total_mapped_reads, pf_cluster_count_total, cluster_count_total, min_fraction_mapped, max_fraction_mapped, cv_fraction_mapped)
+
+    def clear(self):
+        return _py_interop_summary.index_lane_summary_clear(self)
+    __swig_destroy__ = _py_interop_summary.delete_index_lane_summary
+
+# Register index_lane_summary in _py_interop_summary:
+_py_interop_summary.index_lane_summary_swigregister(index_lane_summary)
+
+class index_flowcell_summary(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, n=0):
+        _py_interop_summary.index_flowcell_summary_swiginit(self, _py_interop_summary.new_index_flowcell_summary(n))
+
+    def at(self, n):
+        return _py_interop_summary.index_flowcell_summary_at(self, n)
+
+    def size(self):
+        return _py_interop_summary.index_flowcell_summary_size(self)
+
+    def resize(self, n):
+        return _py_interop_summary.index_flowcell_summary_resize(self, n)
+
+    def sort(self):
+        return _py_interop_summary.index_flowcell_summary_sort(self)
+
+    def clear(self):
+        return _py_interop_summary.index_flowcell_summary_clear(self)
+    __swig_destroy__ = _py_interop_summary.delete_index_flowcell_summary
+
+# Register index_flowcell_summary in _py_interop_summary:
+_py_interop_summary.index_flowcell_summary_swigregister(index_flowcell_summary)
+
+class index_count_summary_vector(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _py_interop_summary.index_count_summary_vector___nonzero__(self)
+
+    def __bool__(self):
+        return _py_interop_summary.index_count_summary_vector___bool__(self)
+
+    def __len__(self):
+        return _py_interop_summary.index_count_summary_vector___len__(self)
+
+    def __getslice__(self, i, j):
+        return _py_interop_summary.index_count_summary_vector___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _py_interop_summary.index_count_summary_vector___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _py_interop_summary.index_count_summary_vector___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _py_interop_summary.index_count_summary_vector___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _py_interop_summary.index_count_summary_vector___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _py_interop_summary.index_count_summary_vector___setitem__(self, *args)
+
+    def pop(self):
+        return _py_interop_summary.index_count_summary_vector_pop(self)
+
+    def append(self, x):
+        return _py_interop_summary.index_count_summary_vector_append(self, x)
+
+    def empty(self):
+        return _py_interop_summary.index_count_summary_vector_empty(self)
+
+    def size(self):
+        return _py_interop_summary.index_count_summary_vector_size(self)
+
+    def swap(self, v):
+        return _py_interop_summary.index_count_summary_vector_swap(self, v)
+
+    def rbegin(self):
+        return _py_interop_summary.index_count_summary_vector_rbegin(self)
+
+    def rend(self):
+        return _py_interop_summary.index_count_summary_vector_rend(self)
+
+    def clear(self):
+        return _py_interop_summary.index_count_summary_vector_clear(self)
+
+    def get_allocator(self):
+        return _py_interop_summary.index_count_summary_vector_get_allocator(self)
+
+    def pop_back(self):
+        return _py_interop_summary.index_count_summary_vector_pop_back(self)
+
+    def erase(self, *args):
+        return _py_interop_summary.index_count_summary_vector_erase(self, *args)
+
+    def __init__(self, *args):
+        _py_interop_summary.index_count_summary_vector_swiginit(self, _py_interop_summary.new_index_count_summary_vector(*args))
+
+    def push_back(self, x):
+        return _py_interop_summary.index_count_summary_vector_push_back(self, x)
+
+    def front(self):
+        return _py_interop_summary.index_count_summary_vector_front(self)
+
+    def back(self):
+        return _py_interop_summary.index_count_summary_vector_back(self)
+
+    def assign(self, n, x):
+        return _py_interop_summary.index_count_summary_vector_assign(self, n, x)
+
+    def resize(self, *args):
+        return _py_interop_summary.index_count_summary_vector_resize(self, *args)
+
+    def insert(self, *args):
+        return _py_interop_summary.index_count_summary_vector_insert(self, *args)
+
+    def reserve(self, n):
+        return _py_interop_summary.index_count_summary_vector_reserve(self, n)
+
+    def capacity(self):
+        return _py_interop_summary.index_count_summary_vector_capacity(self)
+    __swig_destroy__ = _py_interop_summary.delete_index_count_summary_vector
+
+# Register index_count_summary_vector in _py_interop_summary:
+_py_interop_summary.index_count_summary_vector_swigregister(index_count_summary_vector)
+
+class index_lane_summary_vector(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _py_interop_summary.index_lane_summary_vector___nonzero__(self)
+
+    def __bool__(self):
+        return _py_interop_summary.index_lane_summary_vector___bool__(self)
+
+    def __len__(self):
+        return _py_interop_summary.index_lane_summary_vector___len__(self)
+
+    def __getslice__(self, i, j):
+        return _py_interop_summary.index_lane_summary_vector___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _py_interop_summary.index_lane_summary_vector___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _py_interop_summary.index_lane_summary_vector___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _py_interop_summary.index_lane_summary_vector___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _py_interop_summary.index_lane_summary_vector___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _py_interop_summary.index_lane_summary_vector___setitem__(self, *args)
+
+    def pop(self):
+        return _py_interop_summary.index_lane_summary_vector_pop(self)
+
+    def append(self, x):
+        return _py_interop_summary.index_lane_summary_vector_append(self, x)
+
+    def empty(self):
+        return _py_interop_summary.index_lane_summary_vector_empty(self)
+
+    def size(self):
+        return _py_interop_summary.index_lane_summary_vector_size(self)
+
+    def swap(self, v):
+        return _py_interop_summary.index_lane_summary_vector_swap(self, v)
+
+    def rbegin(self):
+        return _py_interop_summary.index_lane_summary_vector_rbegin(self)
+
+    def rend(self):
+        return _py_interop_summary.index_lane_summary_vector_rend(self)
+
+    def clear(self):
+        return _py_interop_summary.index_lane_summary_vector_clear(self)
+
+    def get_allocator(self):
+        return _py_interop_summary.index_lane_summary_vector_get_allocator(self)
+
+    def pop_back(self):
+        return _py_interop_summary.index_lane_summary_vector_pop_back(self)
+
+    def erase(self, *args):
+        return _py_interop_summary.index_lane_summary_vector_erase(self, *args)
+
+    def __init__(self, *args):
+        _py_interop_summary.index_lane_summary_vector_swiginit(self, _py_interop_summary.new_index_lane_summary_vector(*args))
+
+    def push_back(self, x):
+        return _py_interop_summary.index_lane_summary_vector_push_back(self, x)
+
+    def front(self):
+        return _py_interop_summary.index_lane_summary_vector_front(self)
+
+    def back(self):
+        return _py_interop_summary.index_lane_summary_vector_back(self)
+
+    def assign(self, n, x):
+        return _py_interop_summary.index_lane_summary_vector_assign(self, n, x)
+
+    def resize(self, *args):
+        return _py_interop_summary.index_lane_summary_vector_resize(self, *args)
+
+    def insert(self, *args):
+        return _py_interop_summary.index_lane_summary_vector_insert(self, *args)
+
+    def reserve(self, n):
+        return _py_interop_summary.index_lane_summary_vector_reserve(self, n)
+
+    def capacity(self):
+        return _py_interop_summary.index_lane_summary_vector_capacity(self)
+    __swig_destroy__ = _py_interop_summary.delete_index_lane_summary_vector
+
+# Register index_lane_summary_vector in _py_interop_summary:
+_py_interop_summary.index_lane_summary_vector_swigregister(index_lane_summary_vector)
+
+
+def summarize_index_metrics(*args):
+    return _py_interop_summary.summarize_index_metrics(*args)
+
+
```

## interop/py_interop_table.py

```diff
@@ -1,499 +1,516 @@
-# This file was automatically generated by SWIG (https://www.swig.org).
-# Version 4.1.1
-#
-# Do not make changes to this file unless you know what you are doing - modify
-# the SWIG interface file instead.
-
-from sys import version_info as _swig_python_version_info
-# Import the low-level C/C++ module
-if __package__ or "." in __name__:
-    from . import _py_interop_table
-else:
-    import _py_interop_table
-
-try:
-    import builtins as __builtin__
-except ImportError:
-    import __builtin__
-
-def _swig_repr(self):
-    try:
-        strthis = "proxy of " + self.this.__repr__()
-    except __builtin__.Exception:
-        strthis = ""
-    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)
-
-
-def _swig_setattr_nondynamic_instance_variable(set):
-    def set_instance_attr(self, name, value):
-        if name == "this":
-            set(self, name, value)
-        elif name == "thisown":
-            self.this.own(value)
-        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
-            set(self, name, value)
-        else:
-            raise AttributeError("You cannot add instance attributes to %s" % self)
-    return set_instance_attr
-
-
-def _swig_setattr_nondynamic_class_variable(set):
-    def set_class_attr(cls, name, value):
-        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
-            set(cls, name, value)
-        else:
-            raise AttributeError("You cannot add class attributes to %s" % cls)
-    return set_class_attr
-
-
-def _swig_add_metaclass(metaclass):
-    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
-    def wrapper(cls):
-        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
-    return wrapper
-
-
-class _SwigNonDynamicMeta(type):
-    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
-    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)
-
-
-class SwigPyIterator(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-
-    def __init__(self, *args, **kwargs):
-        raise AttributeError("No constructor defined - class is abstract")
-    __repr__ = _swig_repr
-    __swig_destroy__ = _py_interop_table.delete_SwigPyIterator
-
-    def value(self):
-        return _py_interop_table.SwigPyIterator_value(self)
-
-    def incr(self, n=1):
-        return _py_interop_table.SwigPyIterator_incr(self, n)
-
-    def decr(self, n=1):
-        return _py_interop_table.SwigPyIterator_decr(self, n)
-
-    def distance(self, x):
-        return _py_interop_table.SwigPyIterator_distance(self, x)
-
-    def equal(self, x):
-        return _py_interop_table.SwigPyIterator_equal(self, x)
-
-    def copy(self):
-        return _py_interop_table.SwigPyIterator_copy(self)
-
-    def next(self):
-        return _py_interop_table.SwigPyIterator_next(self)
-
-    def __next__(self):
-        return _py_interop_table.SwigPyIterator___next__(self)
-
-    def previous(self):
-        return _py_interop_table.SwigPyIterator_previous(self)
-
-    def advance(self, n):
-        return _py_interop_table.SwigPyIterator_advance(self, n)
-
-    def __eq__(self, x):
-        return _py_interop_table.SwigPyIterator___eq__(self, x)
-
-    def __ne__(self, x):
-        return _py_interop_table.SwigPyIterator___ne__(self, x)
-
-    def __iadd__(self, n):
-        return _py_interop_table.SwigPyIterator___iadd__(self, n)
-
-    def __isub__(self, n):
-        return _py_interop_table.SwigPyIterator___isub__(self, n)
-
-    def __add__(self, n):
-        return _py_interop_table.SwigPyIterator___add__(self, n)
-
-    def __sub__(self, *args):
-        return _py_interop_table.SwigPyIterator___sub__(self, *args)
-    def __iter__(self):
-        return self
-
-# Register SwigPyIterator in _py_interop_table:
-_py_interop_table.SwigPyIterator_swigregister(SwigPyIterator)
-import interop.py_interop_run
-import interop.py_interop_metrics
-import interop.py_interop_run_metrics
-import interop.py_interop_comm
-class map_id_offset(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _py_interop_table.map_id_offset___nonzero__(self)
-
-    def __bool__(self):
-        return _py_interop_table.map_id_offset___bool__(self)
-
-    def __len__(self):
-        return _py_interop_table.map_id_offset___len__(self)
-    def __iter__(self):
-        return self.key_iterator()
-    def iterkeys(self):
-        return self.key_iterator()
-    def itervalues(self):
-        return self.value_iterator()
-    def iteritems(self):
-        return self.iterator()
-
-    def __getitem__(self, key):
-        return _py_interop_table.map_id_offset___getitem__(self, key)
-
-    def __delitem__(self, key):
-        return _py_interop_table.map_id_offset___delitem__(self, key)
-
-    def has_key(self, key):
-        return _py_interop_table.map_id_offset_has_key(self, key)
-
-    def keys(self):
-        return _py_interop_table.map_id_offset_keys(self)
-
-    def values(self):
-        return _py_interop_table.map_id_offset_values(self)
-
-    def items(self):
-        return _py_interop_table.map_id_offset_items(self)
-
-    def __contains__(self, key):
-        return _py_interop_table.map_id_offset___contains__(self, key)
-
-    def key_iterator(self):
-        return _py_interop_table.map_id_offset_key_iterator(self)
-
-    def value_iterator(self):
-        return _py_interop_table.map_id_offset_value_iterator(self)
-
-    def __setitem__(self, *args):
-        return _py_interop_table.map_id_offset___setitem__(self, *args)
-
-    def asdict(self):
-        return _py_interop_table.map_id_offset_asdict(self)
-
-    def __init__(self, *args):
-        _py_interop_table.map_id_offset_swiginit(self, _py_interop_table.new_map_id_offset(*args))
-
-    def empty(self):
-        return _py_interop_table.map_id_offset_empty(self)
-
-    def size(self):
-        return _py_interop_table.map_id_offset_size(self)
-
-    def swap(self, v):
-        return _py_interop_table.map_id_offset_swap(self, v)
-
-    def rbegin(self):
-        return _py_interop_table.map_id_offset_rbegin(self)
-
-    def rend(self):
-        return _py_interop_table.map_id_offset_rend(self)
-
-    def clear(self):
-        return _py_interop_table.map_id_offset_clear(self)
-
-    def get_allocator(self):
-        return _py_interop_table.map_id_offset_get_allocator(self)
-
-    def count(self, x):
-        return _py_interop_table.map_id_offset_count(self, x)
-
-    def erase(self, *args):
-        return _py_interop_table.map_id_offset_erase(self, *args)
-
-    def find(self, x):
-        return _py_interop_table.map_id_offset_find(self, x)
-
-    def lower_bound(self, x):
-        return _py_interop_table.map_id_offset_lower_bound(self, x)
-
-    def upper_bound(self, x):
-        return _py_interop_table.map_id_offset_upper_bound(self, x)
-    __swig_destroy__ = _py_interop_table.delete_map_id_offset
-
-# Register map_id_offset in _py_interop_table:
-_py_interop_table.map_id_offset_swigregister(map_id_offset)
-LaneColumn = _py_interop_table.LaneColumn
-TileColumn = _py_interop_table.TileColumn
-CycleColumn = _py_interop_table.CycleColumn
-ReadColumn = _py_interop_table.ReadColumn
-CycleWithinReadColumn = _py_interop_table.CycleWithinReadColumn
-DensityKPermm2Column = _py_interop_table.DensityKPermm2Column
-DensityPfKPermm2Column = _py_interop_table.DensityPfKPermm2Column
-ClusterCountKColumn = _py_interop_table.ClusterCountKColumn
-ClusterCountPfKColumn = _py_interop_table.ClusterCountPfKColumn
-PercentPassFilterColumn = _py_interop_table.PercentPassFilterColumn
-PercentAlignedColumn = _py_interop_table.PercentAlignedColumn
-LegacyPhasingRateColumn = _py_interop_table.LegacyPhasingRateColumn
-LegacyPrephasingRateColumn = _py_interop_table.LegacyPrephasingRateColumn
-ErrorRateColumn = _py_interop_table.ErrorRateColumn
-PercentGreaterThanQ20Column = _py_interop_table.PercentGreaterThanQ20Column
-PercentGreaterThanQ30Column = _py_interop_table.PercentGreaterThanQ30Column
-P90Column = _py_interop_table.P90Column
-PercentNoCallsColumn = _py_interop_table.PercentNoCallsColumn
-PercentBaseColumn = _py_interop_table.PercentBaseColumn
-FwhmColumn = _py_interop_table.FwhmColumn
-CorrectedColumn = _py_interop_table.CorrectedColumn
-CalledColumn = _py_interop_table.CalledColumn
-SignalToNoiseColumn = _py_interop_table.SignalToNoiseColumn
-PhasingWeightColumn = _py_interop_table.PhasingWeightColumn
-PrephasingWeightColumn = _py_interop_table.PrephasingWeightColumn
-PhasingSlopeColumn = _py_interop_table.PhasingSlopeColumn
-PhasingOffsetColumn = _py_interop_table.PhasingOffsetColumn
-PrephasingSlopeColumn = _py_interop_table.PrephasingSlopeColumn
-PrephasingOffsetColumn = _py_interop_table.PrephasingOffsetColumn
-MinimumContrastColumn = _py_interop_table.MinimumContrastColumn
-MaximumContrastColumn = _py_interop_table.MaximumContrastColumn
-SurfaceColumn = _py_interop_table.SurfaceColumn
-SwathColumn = _py_interop_table.SwathColumn
-SectionColumn = _py_interop_table.SectionColumn
-TileNumberColumn = _py_interop_table.TileNumberColumn
-ClusterCountOccupiedKColumn = _py_interop_table.ClusterCountOccupiedKColumn
-PercentOccupiedColumn = _py_interop_table.PercentOccupiedColumn
-ImagingColumnCount = _py_interop_table.ImagingColumnCount
-UnknownColumnId = _py_interop_table.UnknownColumnId
-class imaging_column(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, *args):
-        _py_interop_table.imaging_column_swiginit(self, _py_interop_table.new_imaging_column(*args))
-
-    def name(self):
-        return _py_interop_table.imaging_column_name(self)
-
-    def has_children(self):
-        return _py_interop_table.imaging_column_has_children(self)
-
-    def subcolumns(self):
-        return _py_interop_table.imaging_column_subcolumns(self)
-
-    def full_name(self, sub_index):
-        return _py_interop_table.imaging_column_full_name(self, sub_index)
-
-    def offset(self, *args):
-        return _py_interop_table.imaging_column_offset(self, *args)
-
-    def id(self, *args):
-        return _py_interop_table.imaging_column_id(self, *args)
-
-    def parse_header_for_id(self, header):
-        return _py_interop_table.imaging_column_parse_header_for_id(self, header)
-
-    def size(self):
-        return _py_interop_table.imaging_column_size(self)
-
-    def column_count(self):
-        return _py_interop_table.imaging_column_column_count(self)
-
-    @staticmethod
-    def to_header(*args):
-        return _py_interop_table.imaging_column_to_header(*args)
-
-    @staticmethod
-    def to_name(*args):
-        return _py_interop_table.imaging_column_to_name(*args)
-    __swig_destroy__ = _py_interop_table.delete_imaging_column
-
-# Register imaging_column in _py_interop_table:
-_py_interop_table.imaging_column_swigregister(imaging_column)
-class imaging_table(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self):
-        _py_interop_table.imaging_table_swiginit(self, _py_interop_table.new_imaging_table())
-
-    def set_data(self, rows, cols, data):
-        return _py_interop_table.imaging_table_set_data(self, rows, cols, data)
-
-    def at(self, r, c, subcol=0):
-        return _py_interop_table.imaging_table_at(self, r, c, subcol)
-
-    def columns(self):
-        return _py_interop_table.imaging_table_columns(self)
-
-    def empty(self):
-        return _py_interop_table.imaging_table_empty(self)
-
-    def clear(self):
-        return _py_interop_table.imaging_table_clear(self)
-
-    def column_at(self, col_index):
-        return _py_interop_table.imaging_table_column_at(self, col_index)
-
-    def column_count(self):
-        return _py_interop_table.imaging_table_column_count(self)
-
-    def total_column_count(self):
-        return _py_interop_table.imaging_table_total_column_count(self)
-
-    def row_count(self):
-        return _py_interop_table.imaging_table_row_count(self)
-    __swig_destroy__ = _py_interop_table.delete_imaging_table
-
-# Register imaging_table in _py_interop_table:
-_py_interop_table.imaging_table_swigregister(imaging_table)
-class imaging_table_id_less(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, table):
-        _py_interop_table.imaging_table_id_less_swiginit(self, _py_interop_table.new_imaging_table_id_less(table))
-    __swig_destroy__ = _py_interop_table.delete_imaging_table_id_less
-
-# Register imaging_table_id_less in _py_interop_table:
-_py_interop_table.imaging_table_id_less_swigregister(imaging_table_id_less)
-class invalid_column_type(interop.py_interop_run.base_exception):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-
-    def __init__(self, mesg):
-        _py_interop_table.invalid_column_type_swiginit(self, _py_interop_table.new_invalid_column_type(mesg))
-
-    def __str__(self):
-        return _py_interop_table.invalid_column_type___str__(self)
-    __swig_destroy__ = _py_interop_table.delete_invalid_column_type
-
-# Register invalid_column_type in _py_interop_table:
-_py_interop_table.invalid_column_type_swigregister(invalid_column_type)
-class imaging_column_vector(object):
-    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
-    __repr__ = _swig_repr
-    def __iter__(self):
-        return self.iterator()
-
-    def __nonzero__(self):
-        return _py_interop_table.imaging_column_vector___nonzero__(self)
-
-    def __bool__(self):
-        return _py_interop_table.imaging_column_vector___bool__(self)
-
-    def __len__(self):
-        return _py_interop_table.imaging_column_vector___len__(self)
-
-    def __getslice__(self, i, j):
-        return _py_interop_table.imaging_column_vector___getslice__(self, i, j)
-
-    def __setslice__(self, *args):
-        return _py_interop_table.imaging_column_vector___setslice__(self, *args)
-
-    def __delslice__(self, i, j):
-        return _py_interop_table.imaging_column_vector___delslice__(self, i, j)
-
-    def __delitem__(self, *args):
-        return _py_interop_table.imaging_column_vector___delitem__(self, *args)
-
-    def __getitem__(self, *args):
-        return _py_interop_table.imaging_column_vector___getitem__(self, *args)
-
-    def __setitem__(self, *args):
-        return _py_interop_table.imaging_column_vector___setitem__(self, *args)
-
-    def pop(self):
-        return _py_interop_table.imaging_column_vector_pop(self)
-
-    def append(self, x):
-        return _py_interop_table.imaging_column_vector_append(self, x)
-
-    def empty(self):
-        return _py_interop_table.imaging_column_vector_empty(self)
-
-    def size(self):
-        return _py_interop_table.imaging_column_vector_size(self)
-
-    def swap(self, v):
-        return _py_interop_table.imaging_column_vector_swap(self, v)
-
-    def rbegin(self):
-        return _py_interop_table.imaging_column_vector_rbegin(self)
-
-    def rend(self):
-        return _py_interop_table.imaging_column_vector_rend(self)
-
-    def clear(self):
-        return _py_interop_table.imaging_column_vector_clear(self)
-
-    def get_allocator(self):
-        return _py_interop_table.imaging_column_vector_get_allocator(self)
-
-    def pop_back(self):
-        return _py_interop_table.imaging_column_vector_pop_back(self)
-
-    def erase(self, *args):
-        return _py_interop_table.imaging_column_vector_erase(self, *args)
-
-    def __init__(self, *args):
-        _py_interop_table.imaging_column_vector_swiginit(self, _py_interop_table.new_imaging_column_vector(*args))
-
-    def push_back(self, x):
-        return _py_interop_table.imaging_column_vector_push_back(self, x)
-
-    def front(self):
-        return _py_interop_table.imaging_column_vector_front(self)
-
-    def back(self):
-        return _py_interop_table.imaging_column_vector_back(self)
-
-    def assign(self, n, x):
-        return _py_interop_table.imaging_column_vector_assign(self, n, x)
-
-    def resize(self, *args):
-        return _py_interop_table.imaging_column_vector_resize(self, *args)
-
-    def insert(self, *args):
-        return _py_interop_table.imaging_column_vector_insert(self, *args)
-
-    def reserve(self, n):
-        return _py_interop_table.imaging_column_vector_reserve(self, n)
-
-    def capacity(self):
-        return _py_interop_table.imaging_column_vector_capacity(self)
-    __swig_destroy__ = _py_interop_table.delete_imaging_column_vector
-
-# Register imaging_column_vector in _py_interop_table:
-_py_interop_table.imaging_column_vector_swigregister(imaging_column_vector)
-
-def populate_imaging_table_data(metrics, columns, row_offset, data_beg):
-    return _py_interop_table.populate_imaging_table_data(metrics, columns, row_offset, data_beg)
-
-def count_table_rows(metrics, row_offset):
-    return _py_interop_table.count_table_rows(metrics, row_offset)
-
-def count_table_columns(columns):
-    return _py_interop_table.count_table_columns(columns)
-
-def create_imaging_table(metrics, table):
-    return _py_interop_table.create_imaging_table(metrics, table)
-
-def list_imaging_table_metrics_to_load(valid_to_load):
-    return _py_interop_table.list_imaging_table_metrics_to_load(valid_to_load)
-
-def max_digits():
-    return _py_interop_table.max_digits()
-
-def get_column_rounding(index):
-    return _py_interop_table.get_column_rounding(index)
-
-def populate_column_offsets(columns):
-    return _py_interop_table.populate_column_offsets(columns)
-
-def create_imaging_table_columns(*args):
-    return _py_interop_table.create_imaging_table_columns(*args)
-
-def list_column_id(vec, skip=0):
-    return _py_interop_table.list_column_id(vec, skip)
-
-def parse_column_id(name):
-    return _py_interop_table.parse_column_id(name)
-
-def to_string_column_id(value):
-    return _py_interop_table.to_string_column_id(value)
-
+# This file was automatically generated by SWIG (http://www.swig.org).
+# Version 4.0.2
+#
+# Do not make changes to this file unless you know what you are doing--modify
+# the SWIG interface file instead.
+
+from sys import version_info as _swig_python_version_info
+if _swig_python_version_info < (2, 7, 0):
+    raise RuntimeError("Python 2.7 or later required")
+
+# Import the low-level C/C++ module
+if __package__ or "." in __name__:
+    from . import _py_interop_table
+else:
+    import _py_interop_table
+
+try:
+    import builtins as __builtin__
+except ImportError:
+    import __builtin__
+
+def _swig_repr(self):
+    try:
+        strthis = "proxy of " + self.this.__repr__()
+    except __builtin__.Exception:
+        strthis = ""
+    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)
+
+
+def _swig_setattr_nondynamic_instance_variable(set):
+    def set_instance_attr(self, name, value):
+        if name == "thisown":
+            self.this.own(value)
+        elif name == "this":
+            set(self, name, value)
+        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
+            set(self, name, value)
+        else:
+            raise AttributeError("You cannot add instance attributes to %s" % self)
+    return set_instance_attr
+
+
+def _swig_setattr_nondynamic_class_variable(set):
+    def set_class_attr(cls, name, value):
+        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
+            set(cls, name, value)
+        else:
+            raise AttributeError("You cannot add class attributes to %s" % cls)
+    return set_class_attr
+
+
+def _swig_add_metaclass(metaclass):
+    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
+    def wrapper(cls):
+        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
+    return wrapper
+
+
+class _SwigNonDynamicMeta(type):
+    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
+    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)
+
+
+class SwigPyIterator(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+
+    def __init__(self, *args, **kwargs):
+        raise AttributeError("No constructor defined - class is abstract")
+    __repr__ = _swig_repr
+    __swig_destroy__ = _py_interop_table.delete_SwigPyIterator
+
+    def value(self):
+        return _py_interop_table.SwigPyIterator_value(self)
+
+    def incr(self, n=1):
+        return _py_interop_table.SwigPyIterator_incr(self, n)
+
+    def decr(self, n=1):
+        return _py_interop_table.SwigPyIterator_decr(self, n)
+
+    def distance(self, x):
+        return _py_interop_table.SwigPyIterator_distance(self, x)
+
+    def equal(self, x):
+        return _py_interop_table.SwigPyIterator_equal(self, x)
+
+    def copy(self):
+        return _py_interop_table.SwigPyIterator_copy(self)
+
+    def next(self):
+        return _py_interop_table.SwigPyIterator_next(self)
+
+    def __next__(self):
+        return _py_interop_table.SwigPyIterator___next__(self)
+
+    def previous(self):
+        return _py_interop_table.SwigPyIterator_previous(self)
+
+    def advance(self, n):
+        return _py_interop_table.SwigPyIterator_advance(self, n)
+
+    def __eq__(self, x):
+        return _py_interop_table.SwigPyIterator___eq__(self, x)
+
+    def __ne__(self, x):
+        return _py_interop_table.SwigPyIterator___ne__(self, x)
+
+    def __iadd__(self, n):
+        return _py_interop_table.SwigPyIterator___iadd__(self, n)
+
+    def __isub__(self, n):
+        return _py_interop_table.SwigPyIterator___isub__(self, n)
+
+    def __add__(self, n):
+        return _py_interop_table.SwigPyIterator___add__(self, n)
+
+    def __sub__(self, *args):
+        return _py_interop_table.SwigPyIterator___sub__(self, *args)
+    def __iter__(self):
+        return self
+
+# Register SwigPyIterator in _py_interop_table:
+_py_interop_table.SwigPyIterator_swigregister(SwigPyIterator)
+
+import interop.py_interop_run
+import interop.py_interop_metrics
+import interop.py_interop_run_metrics
+import interop.py_interop_comm
+class map_id_offset(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _py_interop_table.map_id_offset___nonzero__(self)
+
+    def __bool__(self):
+        return _py_interop_table.map_id_offset___bool__(self)
+
+    def __len__(self):
+        return _py_interop_table.map_id_offset___len__(self)
+    def __iter__(self):
+        return self.key_iterator()
+    def iterkeys(self):
+        return self.key_iterator()
+    def itervalues(self):
+        return self.value_iterator()
+    def iteritems(self):
+        return self.iterator()
+
+    def __getitem__(self, key):
+        return _py_interop_table.map_id_offset___getitem__(self, key)
+
+    def __delitem__(self, key):
+        return _py_interop_table.map_id_offset___delitem__(self, key)
+
+    def has_key(self, key):
+        return _py_interop_table.map_id_offset_has_key(self, key)
+
+    def keys(self):
+        return _py_interop_table.map_id_offset_keys(self)
+
+    def values(self):
+        return _py_interop_table.map_id_offset_values(self)
+
+    def items(self):
+        return _py_interop_table.map_id_offset_items(self)
+
+    def __contains__(self, key):
+        return _py_interop_table.map_id_offset___contains__(self, key)
+
+    def key_iterator(self):
+        return _py_interop_table.map_id_offset_key_iterator(self)
+
+    def value_iterator(self):
+        return _py_interop_table.map_id_offset_value_iterator(self)
+
+    def __setitem__(self, *args):
+        return _py_interop_table.map_id_offset___setitem__(self, *args)
+
+    def asdict(self):
+        return _py_interop_table.map_id_offset_asdict(self)
+
+    def __init__(self, *args):
+        _py_interop_table.map_id_offset_swiginit(self, _py_interop_table.new_map_id_offset(*args))
+
+    def empty(self):
+        return _py_interop_table.map_id_offset_empty(self)
+
+    def size(self):
+        return _py_interop_table.map_id_offset_size(self)
+
+    def swap(self, v):
+        return _py_interop_table.map_id_offset_swap(self, v)
+
+    def rbegin(self):
+        return _py_interop_table.map_id_offset_rbegin(self)
+
+    def rend(self):
+        return _py_interop_table.map_id_offset_rend(self)
+
+    def clear(self):
+        return _py_interop_table.map_id_offset_clear(self)
+
+    def get_allocator(self):
+        return _py_interop_table.map_id_offset_get_allocator(self)
+
+    def count(self, x):
+        return _py_interop_table.map_id_offset_count(self, x)
+
+    def erase(self, *args):
+        return _py_interop_table.map_id_offset_erase(self, *args)
+
+    def find(self, x):
+        return _py_interop_table.map_id_offset_find(self, x)
+
+    def lower_bound(self, x):
+        return _py_interop_table.map_id_offset_lower_bound(self, x)
+
+    def upper_bound(self, x):
+        return _py_interop_table.map_id_offset_upper_bound(self, x)
+    __swig_destroy__ = _py_interop_table.delete_map_id_offset
+
+# Register map_id_offset in _py_interop_table:
+_py_interop_table.map_id_offset_swigregister(map_id_offset)
+
+LaneColumn = _py_interop_table.LaneColumn
+TileColumn = _py_interop_table.TileColumn
+CycleColumn = _py_interop_table.CycleColumn
+ReadColumn = _py_interop_table.ReadColumn
+CycleWithinReadColumn = _py_interop_table.CycleWithinReadColumn
+DensityKPermm2Column = _py_interop_table.DensityKPermm2Column
+DensityPfKPermm2Column = _py_interop_table.DensityPfKPermm2Column
+ClusterCountKColumn = _py_interop_table.ClusterCountKColumn
+ClusterCountPfKColumn = _py_interop_table.ClusterCountPfKColumn
+PercentPassFilterColumn = _py_interop_table.PercentPassFilterColumn
+PercentAlignedColumn = _py_interop_table.PercentAlignedColumn
+LegacyPhasingRateColumn = _py_interop_table.LegacyPhasingRateColumn
+LegacyPrephasingRateColumn = _py_interop_table.LegacyPrephasingRateColumn
+ErrorRateColumn = _py_interop_table.ErrorRateColumn
+PercentGreaterThanQ20Column = _py_interop_table.PercentGreaterThanQ20Column
+PercentGreaterThanQ30Column = _py_interop_table.PercentGreaterThanQ30Column
+P90Column = _py_interop_table.P90Column
+PercentNoCallsColumn = _py_interop_table.PercentNoCallsColumn
+PercentBaseColumn = _py_interop_table.PercentBaseColumn
+FwhmColumn = _py_interop_table.FwhmColumn
+CorrectedColumn = _py_interop_table.CorrectedColumn
+CalledColumn = _py_interop_table.CalledColumn
+SignalToNoiseColumn = _py_interop_table.SignalToNoiseColumn
+PhasingWeightColumn = _py_interop_table.PhasingWeightColumn
+PrephasingWeightColumn = _py_interop_table.PrephasingWeightColumn
+PhasingSlopeColumn = _py_interop_table.PhasingSlopeColumn
+PhasingOffsetColumn = _py_interop_table.PhasingOffsetColumn
+PrephasingSlopeColumn = _py_interop_table.PrephasingSlopeColumn
+PrephasingOffsetColumn = _py_interop_table.PrephasingOffsetColumn
+MinimumContrastColumn = _py_interop_table.MinimumContrastColumn
+MaximumContrastColumn = _py_interop_table.MaximumContrastColumn
+SurfaceColumn = _py_interop_table.SurfaceColumn
+SwathColumn = _py_interop_table.SwathColumn
+SectionColumn = _py_interop_table.SectionColumn
+TileNumberColumn = _py_interop_table.TileNumberColumn
+ClusterCountOccupiedKColumn = _py_interop_table.ClusterCountOccupiedKColumn
+PercentOccupiedColumn = _py_interop_table.PercentOccupiedColumn
+ImagingColumnCount = _py_interop_table.ImagingColumnCount
+UnknownColumnId = _py_interop_table.UnknownColumnId
+class imaging_column(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, *args):
+        _py_interop_table.imaging_column_swiginit(self, _py_interop_table.new_imaging_column(*args))
+
+    def name(self):
+        return _py_interop_table.imaging_column_name(self)
+
+    def has_children(self):
+        return _py_interop_table.imaging_column_has_children(self)
+
+    def subcolumns(self):
+        return _py_interop_table.imaging_column_subcolumns(self)
+
+    def full_name(self, sub_index):
+        return _py_interop_table.imaging_column_full_name(self, sub_index)
+
+    def offset(self, *args):
+        return _py_interop_table.imaging_column_offset(self, *args)
+
+    def id(self, *args):
+        return _py_interop_table.imaging_column_id(self, *args)
+
+    def parse_header_for_id(self, header):
+        return _py_interop_table.imaging_column_parse_header_for_id(self, header)
+
+    def size(self):
+        return _py_interop_table.imaging_column_size(self)
+
+    def column_count(self):
+        return _py_interop_table.imaging_column_column_count(self)
+
+    @staticmethod
+    def to_header(*args):
+        return _py_interop_table.imaging_column_to_header(*args)
+
+    @staticmethod
+    def to_name(*args):
+        return _py_interop_table.imaging_column_to_name(*args)
+    __swig_destroy__ = _py_interop_table.delete_imaging_column
+
+# Register imaging_column in _py_interop_table:
+_py_interop_table.imaging_column_swigregister(imaging_column)
+
+def imaging_column_to_header(*args):
+    return _py_interop_table.imaging_column_to_header(*args)
+
+def imaging_column_to_name(*args):
+    return _py_interop_table.imaging_column_to_name(*args)
+
+class imaging_table(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self):
+        _py_interop_table.imaging_table_swiginit(self, _py_interop_table.new_imaging_table())
+
+    def set_data(self, rows, cols, data):
+        return _py_interop_table.imaging_table_set_data(self, rows, cols, data)
+
+    def at(self, r, c, subcol=0):
+        return _py_interop_table.imaging_table_at(self, r, c, subcol)
+
+    def columns(self):
+        return _py_interop_table.imaging_table_columns(self)
+
+    def empty(self):
+        return _py_interop_table.imaging_table_empty(self)
+
+    def clear(self):
+        return _py_interop_table.imaging_table_clear(self)
+
+    def column_at(self, col_index):
+        return _py_interop_table.imaging_table_column_at(self, col_index)
+
+    def column_count(self):
+        return _py_interop_table.imaging_table_column_count(self)
+
+    def total_column_count(self):
+        return _py_interop_table.imaging_table_total_column_count(self)
+
+    def row_count(self):
+        return _py_interop_table.imaging_table_row_count(self)
+    __swig_destroy__ = _py_interop_table.delete_imaging_table
+
+# Register imaging_table in _py_interop_table:
+_py_interop_table.imaging_table_swigregister(imaging_table)
+
+class imaging_table_id_less(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, table):
+        _py_interop_table.imaging_table_id_less_swiginit(self, _py_interop_table.new_imaging_table_id_less(table))
+    __swig_destroy__ = _py_interop_table.delete_imaging_table_id_less
+
+# Register imaging_table_id_less in _py_interop_table:
+_py_interop_table.imaging_table_id_less_swigregister(imaging_table_id_less)
+
+class invalid_column_type(interop.py_interop_run.base_exception):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+
+    def __init__(self, mesg):
+        _py_interop_table.invalid_column_type_swiginit(self, _py_interop_table.new_invalid_column_type(mesg))
+
+    def __str__(self):
+        return _py_interop_table.invalid_column_type___str__(self)
+    __swig_destroy__ = _py_interop_table.delete_invalid_column_type
+
+# Register invalid_column_type in _py_interop_table:
+_py_interop_table.invalid_column_type_swigregister(invalid_column_type)
+
+class imaging_column_vector(object):
+    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
+    __repr__ = _swig_repr
+    def __iter__(self):
+        return self.iterator()
+
+    def __nonzero__(self):
+        return _py_interop_table.imaging_column_vector___nonzero__(self)
+
+    def __bool__(self):
+        return _py_interop_table.imaging_column_vector___bool__(self)
+
+    def __len__(self):
+        return _py_interop_table.imaging_column_vector___len__(self)
+
+    def __getslice__(self, i, j):
+        return _py_interop_table.imaging_column_vector___getslice__(self, i, j)
+
+    def __setslice__(self, *args):
+        return _py_interop_table.imaging_column_vector___setslice__(self, *args)
+
+    def __delslice__(self, i, j):
+        return _py_interop_table.imaging_column_vector___delslice__(self, i, j)
+
+    def __delitem__(self, *args):
+        return _py_interop_table.imaging_column_vector___delitem__(self, *args)
+
+    def __getitem__(self, *args):
+        return _py_interop_table.imaging_column_vector___getitem__(self, *args)
+
+    def __setitem__(self, *args):
+        return _py_interop_table.imaging_column_vector___setitem__(self, *args)
+
+    def pop(self):
+        return _py_interop_table.imaging_column_vector_pop(self)
+
+    def append(self, x):
+        return _py_interop_table.imaging_column_vector_append(self, x)
+
+    def empty(self):
+        return _py_interop_table.imaging_column_vector_empty(self)
+
+    def size(self):
+        return _py_interop_table.imaging_column_vector_size(self)
+
+    def swap(self, v):
+        return _py_interop_table.imaging_column_vector_swap(self, v)
+
+    def rbegin(self):
+        return _py_interop_table.imaging_column_vector_rbegin(self)
+
+    def rend(self):
+        return _py_interop_table.imaging_column_vector_rend(self)
+
+    def clear(self):
+        return _py_interop_table.imaging_column_vector_clear(self)
+
+    def get_allocator(self):
+        return _py_interop_table.imaging_column_vector_get_allocator(self)
+
+    def pop_back(self):
+        return _py_interop_table.imaging_column_vector_pop_back(self)
+
+    def erase(self, *args):
+        return _py_interop_table.imaging_column_vector_erase(self, *args)
+
+    def __init__(self, *args):
+        _py_interop_table.imaging_column_vector_swiginit(self, _py_interop_table.new_imaging_column_vector(*args))
+
+    def push_back(self, x):
+        return _py_interop_table.imaging_column_vector_push_back(self, x)
+
+    def front(self):
+        return _py_interop_table.imaging_column_vector_front(self)
+
+    def back(self):
+        return _py_interop_table.imaging_column_vector_back(self)
+
+    def assign(self, n, x):
+        return _py_interop_table.imaging_column_vector_assign(self, n, x)
+
+    def resize(self, *args):
+        return _py_interop_table.imaging_column_vector_resize(self, *args)
+
+    def insert(self, *args):
+        return _py_interop_table.imaging_column_vector_insert(self, *args)
+
+    def reserve(self, n):
+        return _py_interop_table.imaging_column_vector_reserve(self, n)
+
+    def capacity(self):
+        return _py_interop_table.imaging_column_vector_capacity(self)
+    __swig_destroy__ = _py_interop_table.delete_imaging_column_vector
+
+# Register imaging_column_vector in _py_interop_table:
+_py_interop_table.imaging_column_vector_swigregister(imaging_column_vector)
+
+
+def populate_imaging_table_data(metrics, columns, row_offset, data_beg):
+    return _py_interop_table.populate_imaging_table_data(metrics, columns, row_offset, data_beg)
+
+def count_table_rows(metrics, row_offset):
+    return _py_interop_table.count_table_rows(metrics, row_offset)
+
+def count_table_columns(columns):
+    return _py_interop_table.count_table_columns(columns)
+
+def create_imaging_table(metrics, table):
+    return _py_interop_table.create_imaging_table(metrics, table)
+
+def list_imaging_table_metrics_to_load(valid_to_load):
+    return _py_interop_table.list_imaging_table_metrics_to_load(valid_to_load)
+
+def max_digits():
+    return _py_interop_table.max_digits()
+
+def get_column_rounding(index):
+    return _py_interop_table.get_column_rounding(index)
+
+def populate_column_offsets(columns):
+    return _py_interop_table.populate_column_offsets(columns)
+
+def create_imaging_table_columns(*args):
+    return _py_interop_table.create_imaging_table_columns(*args)
+
+def list_column_id(vec, skip=0):
+    return _py_interop_table.list_column_id(vec, skip)
+
+def parse_column_id(name):
+    return _py_interop_table.parse_column_id(name)
+
+def to_string_column_id(value):
+    return _py_interop_table.to_string_column_id(value)
+
+
```

