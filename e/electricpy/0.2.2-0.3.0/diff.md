# Comparing `tmp/electricpy-0.2.2.tar.gz` & `tmp/electricpy-0.3.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "electricpy-0.2.2.tar", last modified: Fri May  6 17:49:50 2022, max compression
+gzip compressed data, was "electricpy-0.3.0.tar", last modified: Sat May 13 05:33:39 2023, max compression
```

## Comparing `electricpy-0.2.2.tar` & `electricpy-0.3.0.tar`

### file list

```diff
@@ -1,37 +1,23 @@
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-05-06 17:49:50.362894 electricpy-0.2.2/
--rw-r--r--   0 runner    (1001) docker     (121)     1068 2022-05-06 17:48:59.000000 electricpy-0.2.2/LICENSE
--rw-r--r--   0 runner    (1001) docker     (121)       50 2022-05-06 17:48:59.000000 electricpy-0.2.2/MANIFEST.in
--rw-r--r--   0 runner    (1001) docker     (121)     6379 2022-05-06 17:49:50.362894 electricpy-0.2.2/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (121)     5681 2022-05-06 17:48:59.000000 electricpy-0.2.2/README.md
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-05-06 17:49:50.358894 electricpy-0.2.2/electricpy/
--rw-r--r--   0 runner    (1001) docker     (121)   164481 2022-05-06 17:48:59.000000 electricpy-0.2.2/electricpy/__init__.py
--rw-r--r--   0 runner    (1001) docker     (121)    12681 2022-05-06 17:48:59.000000 electricpy-0.2.2/electricpy/bode.py
--rw-r--r--   0 runner    (1001) docker     (121)    11434 2022-05-06 17:48:59.000000 electricpy-0.2.2/electricpy/constants.py
--rw-r--r--   0 runner    (1001) docker     (121)    10727 2022-05-06 17:48:59.000000 electricpy-0.2.2/electricpy/conversions.py
--rw-r--r--   0 runner    (1001) docker     (121)    65683 2022-05-06 17:48:59.000000 electricpy-0.2.2/electricpy/fault.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-05-06 17:49:50.358894 electricpy-0.2.2/electricpy/geometry/
--rw-r--r--   0 runner    (1001) docker     (121)     9068 2022-05-06 17:48:59.000000 electricpy-0.2.2/electricpy/geometry/__init__.py
--rw-r--r--   0 runner    (1001) docker     (121)     6092 2022-05-06 17:48:59.000000 electricpy-0.2.2/electricpy/geometry/circle.py
--rw-r--r--   0 runner    (1001) docker     (121)     3413 2022-05-06 17:48:59.000000 electricpy-0.2.2/electricpy/geometry/triangle.py
--rw-r--r--   0 runner    (1001) docker     (121)     7568 2022-05-06 17:48:59.000000 electricpy-0.2.2/electricpy/latex.py
--rw-r--r--   0 runner    (1001) docker     (121)     7439 2022-05-06 17:48:59.000000 electricpy-0.2.2/electricpy/math.py
--rw-r--r--   0 runner    (1001) docker     (121)    14391 2022-05-06 17:48:59.000000 electricpy-0.2.2/electricpy/passive.py
--rw-r--r--   0 runner    (1001) docker     (121)    17012 2022-05-06 17:48:59.000000 electricpy-0.2.2/electricpy/phasor.py
--rw-r--r--   0 runner    (1001) docker     (121)    46481 2022-05-06 17:48:59.000000 electricpy-0.2.2/electricpy/sim.py
--rw-r--r--   0 runner    (1001) docker     (121)    25407 2022-05-06 17:48:59.000000 electricpy-0.2.2/electricpy/visu.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-05-06 17:49:50.358894 electricpy-0.2.2/electricpy.egg-info/
--rw-r--r--   0 runner    (1001) docker     (121)     6379 2022-05-06 17:49:49.000000 electricpy-0.2.2/electricpy.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (121)      675 2022-05-06 17:49:50.000000 electricpy-0.2.2/electricpy.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (121)        1 2022-05-06 17:49:49.000000 electricpy-0.2.2/electricpy.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (121)       42 2022-05-06 17:49:50.000000 electricpy-0.2.2/electricpy.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (121)       16 2022-05-06 17:49:50.000000 electricpy-0.2.2/electricpy.egg-info/top_level.txt
--rw-r--r--   0 runner    (1001) docker     (121)       42 2022-05-06 17:48:59.000000 electricpy-0.2.2/requirements.txt
--rw-r--r--   0 runner    (1001) docker     (121)       38 2022-05-06 17:49:50.362894 electricpy-0.2.2/setup.cfg
--rw-r--r--   0 runner    (1001) docker     (121)     1621 2022-05-06 17:48:59.000000 electricpy-0.2.2/setup.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-05-06 17:49:50.362894 electricpy-0.2.2/test/
--rw-r--r--   0 runner    (1001) docker     (121)     1422 2022-05-06 17:48:59.000000 electricpy-0.2.2/test/__init__.py
--rw-r--r--   0 runner    (1001) docker     (121)     2310 2022-05-06 17:48:59.000000 electricpy-0.2.2/test/test_circle.py
--rw-r--r--   0 runner    (1001) docker     (121)    15413 2022-05-06 17:48:59.000000 electricpy-0.2.2/test/test_electricpy.py
--rw-r--r--   0 runner    (1001) docker     (121)     5205 2022-05-06 17:48:59.000000 electricpy-0.2.2/test/test_geometry.py
--rw-r--r--   0 runner    (1001) docker     (121)     1629 2022-05-06 17:48:59.000000 electricpy-0.2.2/test/test_imports.py
--rw-r--r--   0 runner    (1001) docker     (121)     3869 2022-05-06 17:48:59.000000 electricpy-0.2.2/test/test_triangle.py
+-rw-r--r--   0        0        0     1068 2023-05-13 05:32:53.996497 electricpy-0.3.0/LICENSE
+-rw-r--r--   0        0        0     7831 2023-05-13 05:32:53.996497 electricpy-0.3.0/README.md
+-rw-r--r--   0        0        0   110969 2023-05-13 05:32:54.000497 electricpy-0.3.0/electricpy/__init__.py
+-rw-r--r--   0        0        0      378 2023-05-13 05:32:54.000497 electricpy-0.3.0/electricpy/active/__init__.py
+-rw-r--r--   0        0        0    12002 2023-05-13 05:32:54.000497 electricpy-0.3.0/electricpy/bode.py
+-rw-r--r--   0        0        0     7281 2023-05-13 05:32:54.000497 electricpy-0.3.0/electricpy/compute.py
+-rw-r--r--   0        0        0    11577 2023-05-13 05:32:54.000497 electricpy-0.3.0/electricpy/constants.py
+-rw-r--r--   0        0        0    16417 2023-05-13 05:32:54.000497 electricpy-0.3.0/electricpy/conversions.py
+-rw-r--r--   0        0        0    66227 2023-05-13 05:32:54.000497 electricpy-0.3.0/electricpy/fault.py
+-rw-r--r--   0        0        0     9351 2023-05-13 05:32:54.000497 electricpy-0.3.0/electricpy/geometry/__init__.py
+-rw-r--r--   0        0        0     6092 2023-05-13 05:32:54.000497 electricpy-0.3.0/electricpy/geometry/circle.py
+-rw-r--r--   0        0        0     3413 2023-05-13 05:32:54.000497 electricpy-0.3.0/electricpy/geometry/triangle.py
+-rw-r--r--   0        0        0     7587 2023-05-13 05:32:54.000497 electricpy-0.3.0/electricpy/latex.py
+-rw-r--r--   0        0        0    43391 2023-05-13 05:32:54.000497 electricpy-0.3.0/electricpy/machines.py
+-rw-r--r--   0        0        0     7405 2023-05-13 05:32:54.000497 electricpy-0.3.0/electricpy/math.py
+-rw-r--r--   0        0        0    14583 2023-05-13 05:32:54.000497 electricpy-0.3.0/electricpy/passive.py
+-rw-r--r--   0        0        0    12427 2023-05-13 05:32:54.000497 electricpy-0.3.0/electricpy/phasors.py
+-rw-r--r--   0        0        0    47360 2023-05-13 05:32:54.000497 electricpy-0.3.0/electricpy/sim.py
+-rw-r--r--   0        0        0     8335 2023-05-13 05:32:54.000497 electricpy-0.3.0/electricpy/thermal.py
+-rw-r--r--   0        0        0      367 2023-05-13 05:32:54.000497 electricpy-0.3.0/electricpy/version.py
+-rw-r--r--   0        0        0    34914 2023-05-13 05:32:54.000497 electricpy-0.3.0/electricpy/visu.py
+-rw-r--r--   0        0        0     1480 2023-05-13 05:32:54.004498 electricpy-0.3.0/pyproject.toml
+-rw-r--r--   0        0        0     9185 1970-01-01 00:00:00.000000 electricpy-0.3.0/PKG-INFO
```

### Comparing `electricpy-0.2.2/LICENSE` & `electricpy-0.3.0/LICENSE`

 * *Files identical despite different names*

### Comparing `electricpy-0.2.2/README.md` & `electricpy-0.3.0/PKG-INFO`

 * *Files 26% similar despite different names*

```diff
@@ -1,356 +1,575 @@
-00000000: 3c69 6d67 2073 7263 3d22 6874 7470 733a  <img src="https:
-00000010: 2f2f 7261 772e 6769 7468 7562 7573 6572  //raw.githubuser
-00000020: 636f 6e74 656e 742e 636f 6d2f 656e 6769  content.com/engi
-00000030: 6e65 6572 6a6f 6534 3430 2f45 6c65 6374  neerjoe440/Elect
-00000040: 7269 6350 792f 6d61 7374 6572 2f6c 6f67  ricPy/master/log
-00000050: 6f2f 456c 6563 7472 6963 7079 4c6f 676f  o/ElectricpyLogo
-00000060: 2e73 7667 2220 7769 6474 683d 2232 3030  .svg" width="200
-00000070: 2220 616c 743d 226c 6f67 6f22 2061 6c69  " alt="logo" ali
-00000080: 676e 3d22 7269 6768 7422 3e0a 0a23 2045  gn="right">..# E
-00000090: 6c65 6374 7269 6350 790a 0a2a 456c 6563  lectricPy..*Elec
-000000a0: 7472 6963 616c 2d45 6e67 696e 6565 7269  trical-Engineeri
-000000b0: 6e67 2d66 6f72 2d50 7974 686f 6e2a 0a0a  ng-for-Python*..
-000000c0: 5b21 5b73 7068 696e 785d 2868 7474 7073  [![sphinx](https
-000000d0: 3a2f 2f67 6974 6875 622e 636f 6d2f 656e  ://github.com/en
-000000e0: 6769 6e65 6572 6a6f 6534 3430 2f45 6c65  gineerjoe440/Ele
-000000f0: 6374 7269 6350 792f 6163 7469 6f6e 732f  ctricPy/actions/
-00000100: 776f 726b 666c 6f77 732f 7370 6869 6e78  workflows/sphinx
-00000110: 2d62 7569 6c64 2e79 6d6c 2f62 6164 6765  -build.yml/badge
-00000120: 2e73 7667 3f62 7261 6e63 683d 6d61 7374  .svg?branch=mast
-00000130: 6572 295d 2868 7474 7073 3a2f 2f67 6974  er)](https://git
-00000140: 6875 622e 636f 6d2f 656e 6769 6e65 6572  hub.com/engineer
-00000150: 6a6f 6534 3430 2f45 6c65 6374 7269 6350  joe440/ElectricP
-00000160: 792f 6163 7469 6f6e 732f 776f 726b 666c  y/actions/workfl
-00000170: 6f77 732f 7370 6869 6e78 2d62 7569 6c64  ows/sphinx-build
-00000180: 2e79 6d6c 290a 215b 546f 7820 496d 706f  .yml).![Tox Impo
-00000190: 7274 2054 6573 745d 2868 7474 7073 3a2f  rt Test](https:/
-000001a0: 2f67 6974 6875 622e 636f 6d2f 656e 6769  /github.com/engi
-000001b0: 6e65 6572 6a6f 6534 3430 2f45 6c65 6374  neerjoe440/Elect
-000001c0: 7269 6350 792f 776f 726b 666c 6f77 732f  ricPy/workflows/
-000001d0: 546f 7825 3230 5465 7374 732f 6261 6467  Tox%20Tests/badg
-000001e0: 652e 7376 6729 0a5b 215b 7079 7465 7374  e.svg).[![pytest
-000001f0: 5d28 6874 7470 733a 2f2f 6769 7468 7562  ](https://github
-00000200: 2e63 6f6d 2f65 6e67 696e 6565 726a 6f65  .com/engineerjoe
-00000210: 3434 302f 456c 6563 7472 6963 5079 2f61  440/ElectricPy/a
-00000220: 6374 696f 6e73 2f77 6f72 6b66 6c6f 7773  ctions/workflows
-00000230: 2f70 7974 6573 742e 796d 6c2f 6261 6467  /pytest.yml/badg
-00000240: 652e 7376 673f 6272 616e 6368 3d6d 6173  e.svg?branch=mas
-00000250: 7465 7229 5d28 6874 7470 733a 2f2f 6769  ter)](https://gi
-00000260: 7468 7562 2e63 6f6d 2f65 6e67 696e 6565  thub.com/enginee
-00000270: 726a 6f65 3434 302f 456c 6563 7472 6963  rjoe440/Electric
-00000280: 5079 2f61 6374 696f 6e73 2f77 6f72 6b66  Py/actions/workf
-00000290: 6c6f 7773 2f70 7974 6573 742e 796d 6c29  lows/pytest.yml)
-000002a0: 0a5b 215b 7079 646f 6373 7479 6c65 5d28  .[![pydocstyle](
-000002b0: 6874 7470 733a 2f2f 6769 7468 7562 2e63  https://github.c
-000002c0: 6f6d 2f65 6e67 696e 6565 726a 6f65 3434  om/engineerjoe44
-000002d0: 302f 456c 6563 7472 6963 5079 2f61 6374  0/ElectricPy/act
-000002e0: 696f 6e73 2f77 6f72 6b66 6c6f 7773 2f70  ions/workflows/p
-000002f0: 7964 6f63 7374 796c 652e 796d 6c2f 6261  ydocstyle.yml/ba
-00000300: 6467 652e 7376 673f 6272 616e 6368 3d6d  dge.svg?branch=m
-00000310: 6173 7465 7229 5d28 6874 7470 733a 2f2f  aster)](https://
-00000320: 6769 7468 7562 2e63 6f6d 2f65 6e67 696e  github.com/engin
-00000330: 6565 726a 6f65 3434 302f 456c 6563 7472  eerjoe440/Electr
-00000340: 6963 5079 2f61 6374 696f 6e73 2f77 6f72  icPy/actions/wor
-00000350: 6b66 6c6f 7773 2f70 7964 6f63 7374 796c  kflows/pydocstyl
-00000360: 652e 796d 6c29 0a21 5b43 6f76 6572 6167  e.yml).![Coverag
-00000370: 655d 2868 7474 7073 3a2f 2f72 6177 2e67  e](https://raw.g
-00000380: 6974 6875 6275 7365 7263 6f6e 7465 6e74  ithubusercontent
-00000390: 2e63 6f6d 2f65 6e67 696e 6565 726a 6f65  .com/engineerjoe
-000003a0: 3434 302f 456c 6563 7472 6963 5079 2f67  440/ElectricPy/g
-000003b0: 682d 7061 6765 732f 636f 7665 7261 6765  h-pages/coverage
-000003c0: 2e73 7667 290a 0a5b 215b 5d28 6874 7470  .svg)..[![](http
-000003d0: 733a 2f2f 696d 672e 7368 6965 6c64 732e  s://img.shields.
-000003e0: 696f 2f70 7970 692f 762f 656c 6563 7472  io/pypi/v/electr
-000003f0: 6963 7079 2e73 7667 3f63 6f6c 6f72 3d62  icpy.svg?color=b
-00000400: 6c75 6526 6c6f 676f 3d70 7970 6926 6c6f  lue&logo=pypi&lo
-00000410: 676f 436f 6c6f 723d 7768 6974 6529 5d28  goColor=white)](
-00000420: 6874 7470 733a 2f2f 7079 7069 2e6f 7267  https://pypi.org
-00000430: 2f70 726f 6a65 6374 2f65 6c65 6374 7269  /project/electri
-00000440: 6370 792f 290a 5b21 5b5d 2868 7474 7073  cpy/).[![](https
-00000450: 3a2f 2f70 6570 792e 7465 6368 2f62 6164  ://pepy.tech/bad
-00000460: 6765 2f65 6c65 6374 7269 6370 7929 5d28  ge/electricpy)](
-00000470: 6874 7470 733a 2f2f 7065 7079 2e74 6563  https://pepy.tec
-00000480: 682f 7072 6f6a 6563 742f 656c 6563 7472  h/project/electr
-00000490: 6963 7079 290a 5b21 5b5d 2868 7474 7073  icpy).[![](https
-000004a0: 3a2f 2f69 6d67 2e73 6869 656c 6473 2e69  ://img.shields.i
-000004b0: 6f2f 6769 7468 7562 2f73 7461 7273 2f65  o/github/stars/e
-000004c0: 6e67 696e 6565 726a 6f65 3434 302f 656c  ngineerjoe440/el
-000004d0: 6563 7472 6963 7079 3f6c 6f67 6f3d 6769  ectricpy?logo=gi
-000004e0: 7468 7562 295d 2868 7474 7073 3a2f 2f67  thub)](https://g
-000004f0: 6974 6875 622e 636f 6d2f 656e 6769 6e65  ithub.com/engine
-00000500: 6572 6a6f 6534 3430 2f65 6c65 6374 7269  erjoe440/electri
-00000510: 6370 792f 290a 5b21 5b5d 2868 7474 7073  cpy/).[![](https
-00000520: 3a2f 2f69 6d67 2e73 6869 656c 6473 2e69  ://img.shields.i
-00000530: 6f2f 7079 7069 2f6c 2f65 6c65 6374 7269  o/pypi/l/electri
-00000540: 6370 792e 7376 673f 636f 6c6f 723d 626c  cpy.svg?color=bl
-00000550: 7565 295d 2868 7474 7073 3a2f 2f67 6974  ue)](https://git
-00000560: 6875 622e 636f 6d2f 656e 6769 6e65 6572  hub.com/engineer
-00000570: 6a6f 6534 3430 2f65 6c65 6374 7269 6370  joe440/electricp
-00000580: 792f 626c 6f62 2f6d 6173 7465 722f 4c49  y/blob/master/LI
-00000590: 4345 4e53 452e 7478 7429 0a0a 5b21 5b22  CENSE.txt)..[!["
-000005a0: 4275 7920 4d65 2041 2043 6f66 6665 6522  Buy Me A Coffee"
-000005b0: 5d28 6874 7470 733a 2f2f 7777 772e 6275  ](https://www.bu
-000005c0: 796d 6561 636f 6666 6565 2e63 6f6d 2f61  ymeacoffee.com/a
-000005d0: 7373 6574 732f 696d 672f 6375 7374 6f6d  ssets/img/custom
-000005e0: 5f69 6d61 6765 732f 6f72 616e 6765 5f69  _images/orange_i
-000005f0: 6d67 2e70 6e67 295d 2868 7474 7073 3a2f  mg.png)](https:/
-00000600: 2f77 7777 2e62 7579 6d65 6163 6f66 6665  /www.buymeacoffe
-00000610: 652e 636f 6d2f 656e 6769 6e65 6572 6a6f  e.com/engineerjo
-00000620: 6534 3430 290a 0a0a 5079 7468 6f6e 204c  e440)...Python L
-00000630: 6962 7261 7269 6573 2077 6974 6820 6675  ibraries with fu
-00000640: 6e63 7469 6f6e 7320 616e 6420 636f 6e73  nctions and cons
-00000650: 7461 6e74 7320 7265 6c61 7465 6420 746f  tants related to
-00000660: 2065 6c65 6374 7269 6361 6c20 656e 6769   electrical engi
-00000670: 6e65 6572 696e 672e 0a0a 5468 6520 6675  neering...The fu
-00000680: 6e63 7469 6f6e 7320 616e 6420 636f 6e73  nctions and cons
-00000690: 7461 6e74 7320 7468 6174 206d 616b 6520  tants that make 
-000006a0: 7570 2074 6865 7365 206d 6f64 756c 6573  up these modules
-000006b0: 2072 6570 7265 7365 6e74 2061 206c 6962   represent a lib
-000006c0: 7261 7279 206f 6620 6d61 7465 7269 616c  rary of material
-000006d0: 2063 6f6d 7069 6c65 6420 7769 7468 2074   compiled with t
-000006e0: 6865 2069 6e74 656e 7420 6f66 2062 6569  he intent of bei
-000006f0: 6e67 2075 7365 6420 7072 696d 6172 696c  ng used primaril
-00000700: 790a 666f 7220 7265 7365 6172 6368 2c20  y.for research, 
-00000710: 6465 7665 6c6f 706d 656e 742c 2065 6475  development, edu
-00000720: 6361 7469 6f6e 2c20 616e 6420 6578 706c  cation, and expl
-00000730: 6f72 6174 696f 6e20 696e 2074 6865 2072  oration in the r
-00000740: 6561 6c6d 206f 6620 656c 6563 7472 6963  ealm of electric
-00000750: 616c 2065 6e67 696e 6565 7269 6e67 2e0a  al engineering..
-00000760: 0a43 6865 636b 206f 7574 206f 7572 2066  .Check out our f
-00000770: 756c 6c20 646f 6375 6d65 6e74 6174 696f  ull documentatio
-00000780: 6e3a 2068 7474 7073 3a2f 2f65 6e67 696e  n: https://engin
-00000790: 6565 726a 6f65 3434 302e 6769 7468 7562  eerjoe440.github
-000007a0: 2e69 6f2f 456c 6563 7472 6963 5079 2f0a  .io/ElectricPy/.
-000007b0: 0a23 2323 2053 7065 6369 616c 2074 6861  .### Special tha
-000007c0: 6e6b 7320 746f 3a0a 0a2d 2053 6f68 616d  nks to:..- Soham
-000007d0: 2052 6174 6e61 7061 726b 6869 207c 2053   Ratnaparkhi | S
-000007e0: 7475 6465 6e74 202d 2056 6973 6877 616b  tudent - Vishwak
-000007f0: 6172 6d61 2049 6e73 7469 7475 7465 206f  arma Institute o
-00000800: 6620 5465 6368 6e6f 6c6f 6779 0a2d 204c  f Technology.- L
-00000810: 616b 7368 6d69 6b61 6e74 6820 4179 7961  akshmikanth Ayya
-00000820: 6465 7661 7261 207c 2053 7475 6465 6e74  devara | Student
-00000830: 202d 204e 4954 2057 6172 616e 6761 6c20   - NIT Warangal 
-00000840: 284e 6174 696f 6e61 6c20 496e 7374 6974  (National Instit
-00000850: 7574 6520 6f66 2054 6563 686e 6f6c 6f67  ute of Technolog
-00000860: 7920 5761 7261 6e67 616c 290a 2d20 5374  y Warangal).- St
-00000870: 6570 6865 6e20 5765 656b 7320 7c20 5374  ephen Weeks | St
-00000880: 7564 656e 7420 2d20 556e 6976 6572 7369  udent - Universi
-00000890: 7479 206f 6620 4964 6168 6f0a 2d20 4a65  ty of Idaho.- Je
-000008a0: 7265 6d79 2050 6572 6861 6320 7c20 5374  remy Perhac | St
-000008b0: 7564 656e 7420 2d20 556e 6976 6572 7369  udent - Universi
-000008c0: 7479 206f 6620 4964 6168 6f0a 2d20 4461  ty of Idaho.- Da
-000008d0: 6e69 656c 2041 6c6c 656e 207c 2053 7475  niel Allen | Stu
-000008e0: 6465 6e74 202d 2055 6e69 7665 7273 7469  dent - Universti
-000008f0: 7920 6f66 2049 6461 686f 0a2d 2044 722e  y of Idaho.- Dr.
-00000900: 2044 656e 6e69 7320 5375 6c6c 6976 616e   Dennis Sullivan
-00000910: 207c 2050 726f 6666 6573 736f 7220 2d20   | Proffessor - 
-00000920: 556e 6976 6572 7369 7479 206f 6620 4964  University of Id
-00000930: 6168 6f0a 2d20 4472 2e20 4272 6961 6e20  aho.- Dr. Brian 
-00000940: 4a6f 686e 736f 6e20 7c20 5072 6f66 6665  Johnson | Proffe
-00000950: 7373 6f72 202d 2055 6e69 7665 7273 6974  ssor - Universit
-00000960: 7920 6f66 2049 6461 686f 0a2d 2044 722e  y of Idaho.- Dr.
-00000970: 204a 6f65 204c 6177 207c 2050 726f 6666   Joe Law | Proff
-00000980: 6573 736f 7220 2d20 556e 6976 6572 7369  essor - Universi
-00000990: 7479 206f 6620 4964 6168 6f0a 2d20 5374  ty of Idaho.- St
-000009a0: 6163 6b4f 7665 7266 6c6f 7720 7573 6572  ackOverflow user
-000009b0: 2067 6733 3439 0a2d 2053 6861 7572 7961   gg349.- Shaurya
-000009c0: 2055 7070 616c 207c 204f 6e6c 696e 6520   Uppal | Online 
-000009d0: 436f 6465 2043 6f6e 7472 6962 7574 6f72  Code Contributor
-000009e0: 0a2d 2050 6175 6c20 4f72 746d 616e 207c  .- Paul Ortman |
-000009f0: 2050 6f77 6572 2051 7561 6c69 7479 2045   Power Quality E
-00000a00: 6e67 696e 6565 7220 2d20 4964 6168 6f20  ngineer - Idaho 
-00000a10: 506f 7765 7220 7c20 496e 7374 7275 6374  Power | Instruct
-00000a20: 6f72 202d 2055 6e69 7665 7273 6974 7920  or - University 
-00000a30: 6f66 2049 6461 686f 0a0a 0a23 2323 2044  of Idaho...### D
-00000a40: 6570 656e 6465 6e63 6965 733a 0a0a 2d20  ependencies:..- 
-00000a50: 5b4e 756d 5079 5d28 6874 7470 733a 2f2f  [NumPy](https://
-00000a60: 6e75 6d70 792e 6f72 672f 290a 2d20 5b6d  numpy.org/).- [m
-00000a70: 6174 706c 6f74 6c69 625d 2868 7474 7073  atplotlib](https
-00000a80: 3a2f 2f6d 6174 706c 6f74 6c69 622e 6f72  ://matplotlib.or
-00000a90: 672f 290a 2d20 5b53 6369 5079 5d28 6874  g/).- [SciPy](ht
-00000aa0: 7470 733a 2f2f 7363 6970 792e 6f72 672f  tps://scipy.org/
-00000ab0: 290a 2d20 5b53 796d 5079 5d28 6874 7470  ).- [SymPy](http
-00000ac0: 733a 2f2f 7777 772e 7379 6d70 792e 6f72  s://www.sympy.or
-00000ad0: 672f 656e 2f69 6e64 6578 2e68 746d 6c29  g/en/index.html)
-00000ae0: 0a2d 205b 6e75 6d64 6966 6674 6f6f 6c73  .- [numdifftools
-00000af0: 5d28 6874 7470 733a 2f2f 6e75 6d64 6966  ](https://numdif
-00000b00: 6674 6f6f 6c73 2e72 6561 6474 6865 646f  ftools.readthedo
-00000b10: 6373 2e69 6f2f 656e 2f6c 6174 6573 742f  cs.io/en/latest/
-00000b20: 290a 0a0a 2323 2049 4e53 5441 4c4c 4154  )...## INSTALLAT
-00000b30: 494f 4e3a 0a0a 2323 2320 3129 2028 6f70  ION:..### 1) (op
-00000b40: 7469 6f6e 2061 2920 496e 7374 616c 6c20  tion a) Install 
-00000b50: 456c 6563 7472 6963 5079 2077 6974 6820  ElectricPy with 
-00000b60: 5079 7468 6f6e 2773 204f 776e 2060 7069  Python's Own `pi
-00000b70: 7060 0a0a 496e 7374 616c 6c20 2a65 6c65  p`..Install *ele
-00000b80: 6374 7269 6370 792a 0a20 202d 2060 7069  ctricpy*.  - `pi
-00000b90: 7020 696e 7374 616c 6c20 656c 6563 7472  p install electr
-00000ba0: 6963 7079 600a 0a23 2323 2031 2920 286f  icpy`..### 1) (o
-00000bb0: 7074 696f 6e20 6229 2049 6e73 7461 6c6c  ption b) Install
-00000bc0: 2045 6c65 6374 7269 6350 7920 6672 6f6d   ElectricPy from
-00000bd0: 2053 6f75 7263 650a 0a5b 5079 7468 6f6e   Source..[Python
-00000be0: 2044 6f63 756d 656e 7461 7469 6f6e 5d28   Documentation](
-00000bf0: 6874 7470 733a 2f2f 646f 6373 2e70 7974  https://docs.pyt
-00000c00: 686f 6e2e 6f72 672f 332f 696e 7374 616c  hon.org/3/instal
-00000c10: 6c2f 696e 6465 782e 6874 6d6c 290a 2020  l/index.html).  
-00000c20: 0a43 6f6c 6c65 6374 2052 6570 6f73 6974  .Collect Reposit
-00000c30: 6f72 7920 616e 6420 496e 7374 616c 6c0a  ory and Install.
-00000c40: 2020 2020 0a31 2e20 436c 6f6e 652f 446f      .1. Clone/Do
-00000c50: 776e 6c6f 6164 2053 6f75 7263 6520 436f  wnload Source Co
-00000c60: 6465 2066 726f 6d20 4769 7448 7562 205b  de from GitHub [
-00000c70: 5265 706f 7369 746f 7279 5d28 6874 7470  Repository](http
-00000c80: 733a 2f2f 6769 7468 7562 2e63 6f6d 2f65  s://github.com/e
-00000c90: 6e67 696e 6565 726a 6f65 3434 302f 456c  ngineerjoe440/El
-00000ca0: 6563 7472 6963 5079 290a 322e 204f 7065  ectricPy).2. Ope
-00000cb0: 6e20 5465 726d 696e 616c 2061 6e64 204e  n Terminal and N
-00000cc0: 6176 6967 6174 6520 746f 2046 6f6c 6465  avigate to Folde
-00000cd0: 7220 7769 7468 2060 6364 6020 436f 6d6d  r with `cd` Comm
-00000ce0: 616e 6473 3a0a 2020 2d20 6063 6420 3c70  ands:.  - `cd <p
-00000cf0: 6174 685c 746f 5c63 6f6e 7461 696e 696e  ath\to\containin
-00000d00: 675c 666f 6c64 6572 3e5c 656c 6563 7472  g\folder>\electr
-00000d10: 6963 7079 600a 332e 2055 7365 2050 7974  icpy`.3. Use Pyt
-00000d20: 686f 6e20 746f 2049 6e73 7461 6c6c 204d  hon to Install M
-00000d30: 6f64 756c 6520 6672 6f6d 2060 7365 7475  odule from `setu
-00000d40: 702e 7079 603a 0a20 202d 2060 7079 7468  p.py`:.  - `pyth
-00000d50: 6f6e 2073 6574 7570 2e70 7920 696e 7374  on setup.py inst
-00000d60: 616c 6c60 0a20 200a 2323 2320 3229 2056  all`.  .### 2) V
-00000d70: 6572 6966 7920 496e 7374 616c 6c61 7469  erify Installati
-00000d80: 6f6e 0a0a 4368 6563 6b20 696e 7374 616c  on..Check instal
-00000d90: 6c61 7469 6f6e 2073 7563 6365 7373 2069  lation success i
-00000da0: 6e20 5079 7468 6f6e 2065 6e76 6972 6f6e  n Python environ
-00000db0: 6d65 6e74 0a0a 6060 6070 7974 686f 6e0a  ment..```python.
-00000dc0: 696d 706f 7274 2065 6c65 6374 7269 6370  import electricp
-00000dd0: 790a 656c 6563 7472 6963 7079 2e5f 7665  y.electricpy._ve
-00000de0: 7273 696f 6e5f 0a60 6060 0a0a 2323 2054  rsion_.```..## T
-00000df0: 6f20 446f 204c 6973 740a 0a2d 2041 6464  o Do List..- Add
-00000e00: 2048 6561 7420 5369 6e6b 2053 6f6c 7665   Heat Sink Solve
-00000e10: 720a 2d20 4443 2f44 4320 436f 6e76 6572  r.- DC/DC Conver
-00000e20: 7465 7273 0a2d 2044 432f 4143 2043 6f6e  ters.- DC/AC Con
-00000e30: 7665 7274 6572 730a 2d20 5374 6174 696f  verters.- Statio
-00000e40: 6e61 7279 2061 6e64 2053 796e 6368 726f  nary and Synchro
-00000e50: 6e6f 7573 2052 6566 6572 656e 6365 2046  nous Reference F
-00000e60: 7261 6d65 2063 6f6e 7665 7273 696f 6e20  rame conversion 
-00000e70: 4d61 7472 6963 6573 2f43 6f6e 7374 616e  Matrices/Constan
-00000e80: 7473 0a2d 2041 6464 2061 7263 2d66 6c61  ts.- Add arc-fla
-00000e90: 7368 2063 616c 6375 6c61 746f 7273 2073  sh calculators s
-00000ea0: 7567 6765 7374 6564 0a2d 2041 6464 2053  uggested.- Add S
-00000eb0: 696d 706c 6520 5b64 6563 6962 656c 5d28  imple [decibel](
-00000ec0: 6874 7470 733a 2f2f 7777 772e 6261 7369  https://www.basi
-00000ed0: 6374 6162 6c65 732e 636f 6d2f 656c 6563  ctables.com/elec
-00000ee0: 7472 6f6e 6963 732f 6465 6369 6265 6c2d  tronics/decibel-
-00000ef0: 6462 7729 2046 6f72 6d75 6c61 730a 2d20  dbw) Formulas.- 
-00000f00: 4164 6420 5369 6d70 6c65 205b 4261 7474  Add Simple [Batt
-00000f10: 6572 7920 4469 7363 6861 7267 6520 5261  ery Discharge Ra
-00000f20: 7465 5d28 6874 7470 733a 2f2f 7777 772e  te](https://www.
-00000f30: 6261 7369 6374 6162 6c65 732e 636f 6d2f  basictables.com/
-00000f40: 656c 6563 7472 6f6e 6963 732f 6261 7474  electronics/batt
-00000f50: 6572 792f 6261 7474 6572 792d 6469 7363  ery/battery-disc
-00000f60: 6861 7267 652d 7261 7465 2920 466f 726d  harge-rate) Form
-00000f70: 756c 610a 2d20 4164 6420 5369 6d70 6c65  ula.- Add Simple
-00000f80: 205b 4169 7220 436f 7265 2049 6e64 7563   [Air Core Induc
-00000f90: 746f 725d 2868 7474 7073 3a2f 2f77 7777  tor](https://www
-00000fa0: 2e62 6173 6963 7461 626c 6573 2e63 6f6d  .basictables.com
-00000fb0: 2f65 6c65 6374 726f 6e69 6373 2f69 6e64  /electronics/ind
-00000fc0: 7563 746f 722f 6169 722d 636f 7265 2d69  uctor/air-core-i
-00000fd0: 6e64 7563 746f 7229 2046 6f72 6d75 6c61  nductor) Formula
-00000fe0: 2873 290a 2d20 4164 6420 5369 6d70 6c65  (s).- Add Simple
-00000ff0: 205b 5a65 6e65 7220 4469 6f64 655d 2868   [Zener Diode](h
-00001000: 7474 7073 3a2f 2f77 7777 2e62 6173 6963  ttps://www.basic
-00001010: 7461 626c 6573 2e63 6f6d 2f65 6c65 6374  tables.com/elect
-00001020: 726f 6e69 6373 2f64 696f 6465 2f7a 656e  ronics/diode/zen
-00001030: 6572 2d64 696f 6465 2920 466f 726d 756c  er-diode) Formul
-00001040: 6173 0a2d 202a 4465 7665 6c6f 7020 5465  as.- *Develop Te
-00001050: 7374 696e 6720 666f 7220 416c 6c20 4675  sting for All Fu
-00001060: 6e63 7469 6f6e 732a 0a0a 2323 2047 6574  nctions*..## Get
-00001070: 2049 6e76 6f6c 7665 6420 2f20 436f 6e74   Involved / Cont
-00001080: 7269 6275 7465 0a0a 4966 2079 6f75 2772  ribute..If you'r
-00001090: 6520 696e 7465 7265 7374 6564 2069 6e20  e interested in 
-000010a0: 636f 6e74 7269 6275 7469 6e67 2c20 7765  contributing, we
-000010b0: 2764 206c 6f76 6520 746f 2073 6565 2079  'd love to see y
-000010c0: 6f75 7220 7375 7070 6f72 7420 696e 2061  our support in a
-000010d0: 206e 756d 6265 7220 6f66 2077 6179 7321   number of ways!
-000010e0: 0a0a 312e 202a 2a57 7269 7465 2054 6573  ..1. **Write Tes
-000010f0: 7473 2a2a 202d 2057 6527 7265 2072 6561  ts** - We're rea
-00001100: 6c6c 7920 6c61 636b 696e 6720 696e 2074  lly lacking in t
-00001110: 6869 7320 6172 6561 2e20 5765 2776 6520  his area. We've 
-00001120: 7265 6365 6e74 6c79 2061 6464 6564 2073  recently added s
-00001130: 696d 706c 6520 4769 7448 7562 2061 6374  imple GitHub act
-00001140: 696f 6e73 2074 6f20 7465 7374 2069 6e73  ions to test ins
-00001150: 7461 6c6c 6174 696f 6e2c 2062 7574 2074  tallation, but t
-00001160: 6861 7427 7320 6162 6f75 7420 6974 2e20  hat's about it. 
-00001170: 5765 2068 6f70 6520 7468 6174 2073 6f6d  We hope that som
-00001180: 6564 6179 2077 6520 6361 6e20 7465 7374  eday we can test
-00001190: 2061 6c6c 2066 756e 6374 696f 6e73 2069   all functions i
-000011a0: 6e20 7468 6973 206d 6f64 756c 6520 666f  n this module fo
-000011b0: 7220 7665 7269 6669 6361 7469 6f6e 2e0a  r verification..
-000011c0: 322e 202a 2a43 6f6e 7472 6962 7574 6520  2. **Contribute 
-000011d0: 4e65 7720 456c 6563 7472 6963 616c 2045  New Electrical E
-000011e0: 6e67 696e 6565 7269 6e67 2046 756e 6374  ngineering Funct
-000011f0: 696f 6e73 2a2a 202d 2049 6620 796f 7527  ions** - If you'
-00001200: 7665 2067 6f74 2061 206e 6577 2066 756e  ve got a new fun
-00001210: 6374 696f 6e20 7265 6c61 7465 6420 746f  ction related to
-00001220: 2065 6c65 6374 7269 6361 6c20 656e 6769   electrical engi
-00001230: 6e65 6572 696e 6720 7468 6174 2079 6f75  neering that you
-00001240: 2764 206c 696b 6520 746f 2073 6565 2061  'd like to see a
-00001250: 6464 6564 2c20 7765 2764 206c 6f76 6520  dded, we'd love 
-00001260: 746f 2074 6872 6f77 2069 7420 696e 746f  to throw it into
-00001270: 2074 6869 7320 6d6f 6475 6c65 2e20 4f75   this module. Ou
-00001280: 7220 676f 616c 2069 7320 7468 6174 2074  r goal is that t
-00001290: 6869 7320 6d6f 6475 6c65 2063 616e 2062  his module can b
-000012a0: 6563 6f6d 6520 7468 6520 636f 6d70 7265  ecome the compre
-000012b0: 6865 6e73 6976 6520 656c 6563 7472 6963  hensive electric
-000012c0: 616c 2065 6e67 696e 6565 7269 6e67 2074  al engineering t
-000012d0: 6f6f 6c6b 6974 2069 6e20 5079 7468 6f6e  oolkit in Python
-000012e0: 2e20 4472 6f70 2075 7320 6120 6e6f 7465  . Drop us a note
-000012f0: 2c20 6f72 2063 7265 6174 6520 6120 7075  , or create a pu
-00001300: 6c6c 2072 6571 7565 7374 210a 332e 202a  ll request!.3. *
-00001310: 2a52 6570 6f72 7420 4973 7375 6573 2a2a  *Report Issues**
-00001320: 202d 2057 6520 646f 6e27 7420 7761 6e74   - We don't want
-00001330: 2069 7373 7565 7320 746f 2067 6f20 756e   issues to go un
-00001340: 6e6f 7469 6365 642e 2050 6c65 6173 6520  noticed. Please 
-00001350: 6865 6c70 2075 7320 7472 6163 6b20 6275  help us track bu
-00001360: 6773 2061 6e64 2072 6573 6f6c 7665 2074  gs and resolve t
-00001370: 6865 6d21 0a34 2e20 2a2a 4765 7420 7468  hem!.4. **Get th
-00001380: 6520 576f 7264 204f 7574 2a2a 202d 2054  e Word Out** - T
-00001390: 6869 7320 7072 6f6a 6563 7420 6973 2073  his project is s
-000013a0: 7469 6c6c 2069 6e20 6974 7320 696e 6661  till in its infa
-000013b0: 6e63 792c 2073 6f20 706c 6561 7365 2073  ncy, so please s
-000013c0: 6861 7265 2069 7420 7769 7468 2079 6f75  hare it with you
-000013d0: 7220 6672 6965 6e64 7320 616e 6420 636f  r friends and co
-000013e0: 6c6c 6561 6775 6573 2e20 5765 2077 616e  lleagues. We wan
-000013f0: 7420 746f 206d 616b 6520 7375 7265 2074  t to make sure t
-00001400: 6861 7420 6576 6572 796f 6e65 2068 6173  hat everyone has
-00001410: 2074 6865 206f 7070 6f72 7475 6e69 7479   the opportunity
-00001420: 2074 6f20 7461 6b65 2061 6476 616e 7461   to take advanta
-00001430: 6765 206f 6620 7468 6973 2070 726f 6a65  ge of this proje
-00001440: 6374 2e0a 0a23 2323 2320 4368 6563 6b20  ct...#### Check 
-00001450: 6f75 7420 7468 6520 5b63 6f6e 7472 6962  out the [contrib
-00001460: 7574 696f 6e20 6775 6964 655d 2868 7474  ution guide](htt
-00001470: 7073 3a2f 2f67 6974 6875 622e 636f 6d2f  ps://github.com/
-00001480: 656e 6769 6e65 6572 6a6f 6534 3430 2f45  engineerjoe440/E
-00001490: 6c65 6374 7269 6350 792f 626c 6f62 2f6d  lectricPy/blob/m
-000014a0: 6173 7465 722f 434f 4e54 5249 4255 5449  aster/CONTRIBUTI
-000014b0: 4e47 2e6d 6429 0a20 2020 200a 0a23 2320  NG.md).    ..## 
-000014c0: 436f 6e74 6163 740a 0a46 6f72 206d 6f72  Contact..For mor
-000014d0: 6520 696e 666f 726d 6174 696f 6e20 7265  e information re
-000014e0: 6761 7264 696e 6720 7468 6973 2072 6573  garding this res
-000014f0: 6f75 7263 652c 2070 6c65 6173 6520 636f  ource, please co
-00001500: 6e74 6163 7420 4a6f 6520 5374 616e 6c65  ntact Joe Stanle
-00001510: 790a 0a2d 203c 7374 616e 3339 3236 4061  y..- <stan3926@a
-00001520: 6c6d 756e 692e 7569 6461 686f 2e65 6475  lmuni.uidaho.edu
-00001530: 3e0a 2d20 3c6a 6f65 5f73 7461 6e6c 6579  >.- <joe_stanley
-00001540: 4073 656c 696e 632e 636f 6d3e 0a0a 2323  @selinc.com>..##
-00001550: 204c 6963 656e 7365 2061 6e64 2055 7361   License and Usa
-00001560: 6765 0a0a 456c 6563 7472 6963 5079 2069  ge..ElectricPy i
-00001570: 7320 6c69 6365 6e73 6564 2075 6e64 6572  s licensed under
-00001580: 2074 6865 2073 7461 6e64 6172 6420 4d49   the standard MI
-00001590: 5420 6c69 6365 6e73 652c 2061 6e64 2061  T license, and a
-000015a0: 7320 7375 6368 2c20 796f 7520 6172 6520  s such, you are 
-000015b0: 7065 726d 6974 7465 640a 746f 2075 7365  permitted.to use
-000015c0: 2074 6869 7320 7265 736f 7572 6365 2061   this resource a
-000015d0: 7320 796f 7520 7365 6520 6669 742e 2050  s you see fit. P
-000015e0: 6c65 6173 6520 6665 656c 2066 7265 6520  lease feel free 
-000015f0: 746f 2061 736b 2071 7565 7374 696f 6e73  to ask questions
-00001600: 2c20 7375 6767 6573 7420 6564 6974 730a  , suggest edits.
-00001610: 616e 6420 7265 706f 7274 2062 7567 7320  and report bugs 
-00001620: 6f72 206f 7468 6572 2069 7373 7565 732e  or other issues.
-00001630: 0a                                       .
+00000000: 4d65 7461 6461 7461 2d56 6572 7369 6f6e  Metadata-Version
+00000010: 3a20 322e 310a 4e61 6d65 3a20 656c 6563  : 2.1.Name: elec
+00000020: 7472 6963 7079 0a56 6572 7369 6f6e 3a20  tricpy.Version: 
+00000030: 302e 332e 300a 5375 6d6d 6172 793a 2045  0.3.0.Summary: E
+00000040: 6c65 6374 7269 6361 6c20 456e 6769 6e65  lectrical Engine
+00000050: 6572 696e 6720 4675 6e63 7469 6f6e 7320  ering Functions 
+00000060: 696e 2050 7974 686f 6e0a 4175 7468 6f72  in Python.Author
+00000070: 3a20 4c61 6b73 686d 696b 616e 7468 2041  : Lakshmikanth A
+00000080: 7979 6164 6576 6172 612c 204d 6967 7565  yyadevara, Migue
+00000090: 6c20 5a61 6261 6c61 2c20 4920 5761 7961  l Zabala, I Waya
+000000a0: 6e20 4b75 726e 6961 7761 6e2c 2054 616e  n Kurniawan, Tan
+000000b0: 7669 7220 5269 7961 640a 4175 7468 6f72  vir Riyad.Author
+000000c0: 2d65 6d61 696c 3a20 4a6f 6520 5374 616e  -email: Joe Stan
+000000d0: 6c65 7920 3c65 6e67 696e 6565 726a 6f65  ley <engineerjoe
+000000e0: 3434 3040 7961 686f 6f2e 636f 6d3e 2c20  440@yahoo.com>, 
+000000f0: 4b68 616e 2041 7366 6920 5265 7a61 203c  Khan Asfi Reza <
+00000100: 6b68 616e 6173 6669 7265 7a61 3130 4067  khanasfireza10@g
+00000110: 6d61 696c 2e63 6f6d 3e2c 2041 7274 6875  mail.com>, Arthu
+00000120: 7220 4c6f 7265 6e63 696e 6920 4265 7267  r Lorencini Berg
+00000130: 616d 6173 6368 6920 3c61 7274 6875 722e  amaschi <arthur.
+00000140: 6c6f 7265 6e63 696e 6940 676d 6169 6c2e  lorencini@gmail.
+00000150: 636f 6d3e 2c20 536f 6861 6d20 5261 746e  com>, Soham Ratn
+00000160: 6170 6172 6b68 6920 3c73 6f68 616d 2e72  aparkhi <soham.r
+00000170: 6174 6e61 7061 726b 6869 4067 6d61 696c  atnaparkhi@gmail
+00000180: 2e63 6f6d 3e2c 2041 6e6b 7573 6820 3c61  .com>, Ankush <a
+00000190: 6e6b 7573 682e 6f70 656e 736f 7572 6365  nkush.opensource
+000001a0: 4067 6d61 696c 2e63 6f6d 3e0a 4d61 696e  @gmail.com>.Main
+000001b0: 7461 696e 6572 2d65 6d61 696c 3a20 4a6f  tainer-email: Jo
+000001c0: 6520 5374 616e 6c65 7920 3c65 6e67 696e  e Stanley <engin
+000001d0: 6565 726a 6f65 3434 3040 7961 686f 6f2e  eerjoe440@yahoo.
+000001e0: 636f 6d3e 0a52 6571 7569 7265 732d 5079  com>.Requires-Py
+000001f0: 7468 6f6e 3a20 3e3d 332e 370a 4465 7363  thon: >=3.7.Desc
+00000200: 7269 7074 696f 6e2d 436f 6e74 656e 742d  ription-Content-
+00000210: 5479 7065 3a20 7465 7874 2f6d 6172 6b64  Type: text/markd
+00000220: 6f77 6e0a 436c 6173 7369 6669 6572 3a20  own.Classifier: 
+00000230: 5072 6f67 7261 6d6d 696e 6720 4c61 6e67  Programming Lang
+00000240: 7561 6765 203a 3a20 5079 7468 6f6e 203a  uage :: Python :
+00000250: 3a20 330a 436c 6173 7369 6669 6572 3a20  : 3.Classifier: 
+00000260: 4c69 6365 6e73 6520 3a3a 204f 5349 2041  License :: OSI A
+00000270: 7070 726f 7665 6420 3a3a 204d 4954 204c  pproved :: MIT L
+00000280: 6963 656e 7365 0a43 6c61 7373 6966 6965  icense.Classifie
+00000290: 723a 204f 7065 7261 7469 6e67 2053 7973  r: Operating Sys
+000002a0: 7465 6d20 3a3a 204f 5320 496e 6465 7065  tem :: OS Indepe
+000002b0: 6e64 656e 740a 5265 7175 6972 6573 2d44  ndent.Requires-D
+000002c0: 6973 743a 204e 756d 5079 0a52 6571 7569  ist: NumPy.Requi
+000002d0: 7265 732d 4469 7374 3a20 6d61 7470 6c6f  res-Dist: matplo
+000002e0: 746c 6962 0a52 6571 7569 7265 732d 4469  tlib.Requires-Di
+000002f0: 7374 3a20 5363 6950 790a 5265 7175 6972  st: SciPy.Requir
+00000300: 6573 2d44 6973 743a 2053 796d 5079 0a52  es-Dist: SymPy.R
+00000310: 6571 7569 7265 732d 4469 7374 3a20 6e75  equires-Dist: nu
+00000320: 6d64 6966 6674 6f6f 6c73 0a52 6571 7569  mdifftools.Requi
+00000330: 7265 732d 4469 7374 3a20 6172 6366 6c61  res-Dist: arcfla
+00000340: 7368 203b 2065 7874 7261 203d 3d20 2266  sh ; extra == "f
+00000350: 6175 6c74 220a 5265 7175 6972 6573 2d44  ault".Requires-D
+00000360: 6973 743a 206e 756d 6469 6666 746f 6f6c  ist: numdifftool
+00000370: 7320 3b20 6578 7472 6120 3d3d 2022 6675  s ; extra == "fu
+00000380: 6c6c 220a 5265 7175 6972 6573 2d44 6973  ll".Requires-Dis
+00000390: 743a 2061 7263 666c 6173 6820 3b20 6578  t: arcflash ; ex
+000003a0: 7472 6120 3d3d 2022 6675 6c6c 220a 5265  tra == "full".Re
+000003b0: 7175 6972 6573 2d44 6973 743a 206e 756d  quires-Dist: num
+000003c0: 6469 6666 746f 6f6c 7320 3b20 6578 7472  difftools ; extr
+000003d0: 6120 3d3d 2022 6e75 6d65 7269 6361 6c22  a == "numerical"
+000003e0: 0a50 726f 6a65 6374 2d55 524c 3a20 446f  .Project-URL: Do
+000003f0: 6375 6d65 6e74 6174 696f 6e2c 2068 7474  cumentation, htt
+00000400: 7073 3a2f 2f65 6c65 6374 7269 6370 792e  ps://electricpy.
+00000410: 7265 6164 7468 6564 6f63 732e 696f 2f65  readthedocs.io/e
+00000420: 6e2f 6c61 7465 7374 2f0a 5072 6f6a 6563  n/latest/.Projec
+00000430: 742d 5552 4c3a 2048 6f6d 652c 2068 7474  t-URL: Home, htt
+00000440: 7073 3a2f 2f65 6c65 6374 7269 6370 792e  ps://electricpy.
+00000450: 7265 6164 7468 6564 6f63 732e 696f 2f65  readthedocs.io/e
+00000460: 6e2f 6c61 7465 7374 2f69 6e64 6578 2e68  n/latest/index.h
+00000470: 746d 6c0a 5072 6f6a 6563 742d 5552 4c3a  tml.Project-URL:
+00000480: 2049 7373 7565 732c 2068 7474 7073 3a2f   Issues, https:/
+00000490: 2f67 6974 6875 622e 636f 6d2f 656e 6769  /github.com/engi
+000004a0: 6e65 6572 6a6f 6534 3430 2f45 6c65 6374  neerjoe440/Elect
+000004b0: 7269 6350 792f 6973 7375 6573 0a50 726f  ricPy/issues.Pro
+000004c0: 6a65 6374 2d55 524c 3a20 5265 706f 7369  ject-URL: Reposi
+000004d0: 746f 7279 2c20 6874 7470 733a 2f2f 6769  tory, https://gi
+000004e0: 7468 7562 2e63 6f6d 2f65 6e67 696e 6565  thub.com/enginee
+000004f0: 726a 6f65 3434 302f 456c 6563 7472 6963  rjoe440/Electric
+00000500: 5079 0a50 726f 7669 6465 732d 4578 7472  Py.Provides-Extr
+00000510: 613a 2066 6175 6c74 0a50 726f 7669 6465  a: fault.Provide
+00000520: 732d 4578 7472 613a 2066 756c 6c0a 5072  s-Extra: full.Pr
+00000530: 6f76 6964 6573 2d45 7874 7261 3a20 6e75  ovides-Extra: nu
+00000540: 6d65 7269 6361 6c0a 0a3c 6120 6872 6566  merical..<a href
+00000550: 3d22 6874 7470 733a 2f2f 656c 6563 7472  ="https://electr
+00000560: 6963 7079 2e72 6561 6474 6865 646f 6373  icpy.readthedocs
+00000570: 2e69 6f2f 656e 2f6c 6174 6573 742f 223e  .io/en/latest/">
+00000580: 0a20 203c 696d 6720 7372 633d 2268 7474  .  <img src="htt
+00000590: 7073 3a2f 2f72 6177 2e67 6974 6875 6275  ps://raw.githubu
+000005a0: 7365 7263 6f6e 7465 6e74 2e63 6f6d 2f65  sercontent.com/e
+000005b0: 6e67 696e 6565 726a 6f65 3434 302f 456c  ngineerjoe440/El
+000005c0: 6563 7472 6963 5079 2f6d 6173 7465 722f  ectricPy/master/
+000005d0: 6c6f 676f 2f45 6c65 6374 7269 6370 794c  logo/ElectricpyL
+000005e0: 6f67 6f2e 7376 6722 2077 6964 7468 3d22  ogo.svg" width="
+000005f0: 3230 3022 2061 6c74 3d22 6c6f 676f 2220  200" alt="logo" 
+00000600: 616c 6967 6e3d 2272 6967 6874 223e 0a3c  align="right">.<
+00000610: 2f61 3e0a 0a23 2045 6c65 6374 7269 6350  /a>..# ElectricP
+00000620: 790a 0a2a 456c 6563 7472 6963 616c 2d45  y..*Electrical-E
+00000630: 6e67 696e 6565 7269 6e67 2d66 6f72 2d50  ngineering-for-P
+00000640: 7974 686f 6e2a 0a0a 5b21 5b73 7068 696e  ython*..[![sphin
+00000650: 785d 2868 7474 7073 3a2f 2f67 6974 6875  x](https://githu
+00000660: 622e 636f 6d2f 656e 6769 6e65 6572 6a6f  b.com/engineerjo
+00000670: 6534 3430 2f45 6c65 6374 7269 6350 792f  e440/ElectricPy/
+00000680: 6163 7469 6f6e 732f 776f 726b 666c 6f77  actions/workflow
+00000690: 732f 7370 6869 6e78 2d62 7569 6c64 2e79  s/sphinx-build.y
+000006a0: 6d6c 2f62 6164 6765 2e73 7667 3f62 7261  ml/badge.svg?bra
+000006b0: 6e63 683d 6d61 7374 6572 295d 2868 7474  nch=master)](htt
+000006c0: 7073 3a2f 2f67 6974 6875 622e 636f 6d2f  ps://github.com/
+000006d0: 656e 6769 6e65 6572 6a6f 6534 3430 2f45  engineerjoe440/E
+000006e0: 6c65 6374 7269 6350 792f 6163 7469 6f6e  lectricPy/action
+000006f0: 732f 776f 726b 666c 6f77 732f 7370 6869  s/workflows/sphi
+00000700: 6e78 2d62 7569 6c64 2e79 6d6c 290a 5b21  nx-build.yml).[!
+00000710: 5b44 6f63 756d 656e 7461 7469 6f6e 2053  [Documentation S
+00000720: 7461 7475 735d 2868 7474 7073 3a2f 2f72  tatus](https://r
+00000730: 6561 6474 6865 646f 6373 2e6f 7267 2f70  eadthedocs.org/p
+00000740: 726f 6a65 6374 732f 656c 6563 7472 6963  rojects/electric
+00000750: 7079 2f62 6164 6765 2f3f 7665 7273 696f  py/badge/?versio
+00000760: 6e3d 6c61 7465 7374 295d 2868 7474 7073  n=latest)](https
+00000770: 3a2f 2f65 6c65 6374 7269 6370 792e 7265  ://electricpy.re
+00000780: 6164 7468 6564 6f63 732e 696f 2f65 6e2f  adthedocs.io/en/
+00000790: 6c61 7465 7374 2f3f 6261 6467 653d 6c61  latest/?badge=la
+000007a0: 7465 7374 290a 215b 546f 7820 496d 706f  test).![Tox Impo
+000007b0: 7274 2054 6573 745d 2868 7474 7073 3a2f  rt Test](https:/
+000007c0: 2f67 6974 6875 622e 636f 6d2f 656e 6769  /github.com/engi
+000007d0: 6e65 6572 6a6f 6534 3430 2f45 6c65 6374  neerjoe440/Elect
+000007e0: 7269 6350 792f 776f 726b 666c 6f77 732f  ricPy/workflows/
+000007f0: 546f 7825 3230 5465 7374 732f 6261 6467  Tox%20Tests/badg
+00000800: 652e 7376 6729 0a0a 5b21 5b70 7974 6573  e.svg)..[![pytes
+00000810: 745d 2868 7474 7073 3a2f 2f67 6974 6875  t](https://githu
+00000820: 622e 636f 6d2f 656e 6769 6e65 6572 6a6f  b.com/engineerjo
+00000830: 6534 3430 2f45 6c65 6374 7269 6350 792f  e440/ElectricPy/
+00000840: 6163 7469 6f6e 732f 776f 726b 666c 6f77  actions/workflow
+00000850: 732f 7079 7465 7374 2e79 6d6c 2f62 6164  s/pytest.yml/bad
+00000860: 6765 2e73 7667 3f62 7261 6e63 683d 6d61  ge.svg?branch=ma
+00000870: 7374 6572 295d 2868 7474 7073 3a2f 2f67  ster)](https://g
+00000880: 6974 6875 622e 636f 6d2f 656e 6769 6e65  ithub.com/engine
+00000890: 6572 6a6f 6534 3430 2f45 6c65 6374 7269  erjoe440/Electri
+000008a0: 6350 792f 6163 7469 6f6e 732f 776f 726b  cPy/actions/work
+000008b0: 666c 6f77 732f 7079 7465 7374 2e79 6d6c  flows/pytest.yml
+000008c0: 290a 5b21 5b70 7964 6f63 7374 796c 655d  ).[![pydocstyle]
+000008d0: 2868 7474 7073 3a2f 2f67 6974 6875 622e  (https://github.
+000008e0: 636f 6d2f 656e 6769 6e65 6572 6a6f 6534  com/engineerjoe4
+000008f0: 3430 2f45 6c65 6374 7269 6350 792f 6163  40/ElectricPy/ac
+00000900: 7469 6f6e 732f 776f 726b 666c 6f77 732f  tions/workflows/
+00000910: 7079 646f 6373 7479 6c65 2e79 6d6c 2f62  pydocstyle.yml/b
+00000920: 6164 6765 2e73 7667 3f62 7261 6e63 683d  adge.svg?branch=
+00000930: 6d61 7374 6572 295d 2868 7474 7073 3a2f  master)](https:/
+00000940: 2f67 6974 6875 622e 636f 6d2f 656e 6769  /github.com/engi
+00000950: 6e65 6572 6a6f 6534 3430 2f45 6c65 6374  neerjoe440/Elect
+00000960: 7269 6350 792f 6163 7469 6f6e 732f 776f  ricPy/actions/wo
+00000970: 726b 666c 6f77 732f 7079 646f 6373 7479  rkflows/pydocsty
+00000980: 6c65 2e79 6d6c 290a 215b 436f 7665 7261  le.yml).![Covera
+00000990: 6765 5d28 6874 7470 733a 2f2f 7261 772e  ge](https://raw.
+000009a0: 6769 7468 7562 7573 6572 636f 6e74 656e  githubuserconten
+000009b0: 742e 636f 6d2f 656e 6769 6e65 6572 6a6f  t.com/engineerjo
+000009c0: 6534 3430 2f45 6c65 6374 7269 6350 792f  e440/ElectricPy/
+000009d0: 6768 2d70 6167 6573 2f63 6f76 6572 6167  gh-pages/coverag
+000009e0: 652e 7376 6729 0a0a 5b21 5b5d 2868 7474  e.svg)..[![](htt
+000009f0: 7073 3a2f 2f69 6d67 2e73 6869 656c 6473  ps://img.shields
+00000a00: 2e69 6f2f 7079 7069 2f76 2f65 6c65 6374  .io/pypi/v/elect
+00000a10: 7269 6370 792e 7376 673f 636f 6c6f 723d  ricpy.svg?color=
+00000a20: 626c 7565 266c 6f67 6f3d 7079 7069 266c  blue&logo=pypi&l
+00000a30: 6f67 6f43 6f6c 6f72 3d77 6869 7465 295d  ogoColor=white)]
+00000a40: 2868 7474 7073 3a2f 2f70 7970 692e 6f72  (https://pypi.or
+00000a50: 672f 7072 6f6a 6563 742f 656c 6563 7472  g/project/electr
+00000a60: 6963 7079 2f29 0a5b 215b 5d28 6874 7470  icpy/).[![](http
+00000a70: 733a 2f2f 7065 7079 2e74 6563 682f 6261  s://pepy.tech/ba
+00000a80: 6467 652f 656c 6563 7472 6963 7079 295d  dge/electricpy)]
+00000a90: 2868 7474 7073 3a2f 2f70 6570 792e 7465  (https://pepy.te
+00000aa0: 6368 2f70 726f 6a65 6374 2f65 6c65 6374  ch/project/elect
+00000ab0: 7269 6370 7929 0a5b 215b 5d28 6874 7470  ricpy).[![](http
+00000ac0: 733a 2f2f 696d 672e 7368 6965 6c64 732e  s://img.shields.
+00000ad0: 696f 2f67 6974 6875 622f 7374 6172 732f  io/github/stars/
+00000ae0: 656e 6769 6e65 6572 6a6f 6534 3430 2f65  engineerjoe440/e
+00000af0: 6c65 6374 7269 6370 793f 6c6f 676f 3d67  lectricpy?logo=g
+00000b00: 6974 6875 6229 5d28 6874 7470 733a 2f2f  ithub)](https://
+00000b10: 6769 7468 7562 2e63 6f6d 2f65 6e67 696e  github.com/engin
+00000b20: 6565 726a 6f65 3434 302f 656c 6563 7472  eerjoe440/electr
+00000b30: 6963 7079 2f29 0a5b 215b 5d28 6874 7470  icpy/).[![](http
+00000b40: 733a 2f2f 696d 672e 7368 6965 6c64 732e  s://img.shields.
+00000b50: 696f 2f70 7970 692f 6c2f 656c 6563 7472  io/pypi/l/electr
+00000b60: 6963 7079 2e73 7667 3f63 6f6c 6f72 3d62  icpy.svg?color=b
+00000b70: 6c75 6529 5d28 6874 7470 733a 2f2f 6769  lue)](https://gi
+00000b80: 7468 7562 2e63 6f6d 2f65 6e67 696e 6565  thub.com/enginee
+00000b90: 726a 6f65 3434 302f 656c 6563 7472 6963  rjoe440/electric
+00000ba0: 7079 2f62 6c6f 622f 6d61 7374 6572 2f4c  py/blob/master/L
+00000bb0: 4943 454e 5345 2e74 7874 290a 0a5b 215b  ICENSE.txt)..[![
+00000bc0: 4d61 7472 6978 5d28 6874 7470 733a 2f2f  Matrix](https://
+00000bd0: 696d 672e 7368 6965 6c64 732e 696f 2f6d  img.shields.io/m
+00000be0: 6174 7269 782f 656c 6563 7472 6963 7079  atrix/electricpy
+00000bf0: 3a73 7461 6e6c 6579 736f 6c75 7469 6f6e  :stanleysolution
+00000c00: 736e 2e63 6f6d 3f6c 6162 656c 3d25 3233  sn.com?label=%23
+00000c10: 656c 6563 7472 6963 7079 3a73 7461 6e6c  electricpy:stanl
+00000c20: 6579 736f 6c75 7469 6f6e 736e 772e 636f  eysolutionsnw.co
+00000c30: 6d26 6c6f 676f 3d6d 6174 7269 7826 7365  m&logo=matrix&se
+00000c40: 7276 6572 5f66 7164 6e3d 6d61 7472 6978  rver_fqdn=matrix
+00000c50: 2e73 7461 6e6c 6579 736f 6c75 7469 6f6e  .stanleysolution
+00000c60: 736e 772e 636f 6d26 7374 796c 653d 666f  snw.com&style=fo
+00000c70: 722d 7468 652d 6261 6467 6529 5d28 6874  r-the-badge)](ht
+00000c80: 7470 733a 2f2f 6d61 7472 6978 2e74 6f2f  tps://matrix.to/
+00000c90: 232f 2365 6c65 6374 7269 6370 793a 7374  #/#electricpy:st
+00000ca0: 616e 6c65 7973 6f6c 7574 696f 6e73 6e77  anleysolutionsnw
+00000cb0: 2e63 6f6d 290a 0a5b 215b 2242 7579 204d  .com)..[!["Buy M
+00000cc0: 6520 4120 436f 6666 6565 225d 2868 7474  e A Coffee"](htt
+00000cd0: 7073 3a2f 2f77 7777 2e62 7579 6d65 6163  ps://www.buymeac
+00000ce0: 6f66 6665 652e 636f 6d2f 6173 7365 7473  offee.com/assets
+00000cf0: 2f69 6d67 2f63 7573 746f 6d5f 696d 6167  /img/custom_imag
+00000d00: 6573 2f6f 7261 6e67 655f 696d 672e 706e  es/orange_img.pn
+00000d10: 6729 5d28 6874 7470 733a 2f2f 7777 772e  g)](https://www.
+00000d20: 6275 796d 6561 636f 6666 6565 2e63 6f6d  buymeacoffee.com
+00000d30: 2f65 6e67 696e 6565 726a 6f65 3434 3029  /engineerjoe440)
+00000d40: 0a0a 0a50 7974 686f 6e20 4c69 6272 6172  ...Python Librar
+00000d50: 6965 7320 7769 7468 2066 756e 6374 696f  ies with functio
+00000d60: 6e73 2061 6e64 2063 6f6e 7374 616e 7473  ns and constants
+00000d70: 2072 656c 6174 6564 2074 6f20 656c 6563   related to elec
+00000d80: 7472 6963 616c 2065 6e67 696e 6565 7269  trical engineeri
+00000d90: 6e67 2e0a 0a54 6865 2066 756e 6374 696f  ng...The functio
+00000da0: 6e73 2061 6e64 2063 6f6e 7374 616e 7473  ns and constants
+00000db0: 2074 6861 7420 6d61 6b65 2075 7020 7468   that make up th
+00000dc0: 6573 6520 6d6f 6475 6c65 7320 7265 7072  ese modules repr
+00000dd0: 6573 656e 7420 6120 6c69 6272 6172 7920  esent a library 
+00000de0: 6f66 0a6d 6174 6572 6961 6c20 636f 6d70  of.material comp
+00000df0: 696c 6564 2077 6974 6820 7468 6520 696e  iled with the in
+00000e00: 7465 6e74 206f 6620 6265 696e 6720 7573  tent of being us
+00000e10: 6564 2070 7269 6d61 7269 6c79 2066 6f72  ed primarily for
+00000e20: 2072 6573 6561 7263 682c 0a64 6576 656c   research,.devel
+00000e30: 6f70 6d65 6e74 2c20 6564 7563 6174 696f  opment, educatio
+00000e40: 6e2c 2061 6e64 2065 7870 6c6f 7261 7469  n, and explorati
+00000e50: 6f6e 2069 6e20 7468 6520 7265 616c 6d20  on in the realm 
+00000e60: 6f66 2065 6c65 6374 7269 6361 6c20 656e  of electrical en
+00000e70: 6769 6e65 6572 696e 672e 0a0a 4368 6563  gineering...Chec
+00000e80: 6b20 6f75 7420 6f75 7220 6675 6c6c 2064  k out our full d
+00000e90: 6f63 756d 656e 7461 7469 6f6e 3a20 6874  ocumentation: ht
+00000ea0: 7470 733a 2f2f 656c 6563 7472 6963 7079  tps://electricpy
+00000eb0: 2e72 6561 6474 6865 646f 6373 2e69 6f2f  .readthedocs.io/
+00000ec0: 656e 2f6c 6174 6573 742f 0a0a 3c61 2074  en/latest/..<a t
+00000ed0: 6974 6c65 3d22 4661 6269 c3a1 6e20 416c  itle="Fabi..n Al
+00000ee0: 6578 6973 2c20 4343 2042 592d 5341 2033  exis, CC BY-SA 3
+00000ef0: 2e30 2026 6c74 3b68 7474 7073 3a2f 2f63  .0 &lt;https://c
+00000f00: 7265 6174 6976 6563 6f6d 6d6f 6e73 2e6f  reativecommons.o
+00000f10: 7267 2f6c 6963 656e 7365 732f 6279 2d73  rg/licenses/by-s
+00000f20: 612f 332e 3026 6774 3b2c 2076 6961 2057  a/3.0&gt;, via W
+00000f30: 696b 696d 6564 6961 2043 6f6d 6d6f 6e73  ikimedia Commons
+00000f40: 2220 6872 6566 3d22 6874 7470 733a 2f2f  " href="https://
+00000f50: 636f 6d6d 6f6e 732e 7769 6b69 6d65 6469  commons.wikimedi
+00000f60: 612e 6f72 672f 7769 6b69 2f46 696c 653a  a.org/wiki/File:
+00000f70: 416e 7475 5f64 6961 6c6f 672d 7761 726e  Antu_dialog-warn
+00000f80: 696e 672e 7376 6722 3e3c 696d 6720 7769  ing.svg"><img wi
+00000f90: 6474 683d 2232 3570 7822 2061 6c74 3d22  dth="25px" alt="
+00000fa0: 416e 7475 2064 6961 6c6f 672d 7761 726e  Antu dialog-warn
+00000fb0: 696e 6722 2073 7263 3d22 6874 7470 733a  ing" src="https:
+00000fc0: 2f2f 7570 6c6f 6164 2e77 696b 696d 6564  //upload.wikimed
+00000fd0: 6961 2e6f 7267 2f77 696b 6970 6564 6961  ia.org/wikipedia
+00000fe0: 2f63 6f6d 6d6f 6e73 2f74 6875 6d62 2f66  /commons/thumb/f
+00000ff0: 2f66 372f 416e 7475 5f64 6961 6c6f 672d  /f7/Antu_dialog-
+00001000: 7761 726e 696e 672e 7376 672f 3531 3270  warning.svg/512p
+00001010: 782d 416e 7475 5f64 6961 6c6f 672d 7761  x-Antu_dialog-wa
+00001020: 726e 696e 672e 7376 672e 706e 6722 3e3c  rning.svg.png"><
+00001030: 2f61 3e20 2a2a 446f 6375 6d65 6e74 6174  /a> **Documentat
+00001040: 696f 6e20 6861 7320 7265 6365 6e74 6c79  ion has recently
+00001050: 2062 6565 6e20 7570 6461 7465 6420 746f   been updated to
+00001060: 2075 7365 205b 5265 6164 5468 6544 6f63   use [ReadTheDoc
+00001070: 735d 2868 7474 7073 3a2f 2f72 6561 6474  s](https://readt
+00001080: 6865 646f 6373 2e6f 7267 2f29 2a2a 0a0a  hedocs.org/)**..
+00001090: 4769 7448 7562 2050 6167 6573 2061 7265  GitHub Pages are
+000010a0: 2073 7469 6c6c 2061 6374 6976 652c 2061   still active, a
+000010b0: 6e64 2077 696c 6c20 636f 6e74 696e 7565  nd will continue
+000010c0: 2074 6f20 6265 2066 6f72 2074 6865 2066   to be for the f
+000010d0: 6f72 7365 6561 626c 650a 6675 7475 7265  orseeable.future
+000010e0: 2c20 6275 7420 7468 6579 2772 6520 696e  , but they're in
+000010f0: 7465 6e64 6564 2066 6f72 2064 6576 656c  tended for devel
+00001100: 6f70 6d65 6e74 616c 2075 7064 6174 6573  opmental updates
+00001110: 2072 6174 6865 7220 7468 616e 2070 7269   rather than pri
+00001120: 6d61 7279 0a64 6f63 756d 656e 7461 7469  mary.documentati
+00001130: 6f6e 2e0a 0a23 2320 4665 6174 7572 6573  on...## Features
+00001140: 0a0a 2a20 4578 7465 6e73 6976 6520 7365  ..* Extensive se
+00001150: 7420 6f66 2063 6f6d 6d6f 6e20 6675 6e63  t of common func
+00001160: 7469 6f6e 7320 616e 6420 666f 726d 756c  tions and formul
+00001170: 6173 2066 6f72 2065 6c65 6374 7269 6361  as for electrica
+00001180: 6c20 656e 6769 6e65 6572 696e 6720 616e  l engineering an
+00001190: 640a 656c 6563 7472 6f6e 6963 732e 0a2a  d.electronics..*
+000011a0: 2053 7570 706f 7274 2066 6f72 204c 6154   Support for LaT
+000011b0: 6558 206d 6174 6820 6765 6e65 7261 7469  eX math generati
+000011c0: 6f6e 2028 7573 6520 7468 6973 2069 6e20  on (use this in 
+000011d0: 636f 6e6a 756e 6374 696f 6e20 7769 7468  conjunction with
+000011e0: 2079 6f75 7220 4a75 7079 7465 720a 6e6f   your Jupyter.no
+000011f0: 7465 626f 6f6b 7321 290a 2a20 4765 6e65  tebooks!).* Gene
+00001200: 7261 7465 2066 6f63 7573 7365 6420 616e  rate focussed an
+00001210: 6420 7369 6d70 6c65 2070 6c6f 7473 2c20  d simple plots, 
+00001220: 6469 6167 7261 6d73 2c20 616e 6420 6669  diagrams, and fi
+00001230: 6775 7265 732e 0a0a 2323 2320 5361 6d70  gures...### Samp
+00001240: 6c65 7320 4765 6e65 7261 7465 6420 7769  les Generated wi
+00001250: 7468 2045 6c65 6374 7269 6350 790a 0a7c  th ElectricPy..|
+00001260: 2050 6861 736f 7220 506c 6f74 207c 2050   Phasor Plot | P
+00001270: 6f77 6572 2054 7269 616e 676c 6520 7c20  ower Triangle | 
+00001280: 496e 6475 6374 696f 6e20 4d6f 746f 7220  Induction Motor 
+00001290: 4369 7263 6c65 207c 0a7c 2d2d 2d2d 2d2d  Circle |.|------
+000012a0: 2d2d 2d2d 2d2d 2d7c 2d2d 2d2d 2d2d 2d2d  -------|--------
+000012b0: 2d2d 2d2d 2d2d 2d2d 7c2d 2d2d 2d2d 2d2d  --------|-------
+000012c0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+000012d0: 2d7c 0a7c 2021 5b5d 2868 7474 7073 3a2f  -|.| ![](https:/
+000012e0: 2f72 6177 2e67 6974 6875 6275 7365 7263  /raw.githubuserc
+000012f0: 6f6e 7465 6e74 2e63 6f6d 2f65 6e67 696e  ontent.com/engin
+00001300: 6565 726a 6f65 3434 302f 456c 6563 7472  eerjoe440/Electr
+00001310: 6963 5079 2f64 6576 656c 6f70 2f64 6f63  icPy/develop/doc
+00001320: 736f 7572 6365 2f73 7461 7469 632f 5068  source/static/Ph
+00001330: 6173 6f72 506c 6f74 2e70 6e67 2920 7c20  asorPlot.png) | 
+00001340: 215b 5d28 6874 7470 733a 2f2f 7261 772e  ![](https://raw.
+00001350: 6769 7468 7562 7573 6572 636f 6e74 656e  githubuserconten
+00001360: 742e 636f 6d2f 656e 6769 6e65 6572 6a6f  t.com/engineerjo
+00001370: 6534 3430 2f45 6c65 6374 7269 6350 792f  e440/ElectricPy/
+00001380: 6465 7665 6c6f 702f 646f 6373 6f75 7263  develop/docsourc
+00001390: 652f 7374 6174 6963 2f50 6f77 6572 5472  e/static/PowerTr
+000013a0: 6961 6e67 6c65 2e70 6e67 2920 7c20 215b  iangle.png) | ![
+000013b0: 5d28 6874 7470 733a 2f2f 7261 772e 6769  ](https://raw.gi
+000013c0: 7468 7562 7573 6572 636f 6e74 656e 742e  thubusercontent.
+000013d0: 636f 6d2f 656e 6769 6e65 6572 6a6f 6534  com/engineerjoe4
+000013e0: 3430 2f45 6c65 6374 7269 6350 792f 6465  40/ElectricPy/de
+000013f0: 7665 6c6f 702f 646f 6373 6f75 7263 652f  velop/docsource/
+00001400: 7374 6174 6963 2f49 6e64 7563 7469 6f6e  static/Induction
+00001410: 4d6f 746f 7243 6972 636c 6545 7861 6d70  MotorCircleExamp
+00001420: 6c65 2e70 6e67 2920 7c0a 0a23 2320 496e  le.png) |..## In
+00001430: 7374 616c 6c69 6e67 202f 2047 6574 7469  stalling / Getti
+00001440: 6e67 2053 7461 7274 6564 0a0a 312e 2045  ng Started..1. E
+00001450: 6c65 6374 7269 6350 7920 6861 7320 6120  lectricPy has a 
+00001460: 6665 7720 6261 7369 6320 696e 7374 616c  few basic instal
+00001470: 6c61 7469 6f6e 206f 7074 696f 6e73 2066  lation options f
+00001480: 6f72 2075 7365 2077 6974 6820 6070 6970  or use with `pip
+00001490: 602e 2046 6f72 206d 6f73 740a 636f 6d6d  `. For most.comm
+000014a0: 6f6e 2075 7365 7273 2c20 7573 6520 7468  on users, use th
+000014b0: 6520 666f 6c6c 6f77 696e 6720 636f 6d6d  e following comm
+000014c0: 616e 6420 746f 2069 6e73 7461 6c6c 2045  and to install E
+000014d0: 6c65 6374 7269 6350 7920 7769 7468 2060  lectricPy with `
+000014e0: 7069 7060 0a0a 6060 600a 7069 7020 696e  pip`..```.pip in
+000014f0: 7374 616c 6c20 656c 6563 7472 6963 7079  stall electricpy
+00001500: 5b66 756c 6c5d 0a60 6060 0a20 200a 322e  [full].```.  .2.
+00001510: 2043 6865 636b 2069 6e73 7461 6c6c 6174   Check installat
+00001520: 696f 6e20 7375 6363 6573 7320 696e 2050  ion success in P
+00001530: 7974 686f 6e20 656e 7669 726f 6e6d 656e  ython environmen
+00001540: 743a 0a0a 6060 6070 7974 686f 6e0a 696d  t:..```python.im
+00001550: 706f 7274 2065 6c65 6374 7269 6370 790a  port electricpy.
+00001560: 656c 6563 7472 6963 7079 2e5f 7665 7273  electricpy._vers
+00001570: 696f 6e5f 0a60 6060 0a0a 332e 2053 7461  ion_.```..3. Sta
+00001580: 7274 2075 7369 6e67 2074 6865 2065 6c65  rt using the ele
+00001590: 6374 7269 6361 6c20 656e 6769 6e65 6572  ctrical engineer
+000015a0: 696e 6720 666f 726d 756c 6173 0a0a 6060  ing formulas..``
+000015b0: 6070 7974 686f 6e0a 3e3e 3e20 696d 706f  `python.>>> impo
+000015c0: 7274 2065 6c65 6374 7269 6370 7920 6173  rt electricpy as
+000015d0: 2065 700a 3e3e 3e20 766f 6c74 6167 6520   ep.>>> voltage 
+000015e0: 3d20 6570 2e70 6861 736f 7228 3637 2c20  = ep.phasor(67, 
+000015f0: 3132 3029 2023 2036 3720 766f 6c74 7320  120) # 67 volts 
+00001600: 6174 2061 6e67 6c65 2031 3230 2064 6567  at angle 120 deg
+00001610: 7265 6573 0a3e 3e3e 2076 6f6c 7461 6765  rees.>>> voltage
+00001620: 0a28 2d33 332e 3439 3939 3939 3939 3939  .(-33.4999999999
+00001630: 3939 3938 362b 3538 2e30 3233 3730 3230  99986+58.0237020
+00001640: 3533 3535 3733 396a 290a 3e3e 3e20 6570  5355739j).>>> ep
+00001650: 2e63 7072 696e 7428 766f 6c74 6167 6529  .cprint(voltage)
+00001660: 0a36 372e 3020 e288 a020 3132 302e 30c2  .67.0 ... 120.0.
+00001670: b00a 6060 600a 0a23 2323 2049 6e73 7461  ..```..### Insta
+00001680: 6c6c 696e 6720 6672 6f6d 2053 6f75 7263  lling from Sourc
+00001690: 650a 0a49 6620 796f 7527 7265 206c 6f6f  e..If you're loo
+000016a0: 6b69 6e67 2074 6f20 6765 7420 7468 6520  king to get the 
+000016b0: 226c 6174 6573 7420 616e 6420 6772 6561  "latest and grea
+000016c0: 7465 7374 2220 6672 6f6d 2065 6c65 6374  test" from elect
+000016d0: 7269 6370 792c 2079 6f75 276c 6c20 7761  ricpy, you'll wa
+000016e0: 6e74 0a74 6f20 696e 7374 616c 6c20 6469  nt.to install di
+000016f0: 7265 6374 6c79 2066 726f 6d20 4769 7448  rectly from GitH
+00001700: 7562 2c20 796f 7520 6361 6e20 646f 2074  ub, you can do t
+00001710: 6861 7420 6f6e 6520 6f66 2074 776f 2077  hat one of two w
+00001720: 6179 732c 2074 6865 2065 6173 6965 7374  ays, the easiest
+00001730: 206f 660a 7768 6963 6820 6973 2074 6f20   of.which is to 
+00001740: 7369 6d70 6c79 2069 7373 7565 2074 6865  simply issue the
+00001750: 2066 6f6c 6c6f 7769 6e67 2063 6f6d 6d61   following comma
+00001760: 6e64 2066 6f72 2060 7069 7060 0a0a 6060  nd for `pip`..``
+00001770: 600a 7069 7020 696e 7374 616c 6c20 6769  `.pip install gi
+00001780: 742b 6874 7470 733a 2f2f 6769 7468 7562  t+https://github
+00001790: 2e63 6f6d 2f65 6e67 696e 6565 726a 6f65  .com/engineerjoe
+000017a0: 3434 302f 456c 6563 7472 6963 5079 2e67  440/ElectricPy.g
+000017b0: 6974 0a60 6060 0a0a 416c 7465 726e 6174  it.```..Alternat
+000017c0: 6976 656c 792c 2079 6f75 2063 616e 2064  ively, you can d
+000017d0: 6f20 6974 2074 6865 2022 6f6c 6420 6661  o it the "old fa
+000017e0: 7368 696f 6e65 6420 7761 7922 2062 7920  shioned way" by 
+000017f0: 636c 6f6e 696e 6720 7468 6520 7265 706f  cloning the repo
+00001800: 7369 746f 7279 0a61 6e64 2069 6e73 7461  sitory.and insta
+00001810: 6c6c 696e 6720 6c6f 6361 6c6c 792e 0a0a  lling locally...
+00001820: 312e 2043 6c6f 6e65 2f44 6f77 6e6c 6f61  1. Clone/Downloa
+00001830: 6420 536f 7572 6365 2043 6f64 6520 6672  d Source Code fr
+00001840: 6f6d 205b 4769 7448 7562 2052 6570 6f73  om [GitHub Repos
+00001850: 6974 6f72 795d 2868 7474 7073 3a2f 2f67  itory](https://g
+00001860: 6974 6875 622e 636f 6d2f 656e 6769 6e65  ithub.com/engine
+00001870: 6572 6a6f 6534 3430 2f45 6c65 6374 7269  erjoe440/Electri
+00001880: 6350 7929 0a32 2e20 4f70 656e 2054 6572  cPy).2. Open Ter
+00001890: 6d69 6e61 6c20 616e 6420 4e61 7669 6761  minal and Naviga
+000018a0: 7465 2074 6f20 466f 6c64 6572 2077 6974  te to Folder wit
+000018b0: 6820 6063 6460 2043 6f6d 6d61 6e64 733a  h `cd` Commands:
+000018c0: 0a20 202d 2060 6364 203c 7061 7468 5c74  .  - `cd <path\t
+000018d0: 6f5c 636f 6e74 6169 6e69 6e67 5c66 6f6c  o\containing\fol
+000018e0: 6465 723e 5c65 6c65 6374 7269 6370 7960  der>\electricpy`
+000018f0: 0a33 2e20 5573 6520 5079 7468 6f6e 2074  .3. Use Python t
+00001900: 6f20 496e 7374 616c 6c20 4d6f 6475 6c65  o Install Module
+00001910: 2066 726f 6d20 6073 6574 7570 2e70 7960   from `setup.py`
+00001920: 3a0a 2020 2d20 6070 6970 2069 6e73 7461  :.  - `pip insta
+00001930: 6c6c 202e 600a 0a23 2323 2044 6570 656e  ll .`..### Depen
+00001940: 6465 6e63 6965 730a 0a2d 205b 4e75 6d50  dencies..- [NumP
+00001950: 795d 2868 7474 7073 3a2f 2f6e 756d 7079  y](https://numpy
+00001960: 2e6f 7267 2f29 0a2d 205b 6d61 7470 6c6f  .org/).- [matplo
+00001970: 746c 6962 5d28 6874 7470 733a 2f2f 6d61  tlib](https://ma
+00001980: 7470 6c6f 746c 6962 2e6f 7267 2f29 0a2d  tplotlib.org/).-
+00001990: 205b 5363 6950 795d 2868 7474 7073 3a2f   [SciPy](https:/
+000019a0: 2f73 6369 7079 2e6f 7267 2f29 0a2d 205b  /scipy.org/).- [
+000019b0: 5379 6d50 795d 2868 7474 7073 3a2f 2f77  SymPy](https://w
+000019c0: 7777 2e73 796d 7079 2e6f 7267 2f65 6e2f  ww.sympy.org/en/
+000019d0: 696e 6465 782e 6874 6d6c 290a 0a23 2323  index.html)..###
+000019e0: 2320 4f70 7469 6f6e 616c 2044 6570 656e  # Optional Depen
+000019f0: 6465 6e63 6965 730a 0a46 6f72 206e 756d  dencies..For num
+00001a00: 6572 6963 616c 2061 6e61 6c79 7369 7320  erical analysis 
+00001a10: 2869 6e73 7461 6c6c 2077 6974 6820 6070  (install with `p
+00001a20: 6970 2069 6e73 7461 6c6c 2065 6c65 6374  ip install elect
+00001a30: 7269 6370 795b 6e75 6d65 7269 6361 6c5d  ricpy[numerical]
+00001a40: 6029 3a0a 0a2d 205b 6e75 6d64 6966 6674  `):..- [numdifft
+00001a50: 6f6f 6c73 5d28 6874 7470 733a 2f2f 6e75  ools](https://nu
+00001a60: 6d64 6966 6674 6f6f 6c73 2e72 6561 6474  mdifftools.readt
+00001a70: 6865 646f 6373 2e69 6f2f 656e 2f6c 6174  hedocs.io/en/lat
+00001a80: 6573 742f 290a 0a46 6f72 2066 6175 6c74  est/)..For fault
+00001a90: 2061 6e61 6c79 7369 7320 2869 6e73 7461   analysis (insta
+00001aa0: 6c6c 2077 6974 6820 6070 6970 2069 6e73  ll with `pip ins
+00001ab0: 7461 6c6c 2065 6c65 6374 7269 6370 795b  tall electricpy[
+00001ac0: 6661 756c 745d 6029 0a0a 2d20 5b61 7263  fault]`)..- [arc
+00001ad0: 666c 6173 685d 2868 7474 7073 3a2f 2f67  flash](https://g
+00001ae0: 6974 6875 622e 636f 6d2f 4c69 6175 6e67  ithub.com/Liaung
+00001af0: 5969 702f 6172 6366 6c61 7368 290a 0a0a  Yip/arcflash)...
+00001b00: 2323 2047 6574 2049 6e76 6f6c 7665 6420  ## Get Involved 
+00001b10: 2f20 436f 6e74 7269 6275 7465 0a0a 4966  / Contribute..If
+00001b20: 2079 6f75 2772 6520 696e 7465 7265 7374   you're interest
+00001b30: 6564 2069 6e20 636f 6e74 7269 6275 7469  ed in contributi
+00001b40: 6e67 2c20 7765 2764 206c 6f76 6520 746f  ng, we'd love to
+00001b50: 2073 6565 2079 6f75 7220 7375 7070 6f72   see your suppor
+00001b60: 7420 696e 2061 206e 756d 6265 720a 6f66  t in a number.of
+00001b70: 2077 6179 7321 0a0a 312e 202a 2a57 7269   ways!..1. **Wri
+00001b80: 7465 2054 6573 7473 2a2a 202d 2057 6527  te Tests** - We'
+00001b90: 7265 2072 6561 6c6c 7920 6c61 636b 696e  re really lackin
+00001ba0: 6720 696e 2074 6869 7320 6172 6561 2e20  g in this area. 
+00001bb0: 5765 2776 6520 7265 6365 6e74 6c79 2061  We've recently a
+00001bc0: 6464 6564 0a73 696d 706c 6520 4769 7448  dded.simple GitH
+00001bd0: 7562 2061 6374 696f 6e73 2074 6f20 7465  ub actions to te
+00001be0: 7374 2069 6e73 7461 6c6c 6174 696f 6e2c  st installation,
+00001bf0: 2062 7574 2074 6861 7427 7320 6162 6f75   but that's abou
+00001c00: 7420 6974 2e20 5765 2068 6f70 6520 7468  t it. We hope th
+00001c10: 6174 0a73 6f6d 6564 6179 2077 6520 6361  at.someday we ca
+00001c20: 6e20 7465 7374 2061 6c6c 2066 756e 6374  n test all funct
+00001c30: 696f 6e73 2069 6e20 7468 6973 206d 6f64  ions in this mod
+00001c40: 756c 6520 666f 7220 7665 7269 6669 6361  ule for verifica
+00001c50: 7469 6f6e 2e0a 322e 202a 2a43 6f6e 7472  tion..2. **Contr
+00001c60: 6962 7574 6520 4e65 7720 456c 6563 7472  ibute New Electr
+00001c70: 6963 616c 2045 6e67 696e 6565 7269 6e67  ical Engineering
+00001c80: 2046 756e 6374 696f 6e73 2a2a 202d 2049   Functions** - I
+00001c90: 6620 796f 7527 7665 2067 6f74 2061 206e  f you've got a n
+00001ca0: 6577 0a66 756e 6374 696f 6e20 7265 6c61  ew.function rela
+00001cb0: 7465 6420 746f 2065 6c65 6374 7269 6361  ted to electrica
+00001cc0: 6c20 656e 6769 6e65 6572 696e 6720 7468  l engineering th
+00001cd0: 6174 2079 6f75 2764 206c 696b 6520 746f  at you'd like to
+00001ce0: 2073 6565 2061 6464 6564 2c20 7765 2764   see added, we'd
+00001cf0: 0a6c 6f76 6520 746f 2074 6872 6f77 2069  .love to throw i
+00001d00: 7420 696e 746f 2074 6869 7320 6d6f 6475  t into this modu
+00001d10: 6c65 2e20 4f75 7220 676f 616c 2069 7320  le. Our goal is 
+00001d20: 7468 6174 2074 6869 7320 6d6f 6475 6c65  that this module
+00001d30: 2063 616e 2062 6563 6f6d 6520 7468 650a   can become the.
+00001d40: 636f 6d70 7265 6865 6e73 6976 6520 656c  comprehensive el
+00001d50: 6563 7472 6963 616c 2065 6e67 696e 6565  ectrical enginee
+00001d60: 7269 6e67 2074 6f6f 6c6b 6974 2069 6e20  ring toolkit in 
+00001d70: 5079 7468 6f6e 2e20 4472 6f70 2075 7320  Python. Drop us 
+00001d80: 6120 6e6f 7465 2c20 6f72 0a63 7265 6174  a note, or.creat
+00001d90: 6520 6120 5b70 756c 6c20 7265 7175 6573  e a [pull reques
+00001da0: 745d 2868 7474 7073 3a2f 2f67 6974 6875  t](https://githu
+00001db0: 622e 636f 6d2f 656e 6769 6e65 6572 6a6f  b.com/engineerjo
+00001dc0: 6534 3430 2f45 6c65 6374 7269 6350 792f  e440/ElectricPy/
+00001dd0: 7075 6c6c 7329 210a 332e 202a 2a52 6570  pulls)!.3. **Rep
+00001de0: 6f72 7420 4973 7375 6573 2a2a 202d 2057  ort Issues** - W
+00001df0: 6520 646f 6e27 7420 7761 6e74 2069 7373  e don't want iss
+00001e00: 7565 7320 746f 2067 6f20 756e 6e6f 7469  ues to go unnoti
+00001e10: 6365 642e 2050 6c65 6173 6520 6865 6c70  ced. Please help
+00001e20: 2075 730a 7472 6163 6b20 6275 6773 2069   us.track bugs i
+00001e30: 6e20 5b6f 7572 2069 7373 7565 735d 2868  n [our issues](h
+00001e40: 7474 7073 3a2f 2f67 6974 6875 622e 636f  ttps://github.co
+00001e50: 6d2f 656e 6769 6e65 6572 6a6f 6534 3430  m/engineerjoe440
+00001e60: 2f45 6c65 6374 7269 6350 792f 6973 7375  /ElectricPy/issu
+00001e70: 6573 290a 616e 6420 7265 736f 6c76 6520  es).and resolve 
+00001e80: 7468 656d 210a 342e 202a 2a47 6574 2074  them!.4. **Get t
+00001e90: 6865 2057 6f72 6420 4f75 742a 2a20 2d20  he Word Out** - 
+00001ea0: 5468 6973 2070 726f 6a65 6374 2069 7320  This project is 
+00001eb0: 7374 696c 6c20 696e 2069 7473 2069 6e66  still in its inf
+00001ec0: 616e 6379 2c20 736f 2070 6c65 6173 6520  ancy, so please 
+00001ed0: 7368 6172 650a 6974 2077 6974 6820 796f  share.it with yo
+00001ee0: 7572 2066 7269 656e 6473 2061 6e64 2063  ur friends and c
+00001ef0: 6f6c 6c65 6167 7565 732e 2057 6520 7761  olleagues. We wa
+00001f00: 6e74 2074 6f20 6d61 6b65 2073 7572 6520  nt to make sure 
+00001f10: 7468 6174 2065 7665 7279 6f6e 6520 6861  that everyone ha
+00001f20: 7320 7468 650a 6f70 706f 7274 756e 6974  s the.opportunit
+00001f30: 7920 746f 2074 616b 6520 6164 7661 6e74  y to take advant
+00001f40: 6167 6520 6f66 2074 6869 7320 7072 6f6a  age of this proj
+00001f50: 6563 742e 0a0a 2a2a 4368 6563 6b20 6f75  ect...**Check ou
+00001f60: 7420 7468 6520 5b63 6f6e 7472 6962 7574  t the [contribut
+00001f70: 696f 6e20 6775 6964 655d 2868 7474 7073  ion guide](https
+00001f80: 3a2f 2f67 6974 6875 622e 636f 6d2f 656e  ://github.com/en
+00001f90: 6769 6e65 6572 6a6f 6534 3430 2f45 6c65  gineerjoe440/Ele
+00001fa0: 6374 7269 6350 792f 626c 6f62 2f6d 6173  ctricPy/blob/mas
+00001fb0: 7465 722f 434f 4e54 5249 4255 5449 4e47  ter/CONTRIBUTING
+00001fc0: 2e6d 6429 2a2a 0a0a 2a2a 436f 6d65 205b  .md)**..**Come [
+00001fd0: 6368 6174 2061 626f 7574 2045 6c65 6374  chat about Elect
+00001fe0: 7269 6350 795d 2868 7474 7073 3a2f 2f6d  ricPy](https://m
+00001ff0: 6174 7269 782e 746f 2f23 2f23 656c 6563  atrix.to/#/#elec
+00002000: 7472 6963 7079 3a73 7461 6e6c 6579 736f  tricpy:stanleyso
+00002010: 6c75 7469 6f6e 736e 772e 636f 6d29 2a2a  lutionsnw.com)**
+00002020: 0a0a 2323 2320 5370 6563 6961 6c20 7468  ..### Special th
+00002030: 616e 6b73 2074 6f2e 2e2e 0a0a 2d20 5374  anks to.....- St
+00002040: 6570 6865 6e20 5765 656b 7320 7c20 5374  ephen Weeks | St
+00002050: 7564 656e 7420 2d20 5520 6f66 2049 6461  udent - U of Ida
+00002060: 686f 0a2d 204a 6572 656d 7920 5065 7268  ho.- Jeremy Perh
+00002070: 6163 207c 2053 7475 6465 6e74 202d 2055  ac | Student - U
+00002080: 206f 6620 4964 6168 6f0a 2d20 4461 6e69   of Idaho.- Dani
+00002090: 656c 2041 6c6c 656e 207c 2053 7475 6465  el Allen | Stude
+000020a0: 6e74 202d 2055 6e69 7665 7273 7469 7920  nt - Universtiy 
+000020b0: 6f66 2049 6461 686f 0a2d 2044 722e 2044  of Idaho.- Dr. D
+000020c0: 656e 6e69 7320 5375 6c6c 6976 616e 207c  ennis Sullivan |
+000020d0: 2050 726f 6666 6573 736f 7220 2d20 5520   Proffessor - U 
+000020e0: 6f66 2049 6461 686f 0a2d 2044 722e 2042  of Idaho.- Dr. B
+000020f0: 7269 616e 204a 6f68 6e73 6f6e 207c 2050  rian Johnson | P
+00002100: 726f 6666 6573 736f 7220 2d20 5520 6f66  roffessor - U of
+00002110: 2049 6461 686f 0a2d 2044 722e 204a 6f65   Idaho.- Dr. Joe
+00002120: 204c 6177 207c 2050 726f 6666 6573 736f   Law | Proffesso
+00002130: 7220 2d20 5520 6f66 2049 6461 686f 0a2d  r - U of Idaho.-
+00002140: 2053 7461 636b 4f76 6572 666c 6f77 2075   StackOverflow u
+00002150: 7365 7220 6767 3334 390a 2d20 5368 6175  ser gg349.- Shau
+00002160: 7279 6120 5570 7061 6c20 7c20 4f6e 6c69  rya Uppal | Onli
+00002170: 6e65 2043 6f64 6520 436f 6e74 7269 6275  ne Code Contribu
+00002180: 746f 720a 2d20 5061 756c 204f 7274 6d61  tor.- Paul Ortma
+00002190: 6e20 7c20 506f 7765 7220 5175 616c 6974  n | Power Qualit
+000021a0: 7920 456e 6769 6e65 6572 202d 2049 6461  y Engineer - Ida
+000021b0: 686f 2050 6f77 6572 207c 2049 6e73 7472  ho Power | Instr
+000021c0: 7563 746f 7220 2d20 5520 6f66 2049 6461  uctor - U of Ida
+000021d0: 686f 0a0a 2a61 6e64 2a0a 0a3c 6120 6872  ho..*and*..<a hr
+000021e0: 6566 3d22 6874 7470 733a 2f2f 6769 7468  ef="https://gith
+000021f0: 7562 2e63 6f6d 2f65 6e67 696e 6565 726a  ub.com/engineerj
+00002200: 6f65 3434 302f 656c 6563 7472 6963 7079  oe440/electricpy
+00002210: 2f67 7261 7068 732f 636f 6e74 7269 6275  /graphs/contribu
+00002220: 746f 7273 223e 0a20 203c 696d 6720 7372  tors">.  <img sr
+00002230: 633d 2268 7474 7073 3a2f 2f63 6f6e 7472  c="https://contr
+00002240: 6962 2e72 6f63 6b73 2f69 6d61 6765 3f72  ib.rocks/image?r
+00002250: 6570 6f3d 656e 6769 6e65 6572 6a6f 6534  epo=engineerjoe4
+00002260: 3430 2f65 6c65 6374 7269 6370 7922 2061  40/electricpy" a
+00002270: 6c74 3d22 636f 6e74 7269 6275 746f 7273  lt="contributors
+00002280: 223e 0a3c 2f61 3e0a 0a23 2320 436f 6e74  ">.</a>..## Cont
+00002290: 6163 740a 0a46 6f72 206d 6f72 6520 696e  act..For more in
+000022a0: 666f 726d 6174 696f 6e20 7265 6761 7264  formation regard
+000022b0: 696e 6720 7468 6973 2072 6573 6f75 7263  ing this resourc
+000022c0: 652c 2070 6c65 6173 6520 636f 6e74 6163  e, please contac
+000022d0: 7420 4a6f 6520 5374 616e 6c65 790a 0a2d  t Joe Stanley..-
+000022e0: 203c 656e 6769 6e65 6572 6a6f 6534 3430   <engineerjoe440
+000022f0: 4079 6168 6f6f 2e63 6f6d 3e0a 0a23 2320  @yahoo.com>..## 
+00002300: 4c69 6365 6e73 6520 616e 6420 5573 6167  License and Usag
+00002310: 650a 0a45 6c65 6374 7269 6350 7920 6973  e..ElectricPy is
+00002320: 206c 6963 656e 7365 6420 756e 6465 7220   licensed under 
+00002330: 7468 6520 7374 616e 6461 7264 204d 4954  the standard MIT
+00002340: 206c 6963 656e 7365 2c20 616e 6420 6173   license, and as
+00002350: 2073 7563 682c 2079 6f75 2061 7265 0a70   such, you are.p
+00002360: 6572 6d69 7474 6564 2074 6f20 7573 6520  ermitted to use 
+00002370: 7468 6973 2072 6573 6f75 7263 6520 6173  this resource as
+00002380: 2079 6f75 2073 6565 2066 6974 2e20 506c   you see fit. Pl
+00002390: 6561 7365 2066 6565 6c20 6672 6565 2074  ease feel free t
+000023a0: 6f20 6173 6b0a 7175 6573 7469 6f6e 732c  o ask.questions,
+000023b0: 2073 7567 6765 7374 2065 6469 7473 2061   suggest edits a
+000023c0: 6e64 2072 6570 6f72 7420 6275 6773 206f  nd report bugs o
+000023d0: 7220 6f74 6865 7220 6973 7375 6573 2e0a  r other issues..
+000023e0: 0a                                       .
```

### Comparing `electricpy-0.2.2/electricpy/__init__.py` & `electricpy-0.3.0/electricpy/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -8,37 +8,29 @@
 provide a wide array of capabilities to any electrical engineer.
 
 Built to support operations similar to Numpy and Scipy, this package is designed
 to aid in scientific calculations.
 """
 ################################################################################
 
-# Define Module Specific Variables
-_name_ = "electricpy"
-_version_ = "0.2.2"
-__version__ = _version_  # Alias Version for User Ease
-
-# Version Breakdown:
-# MAJOR CHANGE . MINOR CHANGE . MICRO CHANGE
-
-# Import Submodules
-from .constants import *
-from .phasor import compose, parallelz
-from .phasor import phasorz as impedance
 
-# Import Supporting Modules
-import numpy as _np
-import matplotlib.pyplot as _plt
 import cmath as _c
-from scipy.optimize import fsolve as _fsolve
-from warnings import showwarning as _showwarning
 from inspect import getframeinfo as _getframeinfo
 from inspect import stack as _stack
+from warnings import showwarning as _showwarning
+
+import matplotlib.pyplot as _plt
+import numpy as _np
 from scipy.integrate import quad as integrate
 
+from .version import NAME, VERSION
+from .constants import *
+from .phasors import phasor, parallelz
+
+__version__ = VERSION
 
 # Define Cycle Time Function
 def tcycle(ncycles=1, freq=60):
     r"""
     Time of Electrical Cycles.
 
     Evaluates the time for a number of n
@@ -53,28 +45,50 @@
     freq:       float, optional
                 System frequency in Hz, default=60
 
     Returns
     -------
     t:          float
                 Total time for *ncycles*
+
+    Examples
+    --------
+    >>> import electricpy as ep
+    >>> ep.tcycle(1, freq=60) #Value of ncycles=1 & freq=60
+    0.016666666666666666
+    >>> ep.tcycle(1, freq=50) #Value of ncycles=1 & freq=50
+    0.02
     """
     # Condition Inputs
+    if isinstance(ncycles, _np.ndarray) and isinstance(freq, _np.ndarray):
+        if ncycles.shape != freq.shape:
+            raise ValueError("ncycles and freq must be the same shape")
+
+    elif isinstance(ncycles, list) and isinstance(freq, list):
+        if len(ncycles) != len(freq):
+            raise ValueError("ncycles and freq must be the same length")
+
     ncycles = _np.asarray(ncycles)
     freq = _np.asarray(freq)
+    if 0 in freq:
+        raise ZeroDivisionError("Frequency must not be 0")
+    if not (freq > 0).all():
+        # frequency must be postive value
+        raise ValueError("Frequency must be postive value")
     # Evaluate the time for ncycles
     time = ncycles / freq
     # Return
-    if len(time) == 1:
-        return (time[0])
+    if isinstance(time, _np.ndarray) and len(time) == 1:
+        return time[0]
     else:
-        return (time)
-
+        return time
 
 # Define Reactance Calculator
+
+
 def reactance(z, freq=60, sensetivity=1e-12):
     r"""
     Capacitance/Inductance from Impedance.
 
     Calculates the Capacitance or Inductance in Farads or Henreys
     (respectively) provided the impedance of an element.
     Will return capacitance (in Farads) if ohmic impedance is
@@ -109,41 +123,47 @@
                     The Frequency Base for Provided Impedance, default=60
     sensetivity:    float, optional
                     The sensetivity used to check if a resistance was
                     provided, default=1e-12
 
     Returns
     -------
-    out:            float
-                    Capacitance or Inductance of Impedance
+    float:          Capacitance or Inductance of Impedance
+
+    Examples
+    --------
+    >>> import electricpy as ep
+    >>> ep.reactance(z=5) # ohms - inductive impedance
+    0.0132629...
     """
     # Evaluate Omega
     w = 2 * _np.pi * freq
     # Input is Complex
     if isinstance(z, complex):
         # Test for Resistance
-        if (abs(z.real) > sensetivity):
+        if abs(z.real) > sensetivity:
             R = z.real
         else:
             R = 0
-        if (z.imag > 0):
+        if z.imag > 0:
             out = z / (w * 1j)
         else:
             out = 1 / (w * 1j * z)
         out = abs(out)
         # Combine with resistance if present
-        if (R != 0): out = (R, out)
+        if R != 0:
+            out = (R, out)
     else:
-        if (z > 0):
-            out = z / (w)
+        if z > 0:
+            out = z / w
         else:
             out = 1 / (w * z)
         out = abs(out)
     # Return Output
-    return (out)
+    return out
 
 
 # Define display function
 def cprint(val, unit=None, label=None, title=None,
            pretty=True, printval=True, ret=False, decimals=3, round=3):
     """
     Phasor (Complex) Printing Function.
@@ -192,33 +212,35 @@
     numarr:     numpy.ndarray
                 The array of values corresponding to the magnitude and angle,
                 values are returned in the form: [[ mag, ang ],...,[ mag, ang ]]
                 where the angles are evaluated in degrees.
 
     Examples
     --------
+    >>> import numpy as np
     >>> import electricpy as ep
-    >>> v = ep.phasor(67, 120)
+    >>> from electricpy import phasors
+    >>> v = phasor(67, 120)
     >>> ep.cprint(v)
     67.0 ∠ 120.0°
     >>> voltages = np.array([[67,0],
-                             [67,-120],
-                             [67,120]])
-    >>> Vset = ep.phasorlist( voltages )
+    ...                      [67,-120],
+    ...                      [67,120]])
+    >>> Vset = ep.phasors.phasorlist( voltages )
     >>> ep.cprint(Vset)
-    [['67.0 ∠ 0.0°']
-    ['67.0 ∠ -120.0°']
-    ['67.0 ∠ 120.0°']]
+    67.0 ∠ 0.0°
+    67.0 ∠ -120.0°
+    67.0 ∠ 120.0°
 
 
     See Also
     --------
-    electricpy.phasor.phasor:       Phasor Generating Function
-    electricpy.phasor.phasorlist:   Phasor Generating Function for Lists/Arrays
-    electricpy.phasor.phasorz:      Impedance Phasor Generator
+    electricpy.phasors.phasor:       Phasor Generating Function
+    electricpy.phasors.phasorlist:   Phasor Generating Function for Lists/Arrays
+    electricpy.phasors.phasorz:      Impedance Phasor Generator
     """
     # Use depricated `round`
     if round != 3:
         decimals = round
         caller = _getframeinfo(_stack()[1][0])
         # Demonstrate Deprecation Warning
         _showwarning('`round` argument will be deprecated in favor of `decimals`',
@@ -227,15 +249,15 @@
     if isinstance(val, list):
         val = _np.asarray(val)  # Ensure that input is array
     # Find length of the input array
     if isinstance(val, _np.ndarray):
         shp = val.shape
         try:
             row, col = shp  # Interpret Shape of Object
-        except:
+        except (ValueError, IndexError):
             row = shp[0]
             col = 1
         sz = val.size
         # Handle Label as a List or Array
         if isinstance(label, (list, _np.ndarray)):
             if len(label) == 1:
                 tmp = label
@@ -245,15 +267,15 @@
                 raise ValueError("Too Few Label Arguments")
         # Handle Label as String
         elif isinstance(label, str):
             tmp = label
             for _ in range(sz):
                 label = _np.append(label, [tmp])
         # Handle Lack of Label
-        elif label == None:
+        elif label is None:
             label = _np.array([])
             for _ in range(sz):
                 label = _np.append(label, None)
         # Handle all Other Cases
         else:
             raise ValueError("Invalid Label")
         # Handle Unit as a List or Array
@@ -266,15 +288,15 @@
                 raise ValueError("Too Few Unit Arguments")
         # Handle Unit as String
         elif isinstance(unit, str):
             tmp = unit
             for _ in range(sz):
                 unit = _np.append(unit, [tmp])
         # Handle Lack of Unit
-        elif unit == None:
+        elif unit is None:
             unit = _np.array([])
             for _ in range(sz):
                 unit = _np.append(unit, None)
         # Handle all Other Cases
         else:
             raise ValueError("Invalid Unit")
         # Generate Default Arrays
@@ -286,66 +308,66 @@
             _label = label[i]
             _unit = unit[i]
             mag, ang_r = _c.polar(_val)  # Convert to polar form
             ang = _np.degrees(ang_r)  # Convert to degrees
             mag = _np.around(mag, decimals)  # Round
             ang = _np.around(ang, decimals)  # Round
             strg = ""
-            if _label != None:
+            if _label is not None:
                 strg += _label + " "
             strg += str(mag) + " ∠ " + str(ang) + "°"
-            if _unit != None:
+            if _unit is not None:
                 strg += " " + _unit
             printarr = _np.append(printarr, strg)
             numarr = _np.append(numarr, [mag, ang])
         # Reshape Arrays
         printarr = _np.reshape(printarr, (row, col))
         numarr = _np.reshape(numarr, (sz, 2))
         # Print
         if printval and row == 1:
-            if title != None:
+            if title is not None:
                 print(title)
             print(strg)
         elif printval and pretty:
             strg = ''
             start = True
             for i in printarr:
                 if not start:
                     strg += '\n'
                 strg += str(i[0])
                 start = False
-            if title != None:
+            if title is not None:
                 print(title)
             print(strg)
         elif printval:
-            if title != None:
+            if title is not None:
                 print(title)
             print(printarr)
         # Return if Necessary
         if ret:
             return (numarr)
     elif isinstance(val, (int, float, complex)):
         # Handle Invalid Unit/Label
-        if unit != None and not isinstance(unit, str):
+        if unit is not None and not isinstance(unit, str):
             raise ValueError("Invalid Unit Type for Value")
-        if label != None and not isinstance(label, str):
+        if label is not None and not isinstance(label, str):
             raise ValueError("Invalid Label Type for Value")
         mag, ang_r = _c.polar(val)  # Convert to polar form
         ang = _np.degrees(ang_r)  # Convert to degrees
         mag = _np.around(mag, decimals)  # Round
         ang = _np.around(ang, decimals)  # Round
         strg = ""
-        if label != None:
+        if label is not None:
             strg += label + " "
         strg += str(mag) + " ∠ " + str(ang) + "°"
-        if unit != None:
+        if unit is not None:
             strg += " " + unit
         # Print values (by default)
         if printval:
-            if title != None:
+            if title is not None:
                 print(title)
             print(strg)
         # Return values when requested
         if ret:
             return ([mag, ang])
     else:
         raise ValueError("Invalid Input Type")
@@ -391,18 +413,24 @@
                 The Phase-Current; default=None
     realonly:   bool, optional
                 Replacement of `complex` argument. Control to return
                 value in complex form; default=None
     complex:    bool, optional, DEPRECATED
                 Control to return value in complex form, refer to
                 `realonly` instead. default=None
+
+    Examples
+    --------
+    >>> import electricpy as ep
+    >>> ep.cprint(ep.phaseline(VLL=(13.8*ep.k))) # 13.8kV
+    7967.434 ∠ -30.0°
     """
     # Monitor for deprecated input
     if 'complex' in kwargs.keys():
-        if realonly == None:
+        if realonly is None:
             realonly = not kwargs['complex']
         caller = _getframeinfo(_stack()[1][0])
         # Demonstrate Deprecation Warning
         _showwarning('`complex` argument will be deprecated in favor of `realonly`',
                      DeprecationWarning, caller.filename, caller.lineno)
     output = 0
     # Given VLL, convert to VLN
@@ -424,18 +452,18 @@
     # None given, error encountered
     else:
         print("ERROR: No value given" +
               "or innapropriate value" +
               "given.")
         return (0)
     # Auto-detect Complex Values
-    if isinstance(output, complex) and realonly == None:
+    if isinstance(output, complex) and realonly is None:
         realonly = False
     # Return as complex only when requested
-    if realonly == True:
+    if realonly:
         return abs(output)
     return output
 
 
 # Define Power Set Function
 def powerset(P=None, Q=None, S=None, PF=None, find=''):
     """
@@ -470,56 +498,65 @@
             Calculated Real Power Magnitude
     Q:      float
             Calculated Reactive Power Magnitude
     S:      float
             Calculated Apparent Power Magnitude
     PF:     float
             Calculated Power Factor
+
+    Examples
+    --------
+    >>> import electricpy as ep
+    >>> ep.powerset(P=400, Q=300)
+    (400, 300, 500.0, 0.8)
+    >>> ep.powerset(P=400, Q=300, find="PF")
+    0.8
     """
     # Given P and Q
-    if (P != None) and (Q != None):
+    if (P is not None) and (Q is not None):
         S = _np.sqrt(P ** 2 + Q ** 2)
         PF = P / S
         if Q < 0:
             PF = -PF
     # Given S and PF
-    elif (S != None) and (PF != None):
+    elif (S is not None) and (PF is not None):
         P = abs(S * PF)
         Q = _np.sqrt(S ** 2 - P ** 2)
         if PF < 0:
             Q = -Q
     # Given P and PF
-    elif (P != None) and (PF != None):
+    elif (P is not None) and (PF is not None):
         S = P / PF
         Q = _np.sqrt(S ** 2 - P ** 2)
         if PF < 0:
             Q = -Q
     # Given P and S
-    elif (P != None) and (S != None):
+    elif (P is not None) and (S is not None):
         Q = _np.sqrt(S ** 2 - P ** 2)
         PF = P / S
     # Given Q and S
-    elif (Q != None) and (S != None):
+    elif (Q is not None) and (S is not None):
         P = _np.sqrt(S ** 2 - Q ** 2)
         PF = P / S
     else:
         raise ValueError("ERROR: Invalid Parameters or too few" +
                          " parameters given to calculate.")
     # Return
     find = find.upper()
     if find == 'P':
-        return (P)
+        return P
     elif find == 'Q':
-        return (Q)
+        return Q
     elif find == 'S':
-        return (S)
+        return S
     elif find == 'PF':
-        return (PF)
+        return PF
     else:
-        return (P, Q, S, PF)
+        return P, Q, S, PF
+
 
 def slew_rate(V=None, freq=None, SR=None, find=''):
     """
     Slew Rate Calculator.
 
     This function is designed to calculate slew rate
     i.e the change of voltage per unit of time`
@@ -541,228 +578,85 @@
     V:      float
             Calculated Volatage
     freq:   float
             Calculated frequency
     SR:     float
             Calculated slew rate
     """
-    if V!=None and freq!=None:
-        SR = 2*_np.pi*V*freq
-    elif freq!=None and SR!=None:
-        V = SR/(2*_np.pi*freq)
-    elif V!=None and SR!=None:
-        freq = SR/(2*_np.pi*V)
+    if V is not None and freq is not None:
+        SR = 2 * _np.pi * V * freq
+    elif freq is not None and SR is not None:
+        V = SR / (2 * _np.pi * freq)
+    elif V is not None and SR is not None:
+        freq = SR / (2 * _np.pi * V)
     else:
         raise ValueError("ERROR: Invalid Parameters or too few" +
-                        " parameters given to calculate.")
+                         " parameters given to calculate.")
     if find == 'V':
-        return (V)
+        return V
     elif find == 'freq':
-        return (freq)
+        return freq
     elif find == 'SR':
-        return (SR)
-    else:
-        return (V, freq, SR)
-
-# Define Power Triangle Function
-def powertriangle(P=None, Q=None, S=None, PF=None, color="red",
-                  text="Power Triangle", printval=False):
-    """
-    Power Triangle Plotting Function.
-
-    This function is designed to draw a power triangle given
-    values for the complex power system.
-
-    .. image:: /static/PowerTriangle.png
-
-    Parameters
-    ----------
-    P:          float
-                Real Power, unitless, default=None
-    Q:          float
-                Reactive Power, unitless, default=None
-    S:          float
-                Apparent Power, unitless, default=None
-    PF:         float
-                Power Factor, unitless, provided as a decimal value, lagging is
-                positive, leading is negative; default=None
-    color:      string, optional
-                The color of the power triangle lines, default="red"
-    text:       string, optional
-                The title of the power triangle plot, default="Power Triangle"
-    printval:   bool, optional
-                Control argument to allow the numeric values to be printed on
-                the plot, default="False"
-    
-    Returns
-    -------
-    matplotlib.pyplot:  Plotting object to be used for additional configuration
-                        or plotting.
-    """
-    # Calculate all values if not all are provided
-    if (P == None or Q == None or S == None or PF == None):
-        P, Q, S, PF = powerset(P, Q, S, PF)
-
-    # Generate Lines
-    Plnx = [0, P]
-    Plny = [0, 0]
-    Qlnx = [P, P]
-    Qlny = [0, Q]
-    Slnx = [0, P]
-    Slny = [0, Q]
-
-    # Plot Power Triangle
-    _plt.figure(1)
-    _plt.title(text)
-    _plt.plot(Plnx, Plny, color=color)
-    _plt.plot(Qlnx, Qlny, color=color)
-    _plt.plot(Slnx, Slny, color=color)
-    _plt.xlabel("Real Power (W)")
-    _plt.ylabel("Reactive Power (VAR)")
-    mx = max(abs(P), abs(Q))
-
-    if P > 0:
-        _plt.xlim(0, mx * 1.1)
-        x = mx
-    else:
-        _plt.xlim(-mx * 1.1, 0)
-        x = -mx
-    if Q > 0:
-        _plt.ylim(0, mx * 1.1)
-        y = mx
-    else:
-        _plt.ylim(-mx * 1.1, 0)
-        y = -mx
-    if PF > 0:
-        PFtext = " Lagging"
+        return SR
     else:
-        PFtext = " Leading"
-    text = "P:   " + str(P) + " W\n"
-    text = text + "Q:   " + str(Q) + " VAR\n"
-    text = text + "S:   " + str(S) + " VA\n"
-    text = text + "PF:  " + str(abs(PF)) + PFtext + "\n"
-    text = text + "ΘPF: " + str(_np.degrees(_np.arccos(PF))) + "°" + PFtext
-    # Print all values if asked to
-    if printval:
-        _plt.text(x / 20, y * 4 / 5, text, color=color)
-    return _plt
-
-
-# Define Transformer Short-Circuit/Open-Circuit Function
-def transformertest(Poc=False, Voc=False, Ioc=False, Psc=False, Vsc=False,
-                    Isc=False):
-    """
-    Electrical Transformer Rated Test Evaluator.
-
-    This function will determine the non-ideal circuit components of
-    a transformer (Req and Xeq, or Rc and Xm) given the test-case
-    parameters for the open-circuit test and/or the closed-circuit
-    test. Requires one or both of two sets: { Poc, Voc, Ioc }, or
-    { Psc, Vsc, Isc }.
-    All values given must be given as absolute value, not complex.
-    All values returned are given with respect to primary.
-
-    Parameters
-    ----------
-    Poc:    float, optional
-            The open-circuit measured power (real power), default=None
-    Voc:    float, optional
-            The open-circuit measured voltage (measured on X),
-            default=None
-    Ioc:    float, optional
-            The open-circuit measured current (measured on primary),
-            default=None
-    Psc:    float, optional
-            The short-circuit measured power (real power), default=None
-    Vsc:    float, optional
-            The short-circuit measured voltage (measured on X),
-            default=None
-    Isc:    float, optional
-            The short-circuit measured current (measured on X),
-            default=None
-
-    Returns
-    -------
-    {Req,Xeq,Rc,Xm}:    Given all optional args
-    {Rc, Xm}:           Given open-circuit parameters
-    {Req, Xeq}:         Given short-circuit parameters
-    """
-    SC = False
-    OC = False
-    # Given Open-Circuit Values
-    if (Poc != None) and (Voc != None) and (Ioc != None):
-        PF = Poc / (Voc * Ioc)
-        Y = _c.rect(Ioc / Voc, -_np.arccos(PF))
-        Rc = 1 / Y.real
-        Xm = -1 / Y.imag
-        OC = True
-    # Given Short-Circuit Values
-    if (Psc != None) and (Vsc != None) and (Isc != None):
-        PF = Psc / (Vsc * Isc)
-        Zeq = _c.rect(Vsc / Isc, _np.arccos(PF))
-        Req = Zeq.real
-        Xeq = Zeq.imag
-        SC = True
-    # Return All if Found
-    if OC and SC:
-        return (Req, Xeq, Rc, Xm)
-    elif OC:
-        return (Rc, Xm)
-    elif SC:
-        return (Req, Xeq)
-    else:
-        print("An Error Was Encountered.\n" +
-              "Not enough arguments were provided.")
+        return V, freq, SR
 
 
 # Define Non-Linear Power Factor Calculator
-def nlinpf(PFtrue=False, PFdist=False, PFdisp=False):
+def non_linear_pf(PFtrue=False, PFdist=False, PFdisp=False):
     """
     Non-Linear Power Factor Evaluator.
 
     This function is designed to evaluate one of three unknowns
     given the other two. These particular unknowns are the arguments
     and as such, they are described in the representative sections
     below.
 
+    .. note:: Also available as `nlinpf`.
+
     Parameters
     ----------
     PFtrue:     float, exclusive
                 The "True" power-factor, default=None
     PFdist:     float, exclusive
                 The "Distorted" power-factor, default=None
     PFdisp:     float, exclusive
                 The "Displacement" power-factor, default=None
 
     Returns
     -------
     float:  This function will return the unknown variable from the previously
             described set of variables.
     """
-    if (PFtrue != None and PFdist != None and PFdisp != None):
+    if PFtrue is not None and PFdist is not None and PFdisp is not None:
         raise ValueError("ERROR: Too many constraints, no solution.")
-    elif (PFdist != None and PFdisp != None):
-        return (PFdist * PFdisp)
-    elif (PFtrue != None and PFdisp != None):
-        return (PFtrue / PFdisp)
-    elif (PFtrue != None and PFdist != None):
-        return (PFtrue / PFdist)
-    else:
-        raise ValueError("ERROR: Function requires at least two arguments.")
+    if PFdist is not None and PFdisp is not None:
+        return PFdist * PFdisp
+    if PFtrue is not None and PFdisp is not None:
+        return PFtrue / PFdisp
+    if PFtrue is not None and PFdist is not None:
+        return PFtrue / PFdist
+    raise ValueError("ERROR: Function requires at least two arguments.")
+
+
+# Alias to original Name
+nlinpf = non_linear_pf
 
 
 # Define Short-Circuit RL Current Calculator
-def iscrl(V, Z, t=None, f=None, mxcurrent=True, alpha=None):
+def short_circuit_current(V, Z, t=None, f=None, mxcurrent=True, alpha=None):
     """
     Short-Circuit-Current (ISC) Calculator.
 
     The Isc-RL function (Short Circuit Current for RL Circuit)
     is designed to calculate the short-circuit current for an
     RL circuit.
 
+    .. note:: Also available as `iscrl`.
+
     Parameters
     ----------
     V:          float
                 The absolute magnitude of the voltage.
     Z:          float
                 The complex value of the impedance. (R + jX)
     t:          float, optional
@@ -784,62 +678,67 @@
     Opt 2 - (i, iAC, iDC, T):   The Instantaneous current with
                                 maximum DC offset, the instantaneous
                                 AC current, the instantaneous DC
                                 current, and the time-constant T.
     Opt 3 - (Iac):              The RMS current without DC offset.
     """
     # Calculate omega, theta, R, and X
-    if (f != None):
+    if f is not None:
         omega = 2 * _np.pi * f
     else:
         omega = None
     R = abs(Z.real)
     X = abs(Z.imag)
     theta = _np.arctan(X / R)
 
     # If Maximum Current is Desired and No alpha provided
-    if (mxcurrent and alpha == None):
+    if mxcurrent and alpha is None:
         alpha = theta - _np.pi / 2
-    elif (mxcurrent and alpha != None):
+    elif mxcurrent and alpha is not None:
         raise ValueError("ERROR: Inappropriate Arguments Provided.\n" +
                          "Not both mxcurrent and alpha can be provided.")
 
-    # Calculate Asymmetrical (total) Current if t != None
-    if (t != None and f != None):
+    # Calculate Asymmetrical (total) Current if t is not None
+    if t is not None and f is not None:
         # Calculate RMS if none of the angular values are provided
-        if (alpha == None and omega == None):
+        if alpha is None and omega is None:
             # Calculate tau
             tau = t / (1 / 60)
             K = _np.sqrt(1 + 2 * _np.exp(-4 * _np.pi * tau / (X / R)))
             IAC = abs(V / Z)
             Irms = K * IAC
             # Return Values
-            return (Irms, IAC, K)
-        elif (alpha == None or omega == None):
+            return Irms, IAC, K
+        elif alpha is None or omega is None:
             raise ValueError("ERROR: Inappropriate Arguments Provided.")
         # Calculate Instantaneous if all angular values provided
         else:
             # Convert Degrees to Radians
             omega = _np.radians(omega)
             alpha = _np.radians(alpha)
             theta = _np.radians(theta)
             # Calculate T
             T = X / (2 * _np.pi * f * R)  # seconds
             # Calculate iAC and iDC
             iAC = _np.sqrt(2) * V / Z * _np.sin(omega * t + alpha - theta)
-            iDC = -_np.sqrt(2) * V / Z * _np.sin(alpha - theta) * _np.exp(-t / T)
+            iDC = -_np.sqrt(2) * V / Z * \
+                _np.sin(alpha - theta) * _np.exp(-t / T)
             i = iAC + iDC
             # Return Values
-            return (i, iAC, iDC, T)
-    elif ((t != None and f == None) or (t == None and f != None)):
+            return i, iAC, iDC, T
+    elif (t is not None and f is None) or (t is None and f is not None):
         raise ValueError("ERROR: Inappropriate Arguments Provided.\n" +
                          "Must provide both t and f or neither.")
     else:
         Iac = abs(V / Z)
-        return (Iac)
+        return Iac
+
+
+# Alias to original Name
+iscrl = short_circuit_current
 
 
 # Define Voltage Divider Calculator
 def voltdiv(Vin, R1, R2, Rload=None):
     r"""
     Electrical Voltage Divider Function.
 
@@ -865,22 +764,30 @@
     Rload:  float, optional
             The Load Resistor (or impedance), default=None
 
     Returns
     -------
     Vout:   float
             The Output voltage as measured across R2 and/or Rload
+
+    Examples
+    --------
+    >>> import electricpy as ep
+    >>> ep.voltdiv(Vin=12, R1=4, R2=8)
+    8.0
+    >>> ep.voltdiv(Vin=12, R1=6, R2=12, Rload=12) # R2 and Rload are parallel
+    6.0
     """
     # Determine whether Rload is given
-    if (Rload == None):  # No Load Given
+    if Rload is None:  # No Load Given
         Vout = Vin * R2 / (R1 + R2)
     else:  # Load was given
-        Rp = R2*Rload/(R2 + Rload)
+        Rp = R2 * Rload / (R2 + Rload)
         Vout = Vin * Rp / (R1 + Rp)
-    return (Vout)
+    return Vout
 
 
 # Define Current Divider Calculator
 def curdiv(Ri, Rset, Vin=None, Iin=None, Vout=False, combine=True):
     r"""
     Electrical Current Divider Function.
 
@@ -906,39 +813,49 @@
                 Control argument to force resistance combination. default=True
 
     Returns
     -------
     Opt1 - Ii:          The Current through the resistor (impedance) of interest
     Opt2 - (Ii,Vi):     The afore mentioned current, and voltage across the
                         resistor (impedance) of interest
+
+    Examples
+    --------
+    >>> from electricpy.constants import k
+    >>> import electricpy as ep
+    >>> ep.curdiv(Ri=1*k, Rset=(1*k, 1*k), Iin=12) # 12-amps, split three ways
+    4.0
+    >>> ep.curdiv(Ri=1*k, Rset=(1*k, 1*k), Iin=12, Vout=True) # Find Voltage
+    (4.0, 4000.0)
     """
     # Validate Tuple
     if not isinstance(Rset, tuple):
         Rset = (Rset,)  # Set as Tuple
     # Calculate The total impedance
     if combine:
         # Combine tuples, then calculate total resistance
         Rtot = parallelz(Rset + (Ri,))
     else:
         Rtot = parallelz(Rset)
     # Determine Whether Input was given as Voltage or Current
-    if (Vin != None and Iin == None):  # Vin Provided
+    if Vin is not None and Iin is None:  # Vin Provided
         Iin = Vin / Rtot  # Calculate total current
         Ii = Iin * Rtot / Ri  # Calculate the current of interest
-    elif (Vin == None and Iin != None):  # Iin provided
+    elif Vin is None and Iin is not None:  # Iin provided
         Ii = Iin * Rtot / Ri  # Calculate the current of interest
     else:
         raise ValueError("ERROR: Too many or too few constraints provided.")
-    if (Vout):  # Asked for voltage across resistor of interest
+    if Vout:  # Asked for voltage across resistor of interest
         Vi = Ii * Ri
-        return (Ii, Vi)
+        return Ii, Vi
     else:
-        return (Ii)
+        return Ii
+
 
-#Induction Machine Slip
+# Induction Machine Slip
 def induction_machine_slip(Nr, freq=60, poles=4):
     r"""
     Induction Machine slip calculator.
 
     This function is used to calculate the slip of an induction machine.
 
     .. math:: slip = 1 - \frac{Nr}{120*frac{freq}{poles}}
@@ -949,19 +866,20 @@
     freq: int, Supply AC frequency, default=60
     poles: Number of poles inside Induction Machine, default=4
 
     Returns
     -------
     slip: float, Induction Machine forward Slip
     """
-    Ns = (120*freq)/poles
-    return (Ns - Nr)/(Ns)
+    Ns = (120 * freq) / poles
+    return (Ns - Nr) / (Ns)
+
 
 # Define Function to Evaluate Resistance Needed for LED
-def led_resistor(Vsrc, Vfwd = 2, Ifwd = 20):
+def led_resistor(Vsrc, Vfwd=2, Ifwd=20):
     r"""
     LED Resistor Calculator.
 
     This function will evaluate the necessary resistance value for a simple LED
     circuit with a voltage source, resistor, and LED.
 
     .. math:: R_\text{LED} = \frac{V_\text{SRC} - V_\text{FWD}}{I_\text{FWD}}
@@ -970,15 +888,15 @@
     ----------
     Vsrc:   float
             Source voltage, as measured across both LED and resistor in circuit.
     Vfwd:   float, optional
             Forward voltage of LED (or series LEDs if available), default=2
     Ifwd:   float, optional
             Forward current of LEDs in milliamps, default=20 (milliamps)
-    
+
     Returns
     -------
     R:      float
             The resistance value most appropriate for the LED circuit.
     """
     # Calculate and Return!
     R = (Vsrc - Vfwd) / (Ifwd * 1000)
@@ -1004,22 +922,21 @@
     t:      float
             Time at which to evaluate
     freq:   float, optional
             System frequency (in Hz), default=60
 
     Returns
     -------
-    Pinst:  float
-            Instantaneous Power at time t
+    float:  Instantaneous Power at time t.
     """
     # Evaluate omega
     w = 2 * _np.pi * freq
     # Calculate
     Pinst = P + P * _np.cos(2 * w * t) - Q * _np.sin(2 * w * t)
-    return (Pinst)
+    return Pinst
 
 
 # Define Delta-Wye Impedance Network Calculator
 def dynetz(delta=None, wye=None, round=None):
     r"""
     Delta-Wye Impedance Converter.
 
@@ -1051,55 +968,58 @@
     Returns
     -------
     delta-set:  tuple of float
                 Delta-Connected impedance values { Z12, Z23, Z31 }
     wye-set:    tuple of float
                 Wye-Connected impedance values { Z1, Z2, Z3 }
     """
+    if delta is None and wye is None:
+        raise ValueError(
+            "ERROR: Either delta or wye impedances must be specified."
+        )
     # Determine which set of impedances was provided
-    if (delta != None and wye == None):
+    if delta is not None and wye is None:
         Z12, Z23, Z31 = delta  # Gather particular impedances
         Zsum = Z12 + Z23 + Z31  # Find Sum
         # Calculate Wye Impedances
         Z1 = Z12 * Z31 / Zsum
         Z2 = Z12 * Z23 / Zsum
         Z3 = Z23 * Z31 / Zsum
         Zset = (Z1, Z2, Z3)
-        if round != None: Zset = _np.around(Zset, round)
-        return (Zset)  # Return Wye Impedances
-    elif (delta == None and wye != None):
+        if round is not None:
+            Zset = _np.around(Zset, round)
+        return Zset  # Return Wye Impedances
+    if delta is None and wye is not None:
         Z1, Z2, Z3 = wye  # Gather particular impedances
         Zmultsum = Z1 * Z2 + Z2 * Z3 + Z3 * Z1
         Z23 = Zmultsum / Z1
         Z31 = Zmultsum / Z2
         Z12 = Zmultsum / Z3
         Zset = (Z12, Z23, Z31)
-        if round != None: Zset = _np.around(Zset, round)
-        return (Zset)  # Return Delta Impedances
-    else:
-        raise ValueError(
-            "ERROR: Either delta or wye impedances must be specified."
-        )
+        if round is not None:
+            Zset = _np.around(Zset, round)
+        return Zset  # Return Delta Impedances
+
 
-#calculating impedance of bridge network
+# calculating impedance of bridge network
 def bridge_impedance(z1, z2, z3, z4, z5):
     r"""
     Bridge Impedance Calculator.
-    
+
     The following condition describing the Wheatstone Bridge is utilized to
     ensure that current through `z5` will be zero.
 
     .. math:: z1 \cdot z3 = z2 \cdot z4
-    
+
     .. image:: /static/WheatstoneBridgeCircuit.png
-    
+
     Parameters
     ----------
     z1:     [float, complex]
-            Bridge impedance 1
+            Bridge impedance 1iscrl
     z2:     [float, complex]
             Bridge impedance 2
     z3:     [float, complex]
             Bridge impedance 3
     z4:     [float, complex]
             Bridge impedance 4
     z5:     [float, complex]
@@ -1108,19 +1028,18 @@
     Returns
     -------
     effective bridge impedance
 
     """
     if z1 * z3 == z2 * z4:
         return (z1 + z2) * (z3 + z4) / (z1 + z2 + z3 + z4)
-    else:
-        za, zb, zc = dynetz(delta = (z1, z5, z4))
-        ze1 = zb + z2
-        ze2 = zc + z3
-        return za + (ze1*ze2)/(ze1+ze2)
+    za, zb, zc = dynetz(delta=(z1, z5, z4))
+    ze1 = zb + z2
+    ze2 = zc + z3
+    return za + (ze1 * ze2) / (ze1 + ze2)
 
 
 # Define Single Line Power Flow Calculator
 def powerflow(Vsend, Vrec, Xline):
     r"""
     Approximated Power-Flow Calculator.
 
@@ -1152,16 +1071,16 @@
     """
     # Evaluate the Input Terms
     Vs = abs(Vsend)
     ds = _c.phase(Vsend)
     Vr = abs(Vrec)
     dr = _c.phase(Vrec)
     # Calculate Power Flow
-    pflow = (Vs * Vr) / (Xline) * _np.sin(ds - dr)
-    return (pflow)
+    pflow = (Vs * Vr) / Xline * _np.sin(ds - dr)
+    return pflow
 
 
 # Define Impedance From Power and X/R
 def zsource(S, V, XoR, Sbase=None, Vbase=None, perunit=True):
     """
     Source Impedance Calculator.
 
@@ -1196,41 +1115,41 @@
     -------
     Zsource_pu: complex
                 The per-unit evaluation of the source impedance.
                 Will be returned in ohmic (not per-unit) value if
                 *perunit* argument is specified as False.
     """
     # Force Sbase and Vbase if needed
-    if Vbase == None:
+    if Vbase is None:
         Vbase = V
-    if Sbase == None:
+    if Sbase is None:
         Sbase = S
     # Prevent scaling if per-unit already applied
-    if Vbase == True:
+    if Vbase:
         Vbase = 1
-    if Sbase == True:
+    if Sbase:
         Sbase = 1
     # Set to per-unit
     Spu = S / Sbase
     Vpu = V / Vbase
     # Evaluate Zsource Magnitude
     Zsource_pu = Vpu ** 2 / Spu
     # Evaluate the angle
     nu = _np.degrees(_np.arctan(XoR))
     # Conditionally Evaluate Phasor Impedance
     if isinstance(nu, (list, _np.ndarray)):
         Zsource_pu = []
         for angle in nu:
-            Zsource_pu.append(phasor(Zsource_pu, angle))
+            Zsource_pu.append(phasors(Zsource_pu, angle))
     else:
-        Zsource_pu = phasor(Zsource_pu, nu)
+        Zsource_pu = phasors(Zsource_pu, nu)
     if not perunit:
         Zsource = Zsource_pu * Vbase ** 2 / Sbase
-        return (Zsource)
-    return (Zsource_pu)
+        return Zsource
+    return Zsource_pu
 
 
 # Define Impedance Decomposer
 def zdecompose(Zmag, XoR):
     """
     Impedance Decomposition Function.
 
@@ -1256,15 +1175,15 @@
                 The reactance (in ohms)
     """
     # Evaluate Resistance
     R = Zmag / _np.sqrt(XoR ** 2 + 1)
     # Evaluate Reactance
     X = R * XoR
     # Return
-    return (R, X)
+    return R, X
 
 
 # Define Power Reactance Calculator
 def powerimpedance(S, V, PF=None, parallel=False, terms=False):
     r"""
     Impedance from Apparent Power Formula.
 
@@ -1320,261 +1239,38 @@
                 The ohmic reactance required to consume the
                 specified apparent power (S) at the rated
                 voltage (V).
     """
     # Condition Inputs
     V = abs(V)
     # Test for Parallel Component Option and Evaluate
-    if isinstance(S, complex) or PF != None:
-        if PF != None:
+    if isinstance(S, complex) or PF is not None:
+        if PF is not None:
             # Evaluate Elements
             P, Q, S, PF = powerset(S=S, PF=PF)
         else:
             P = S.real
             Q = S.imag
         # Compute Elements
         if parallel:
-            Zp = V ** 2 / (3 * (P + 1j*Q))
+            Zp = V ** 2 / (3 * (P + 1j * Q))
         else:
-            Zp = V ** 2 / (P + 1j*Q)
+            Zp = V ** 2 / (P + 1j * Q)
         Z = _np.conjugate(Zp)
         R = Z.real
         X = Z.imag
         # Conditionally Return as Impedance
         if terms:
             return (R, X)
         return Z
     # Not Complex (just R)
     R = V ** 2 / S
     return R
 
 
-# Define Cold-Junction-Voltage Calculator
-def coldjunction(Tcj, coupletype="K", To=None, Vo=None, P1=None, P2=None,
-                 P3=None, P4=None, Q1=None, Q2=None, round=None):
-    """
-    Thermocouple Cold-Junction Formula.
-
-    Function to calculate the expected cold-junction-voltage given
-    the temperature at the cold-junction.
-
-    Parameters
-    ----------
-    Tcj:        float
-                The temperature (in degrees C) that the junction is
-                currently subjected to.
-    coupletype: string, optional
-                Thermocouple Type, may be one of (B,E,J,K,N,R,S,T), default="K"
-    To:         float, optional
-                Temperature Constant used in Polynomial.
-    Vo:         float, optional
-                Voltage Constant used in Polynomial.
-    P1:         float, optional
-                Polynomial constant.
-    P2:         float, optional
-                Polynomial constant.
-    P3:         float, optional
-                Polynomial constant.
-    P4:         float, optional
-                Polynomial constant.
-    Q1:         float, optional
-                Polynomial constant.
-    Q2:         float, optional
-                Polynomial constant.
-    round:      int, optional
-                Control input to specify how many decimal places the result
-                should be rounded to, default=1.
-
-    Returns
-    -------
-    Vcj:        float
-                The calculated cold-junction-voltage in volts.
-    """
-    # Condition Inputs
-    coupletype = coupletype.upper()
-    # Validate Temperature Range
-    if coupletype == "B":
-        if not (0 < Tcj and Tcj < 70):
-            raise ValueError("Temperature out of range.")
-    else:
-        if not (-20 < Tcj and Tcj < 70):
-            raise ValueError("Temperature out of range.")
-    # Define Constant Lookup System
-    lookup = ["B", "E", "J", "K", "N", "R", "S", "T"]
-    if not (coupletype in lookup):
-        raise ValueError("Invalid Thermocouple Type")
-    index = lookup.index(coupletype)
-    # Define Constant Dictionary
-    # Load Data Into Terms
-    parameters = {}
-    for var in COLD_JUNCTION_DATA.keys():
-        parameters[var] = parameters.get(var, None) or COLD_JUNCTION_DATA[var][index]
-    To, Vo, P1, P2, P3, P4, Q1, Q2 = [parameters[key] for key in COLD_JUNCTION_KEYS]
-    # Define Formula Terms
-    tx = (Tcj - To)
-    num = tx * (P1 + tx * (P2 + tx * (P3 + P4 * tx)))
-    den = 1 + tx * (Q1 + Q2 * tx)
-    Vcj = Vo + num / den
-    # Round Value if Allowed
-    if round != None:
-        Vcj = _np.around(Vcj, round)
-    # Return in milivolts
-    return (Vcj * m)
-
-
-# Define Thermocouple Temperature Calculation
-def thermocouple(V, coupletype="K", fahrenheit=False, cjt=None, To=None,
-                 Vo=None, P1=None, P2=None, P3=None, P4=None, Q1=None, Q2=None,
-                 Q3=None, round=1):
-    """
-    Thermocouple Temperature Calculator.
-
-    Utilizes polynomial formula to calculate the temperature being monitored
-    by a thermocouple. Allows for various thermocouple types (B,E,J,K,N,R,S,T)
-    and various cold-junction-temperatures.
-
-    Parameters
-    ----------
-    V:          float
-                Measured voltage (in Volts)
-    coupletype: string, optional
-                Thermocouple Type, may be one of (B,E,J,K,N,R,S,T), default="K"
-    fahrenheit: bool, optional
-                Control to enable return value as Fahrenheit instead of Celsius,
-                default=False
-    cjt:        float, optional
-                Cold-Junction-Temperature
-    To:         float, optional
-                Temperature Constant used in Polynomial.
-    Vo:         float, optional
-                Voltage Constant used in Polynomial.
-    P1:         float, optional
-                Polynomial constant.
-    P2:         float, optional
-                Polynomial constant.
-    P3:         float, optional
-                Polynomial constant.
-    P4:         float, optional
-                Polynomial constant.
-    Q1:         float, optional
-                Polynomial constant.
-    Q2:         float, optional
-                Polynomial constant.
-    Q3:         float, optional
-                Polynomial constant.
-    round:      int, optional
-                Control input to specify how many decimal places the result
-                should be rounded to, default=1.
-
-    Returns
-    -------
-    T:          float
-                The temperature (by default in degrees C, but optionally in
-                degrees F) as computed by the function.
-    """
-    # Condition Inputs
-    coupletype = coupletype.upper()
-    V = V / m  # Scale volts to milivolts
-    # Determine Cold-Junction-Voltage
-    if cjt != None:
-        Vcj = coldjunction(cjt, coupletype, To, Vo, P1, P2, P3, P4, Q1, Q2, round)
-        V += Vcj / m
-    # Define Constant Lookup System
-    lookup = ["B", "E", "J", "K", "N", "R", "S", "T"]
-    if not (coupletype in lookup):
-        raise ValueError("Invalid Thermocouple Type")
-    # Determine Array Selection
-    vset = THERMO_COUPLE_VOLTAGES[coupletype]
-    if V < vset[0] * m:
-        raise ValueError("Voltage Below Lower Bound")
-    elif vset[0] <= V < vset[1]:
-        select = 0
-    elif vset[1] <= V < vset[2]:
-        select = 1
-    elif vset[2] <= V < vset[3]:
-        select = 2
-    elif vset[3] <= V < vset[4]:
-        select = 3
-    elif vset[4] <= V <= vset[5]:
-        select = 4
-    elif vset[5] < V:
-        raise ValueError("Voltage Above Upper Bound")
-    else:
-        raise ValueError("Internal Error!")
-    # Load Data Into Terms
-    parameters = {}
-    for i, key in enumerate(THERMO_COUPLE_KEYS):
-        parameters[key] = parameters.get(key, None) or THERMO_COUPLE_DATA[coupletype][i][select]
-    Vo, To, P1, P2, P3, P4, Q1, Q2, Q3 = [parameters[key] for key in THERMO_COUPLE_KEYS]
-    # Calculate Temperature in Degrees C
-    num = (V - Vo) * (P1 + (V - Vo) * (P2 + (V - Vo) * (P3 + P4 * (V - Vo))))
-    den = 1 + (V - Vo) * (Q1 + (V - Vo) * (Q2 + Q3 * (V - Vo)))
-    temp = To + num / den
-    # Return Temperature
-    if fahrenheit:
-        temp = (temp * 9 / 5) + 32
-    temp = _np.around(temp, round)
-    return (temp)
-
-
-# Define RTD Calculator
-def rtdtemp(RT, rtdtype="PT100", fahrenheit=False, Rref=None, Tref=None,
-            a=None, round=1):
-    """
-    RTD Temperature Calculator.
-
-    Evaluates the measured temperature based on the measured resistance
-    and the RTD type.
-
-    Parameters
-    ----------
-    RT:         float
-                The measured resistance (in ohms).
-    rtdtype:    string
-                RTD Type string, may be one of: (PT100, PT1000,
-                CU100, NI100, NI120, NIFE), default=PT100
-    fahrenheit: bool, optional
-                Control parameter to force return into degrees
-                fahrenheit, default=False
-    Rref:       float, optional
-                Resistance reference, commonly used if non-standard
-                RTD type being used. Specified in ohms.
-    Tref:       float, optional
-                Temperature reference, commonly used if non-standard
-                RTD type being used. Specified in degrees Celsius.
-    a:          float, optional
-                Scaling value, commonly used if non-standard
-                RTD type being used.
-    round:      int, optional
-                Control argument to specify number of decimal points
-                in returned value.
-
-    Returns
-    -------
-    temp:       float
-                Calculated temperature, defaults to degrees Celsius.
-    """
-    # Load Variables
-    if Rref == None:
-        Rref = RTD_TYPES[rtdtype][0]
-    if Tref == None:
-        Tref = 0
-    if a == None:
-        a = RTD_TYPES[rtdtype][1]
-    # Define Terms
-    num = RT - Rref + Rref * a * Tref
-    den = Rref * a
-    temp = num / den
-    # Return Temperature
-    if fahrenheit:
-        temp = (temp * 9 / 5) + 32
-    temp = _np.around(temp, round)
-    return (temp)
-
-
 # Define function to find VDC setpoint
 def vscdcbus(VLL, Zs, P, Q=0, mmax=0.8, debug=False):
     """
     Voltage Sourced Converter DC Bus Voltage Function.
 
     The purpose of this function is to calculate the
     required DC-bus voltage for a Voltage-Sourced-
@@ -1613,15 +1309,15 @@
     # Calculate the VDC value
     VDC = 2 * Vtpk / mmax
     if debug:
         print("Iload", Iload)
         print("Vtln", Vtln)
         print("Vtpk", Vtpk)
         print("VDC", VDC)
-    return (VDC)
+    return VDC
 
 
 # Define kp/ki/w0L calculating function
 def vscgains(Rs, Ls, tau=0.005, freq=60):
     """
     Voltage Sourced Converter Gains Calculator.
 
@@ -1650,78 +1346,15 @@
     """
     # Calculate kp
     kp = Ls / tau
     # Calculate ki
     ki = kp * Rs / Ls
     # Calculate w0L
     w0L = 2 * _np.pi * freq * Ls
-    return (kp, ki, w0L)
-
-
-# Define Convolution Bar-Graph Function:
-def convbar(h, x, outline=True):
-    """
-    Convolution Bar-Graph Plotter Function.
-
-    Generates plots of each of two input arrays as bar-graphs, then
-    generates a convolved bar-graph of the two inputs to demonstrate
-    and illustrate convolution, typically for an educational purpose.
-
-    Examples
-    --------
-    >>> import numpy as np
-    >>> import electricpy as ep
-    >>> h = np.array([0, 1, 1, 1, 0])
-    >>> x = np.array([0, 1, 1, 1, 0])
-    >>> ep.convbar(h, x)
-    
-    .. image:: /static/convbar-example.png
-
-    Parameters
-    ----------
-    h:      numpy.ndarray
-            Impulse Response - Given as Array (Prefferably Numpy Array)
-    x:      numpy.ndarray
-            Input Function - Given as Array (Prefferably Numpy Array)
-    """
-    # The impulse response
-    M = len(h)
-    t = _np.arange(M)
-    # Plot
-    _plt.subplot(121)
-    if (outline): _plt.plot(t, h, color='red')
-    _plt.bar(t, h, color='black')
-    _plt.xticks([0, 5, 9])
-    _plt.ylabel('h')
-    _plt.title('Impulse Response')
-    _plt.grid()
-
-    # The input function
-    N = len(x)
-    s = _np.arange(N)
-    # Plot
-    _plt.subplot(122)
-    if (outline): _plt.plot(s, x, color='red')
-    _plt.bar(s, x, color='black')
-    _plt.xticks([0, 10, 19])
-    _plt.title('Input Function')
-    _plt.grid()
-    _plt.ylabel('x')
-
-    # The output
-    L = M + N - 1
-    w = _np.arange(L)
-    _plt.figure(3)
-    y = _np.convolve(h, x)
-    if (outline): _plt.plot(w, y, color='red')
-    _plt.bar(w, y, color='black')
-    _plt.ylabel('y')
-    _plt.grid()
-    _plt.title('Convolved Output')
-    return _plt
+    return kp, ki, w0L
 
 
 # Define Peak Calculator
 def peak(val):
     r"""
     Sinusoid RMS to Peak Converter.
 
@@ -1733,15 +1366,15 @@
 
     Examples
     --------
     >>> import electricpy as ep
     >>> ep.peak(120)
     169.7056274847714
     """
-    return (_np.sqrt(2) * val)
+    return _np.sqrt(2) * val
 
 
 # Define RMS Calculator
 def rms(val):
     r"""
     Sinusoid Peak to RMS Converter.
 
@@ -1753,15 +1386,15 @@
 
     Examples
     --------
     >>> import electricpy as ep
     >>> ep.rms(169.7)
     119.99602076735711
     """
-    return (val * _np.sqrt(0.5))
+    return val * _np.sqrt(0.5)
 
 
 # Define Normalized Power Spectrum Function
 def wrms(func, dw=0.1, NN=100, quad=False, plot=True,
          title="Power Density Spectrum", round=3):
     """
     WRMS Function.
@@ -1801,37 +1434,37 @@
     # Power Density Spectrum
     Sxx = _np.array([])
     for n in range(NN):
         # Calculate Power Density Spectrum
         Sxx = _np.append(Sxx, func(omega[n]))
         Stot = Stot + Sxx[n]
         Sw2 = Sw2 + (omega[n] ** 2) * Sxx[n]
-    if (quad):
+    if quad:
         def intf(w):
-            return (w ** 2 * func(w))
+            return w ** 2 * func(w)
 
         num = integrate(intf, 0, _np.inf)[0]
         den = integrate(func, 0, _np.inf)[0]
         # Calculate W
         W = _np.sqrt(num / den)
     else:
         # Calculate W
         W = _np.sqrt(Sw2 / Stot)
     Wr = _np.around(W, round)
     # Plot Upon Request
-    if (plot):
+    if plot:
         _plt.plot(omega, Sxx)
         _plt.title(title)
         # Evaluate Text Location
         x = 0.65 * max(omega)
         y = 0.80 * max(Sxx)
         _plt.text(x, y, "Wrms: " + str(Wr))
         _plt.show()
     # Return Calculated RMS Bandwidth
-    return (W)
+    return W
 
 
 # Define Hartley's Equation for Data Capacity
 def hartleydata(BW, M):
     """
     Hartley Data Function.
 
@@ -1847,15 +1480,15 @@
 
     Returns
     -------
     C:          float
                 Capacity of channel (in bits per second)
     """
     C = 2 * BW * _np.log2(M)
-    return (C)
+    return C
 
 
 # Define Shannon's Equation For Data Capacity
 def shannondata(BW, S, N):
     """
     Shannon Data Function.
 
@@ -1873,222 +1506,15 @@
 
     Returns
     -------
     C:          float
                 Capacity of channel (in bits per second)
     """
     C = BW * _np.log2(1 + S / N)
-    return (C)
-
-
-# Define CRC Generator (Sender Side)
-def crcsender(data, key):
-    """
-    CRC Sender Function.
-
-    Function to generate a CRC-embedded message ready for transmission.
-
-    Contributing Author Credit:
-    Shaurya Uppal
-    Available from: geeksforgeeks.org
-
-    Parameters
-    ----------
-    data:       string of bits
-                The bit-string to be encoded.
-    key:        string of bits
-                Bit-string representing key.
-
-    Returns
-    -------
-    codeword:   string of bits
-                Bit-string representation of
-                encoded message.
-    """
-    # Define Sub-Functions
-    def xor(a, b):
-        # initialize result
-        result = []
-
-        # Traverse all bits, if bits are
-        # same, then XOR is 0, else 1
-        for i in range(1, len(b)):
-            if a[i] == b[i]:
-                result.append('0')
-            else:
-                result.append('1')
-
-        return (''.join(result))
-
-    # Performs Modulo-2 division
-    def mod2div(divident, divisor):
-        # Number of bits to be XORed at a time.
-        pick = len(divisor)
-
-        # Slicing the divident to appropriate
-        # length for particular step
-        tmp = divident[0: pick]
-
-        while pick < len(divident):
-
-            if tmp[0] == '1':
-
-                # replace the divident by the result
-                # of XOR and pull 1 bit down
-                tmp = xor(divisor, tmp) + divident[pick]
-
-            else:  # If leftmost bit is '0'
-
-                # If the leftmost bit of the dividend (or the
-                # part used in each step) is 0, the step cannot
-                # use the regular divisor; we need to use an
-                # all-0s divisor.
-                tmp = xor('0' * pick, tmp) + divident[pick]
-
-                # increment pick to move further
-            pick += 1
-
-        # For the last n bits, we have to carry it out
-        # normally as increased value of pick will cause
-        # Index Out of Bounds.
-        if tmp[0] == '1':
-            tmp = xor(divisor, tmp)
-        else:
-            tmp = xor('0' * pick, tmp)
-
-        checkword = tmp
-        return (checkword)
-
-    # Condition data
-    data = str(data)
-    # Condition Key
-    key = str(key)
-    l_key = len(key)
-
-    # Appends n-1 zeroes at end of data
-    appended_data = data + '0' * (l_key - 1)
-    remainder = mod2div(appended_data, key)
-
-    # Append remainder in the original data
-    codeword = data + remainder
-    return (codeword)
-
-
-# Define CRC Generator (Sender Side)
-def crcremainder(data, key):
-    """
-    CRC Remainder Function.
-
-    Function to calculate the CRC remainder of a CRC message.
-
-    Contributing Author Credit:
-    Shaurya Uppal
-    Available from: geeksforgeeks.org
-
-    Parameters
-    ----------
-    data:       string of bits
-                The bit-string to be decoded.
-    key:        string of bits
-                Bit-string representing key.
-
-    Returns
-    -------
-    remainder: string of bits
-                Bit-string representation of
-                encoded message.
-    """
-    # Define Sub-Functions
-    def xor(a, b):
-        # initialize result
-        result = []
-
-        # Traverse all bits, if bits are
-        # same, then XOR is 0, else 1
-        for i in range(1, len(b)):
-            if a[i] == b[i]:
-                result.append('0')
-            else:
-                result.append('1')
-
-        return (''.join(result))
-
-    # Performs Modulo-2 division
-    def mod2div(divident, divisor):
-        # Number of bits to be XORed at a time.
-        pick = len(divisor)
-
-        # Slicing the divident to appropriate
-        # length for particular step
-        tmp = divident[0: pick]
-
-        while pick < len(divident):
-
-            if tmp[0] == '1':
-
-                # replace the divident by the result
-                # of XOR and pull 1 bit down
-                tmp = xor(divisor, tmp) + divident[pick]
-
-            else:  # If leftmost bit is '0'
-
-                # If the leftmost bit of the dividend (or the
-                # part used in each step) is 0, the step cannot
-                # use the regular divisor; we need to use an
-                # all-0s divisor.
-                tmp = xor('0' * pick, tmp) + divident[pick]
-
-                # increment pick to move further
-            pick += 1
-
-        # For the last n bits, we have to carry it out
-        # normally as increased value of pick will cause
-        # Index Out of Bounds.
-        if tmp[0] == '1':
-            tmp = xor(divisor, tmp)
-        else:
-            tmp = xor('0' * pick, tmp)
-
-        checkword = tmp
-        return (checkword)
-
-    # Condition data
-    data = str(data)
-    # Condition Key
-    key = str(key)
-    l_key = len(key)
-
-    # Appends n-1 zeroes at end of data
-    appended_data = data + '0' * (l_key - 1)
-    remainder = mod2div(appended_data, key)
-
-    return (remainder)
-
-
-# Define String to Bits Function
-def string_to_bits(str):
-    # noqa: D401   "String" is an intended leading word.
-    """
-    String to Bits Converter.
-
-    Converts a Pythonic string to the string's binary representation.
-
-    Parameters
-    ----------
-    str:        string
-                The string to be converted.
-
-    Returns
-    -------
-    data:       string
-                The binary representation of the
-                input string.
-    """
-    data = (''.join(format(ord(x), 'b') for x in str))
-    return (data)
+    return C
 
 
 # Define Per-Unit Impedance Formula
 def zpu(S, VLL=None, VLN=None):
     r"""
     Per-Unit Impedance Evaluator.
 
@@ -2109,20 +1535,20 @@
                 The Line-to-Neutral Voltage; default=None
 
     Returns
     -------
     Zbase:      float
                 The per-unit impedance base.
     """
-    if (VLL == None and VLN == None):
+    if VLL is None and VLN is None:
         raise ValueError("ERROR: One voltage must be provided.")
-    if VLL != None:
-        return (VLL ** 2 / S)
+    if VLL is not None:
+        return VLL ** 2 / S
     else:
-        return ((_np.sqrt(3) * VLN) ** 2 / S)
+        return (_np.sqrt(3) * VLN) ** 2 / S
 
 
 # Define Per-Unit Current Formula
 def ipu(S, VLL=None, VLN=None, V1phs=None):
     r"""
     Per-Unit Current Evaluator.
 
@@ -2145,22 +1571,22 @@
                 The voltage base of the single phase system.
 
     Returns
     -------
     Ibase:      float
                 The per-unit current base.
     """
-    if (VLL == None and VLN == None):
+    if VLL is None and VLN is None:
         raise ValueError("ERROR: One voltage must be provided.")
-    if VLL != None:
-        return (S / (_np.sqrt(3) * VLL))
-    elif VLN != None:
-        return (S / (3 * VLN))
+    if VLL is not None:
+        return S / (_np.sqrt(3) * VLL)
+    elif VLN is not None:
+        return S / (3 * VLN)
     else:
-        return (S / V1phs)
+        return S / V1phs
 
 
 # Define Per-Unit Change of Base Function
 def puchgbase(quantity, puB_old, puB_new):
     r"""
     Per-Unit Change of Base Function.
 
@@ -2180,15 +1606,15 @@
 
     Returns
     -------
     pu_new:     complex
                 New per-unit value.
     """
     pu_new = quantity * puB_old / puB_new
-    return (pu_new)
+    return pu_new
 
 
 # Define Recomposition Function
 def zrecompose(z_pu, S3phs, VLL=None, VLN=None):
     """
     Impedance from Per-Unit System Evaluator.
 
@@ -2212,15 +1638,15 @@
     z:          complex
                 The ohmic impedance evaluated from the per-unit base.
     """
     # Evaluate the per-unit impedance
     zbase = zpu(S3phs, VLL, VLN)
     # Evaluate the impedance
     z = z_pu * zbase
-    return (z)
+    return z
 
 
 # Define X/R Recomposition Function
 def rxrecompose(x_pu, XoR, S3phs=None, VLL=None, VLN=None):
     """
     Resistance/Reactance from Per-Unit System Evaluator.
 
@@ -2251,23 +1677,23 @@
     # Ensure Absolute Value
     x_pu = abs(x_pu)
     # Find R from X/R
     r_pu = x_pu / XoR
     # Compose into z
     z_pu = r_pu + 1j * x_pu
     # Recompose
-    if S3phs == None:
-        return (z_pu)
+    if S3phs is None:
+        return z_pu
     else:
         z = zrecompose(z_pu, S3phs, VLL, VLN)
-        return (z)
+        return z
 
 
 # Define Generator Internal Voltage Calculator
-def geninternalv(I, Zs, Vt, Vgn=None,Zm=None, Zmp=None, Zmpp=None, Ip=None, Ipp=None):
+def geninternalv(I, Zs, Vt, Vgn=None, Zm=None, Zmp=None, Zmpp=None, Ip=None, Ipp=None):
     """
     Electric Generator Internal Voltage Evaluator.
 
     Evaluates the internal voltage for a generator given the
     generator's internal impedance and internal mutual coupling
     impedance values.
 
@@ -2295,25 +1721,25 @@
 
     Returns
     -------
     Ea:         complex
                 The internal voltage of the generator.
     """
     # All Parameters Provided
-    if Zmp == Zmpp == Ip == Ipp != None:
-        if Vgn == None:
+    if Zmp == Zmpp == Ip == Ipp is not None:
+        if Vgn is None:
             Vgn = 0
         Ea = Zs * I + Zmp * Ip + Zmpp * Ipp + Vt + Vgn
     # Select Parameters Provided
-    elif Vgn == Zm == Ip == Ipp == None:
+    elif Vgn == Zm == Ip == Ipp is None:
         Ea = Zs * I + Vt
     # Invalid Parameter Set
     else:
         raise ValueError("Invalid Parameter Set")
-    return (Ea)
+    return Ea
 
 
 # FFT Coefficient Calculator Function
 def funcfft(func, minfreq=60, maxmult=15, complex=False):
     """
     FFT Evaluator for Callable Functions.
 
@@ -2349,19 +1775,19 @@
     T = 1 / minfreq
     # Generate time range to apply for FFT
     t, dt = _np.linspace(0, T, NN, endpoint=False, retstep=True)
     # Evaluate FFT
     y = _np.fft.rfft(func(t)) / t.size
     # Return Complex Values
     if complex:
-        return (y)
+        return y
     # Split out useful values
     else:
         y *= 2
-        return (y[0].real, y[1:-1].real, -y[1:-1].imag)
+        return y[0].real, y[1:-1].real, -y[1:-1].imag
 
 
 def sampfft(data, dt, minfreq=60.0, complex=False):
     """
     Sample Dataset FFT Evaluator.
 
     Given a data array and the delta-t for the data array, evaluates
@@ -2408,15 +1834,15 @@
         y = _np.fft.rfft(cut_data) / len(cut_data)
     # Return Complex Values
     if complex:
         return (y)
     # Split out useful values
     else:
         y *= 2
-        return (y[0].real, y[1:-1].real, -y[1:-1].imag)
+        return y[0].real, y[1:-1].real, -y[1:-1].imag
 
 
 # Define FFT Plotting Function
 def fftplot(dc, real, imag=None, title="Fourier Coefficients"):
     """
     FFT System Plotter.
 
@@ -2430,15 +1856,15 @@
     real:       list of float
                 Real terms of FFT (cosine terms)
     imag:       list of float, optional
                 Imaginary terms of FFT (sine terms)
     title:      str, optional
                 String appended to plot title,
                 default="Fourier Coefficients"
-    
+
     Returns
     -------
     matplotlib.pyplot:  Plotting object to be used for additional configuration
                         or plotting.
     """
     # Define Range values for plots
     rng = range(1, len(real) + 1, 1)
@@ -2453,15 +1879,15 @@
         rng,
         real,
         linefmt='r',
         markerfmt='ro',
         label="Real-Terms",
         use_line_collection=True
     )
-    if imag != None:
+    if imag is not None:
         _plt.stem(
             rng,
             imag,
             linefmt='b',
             markerfmt='bo',
             label="Imaginary-Terms",
             use_line_collection=True
@@ -2498,37 +1924,37 @@
                 List of two floats containing the minimum
                 time and the maximum time.
     npts:       int, optional
                 Number of time step points, default=1000
     title:      str, optional
                 String appended to plot title,
                 default="Fourier Series Summation"
-    
+
     Returns
     -------
     matplotlib.pyplot:  Plotting object to be used for additional configuration
                         or plotting.
     """
     # Determine the number (N) of terms
     N = len(real)
     # Determine the system period (T)
     T = 1 / freq
     # Generate Domain Array
-    if xrange == None:
+    if xrange is None:
         x = _np.linspace(0, T, npts)
     else:
         x = _np.linspace(xrange[0], xrange[1], npts)
     # Initialize output with DC term
     yout = _np.ones(len(x)) * dc
     # Plot each iteration of the Fourier Series
     for k in range(1, N):
         if plotall:
             _plt.plot(x, yout)
         yout += real[k - 1] * _np.cos(k * 2 * _np.pi * x / T)
-        if imag != None:
+        if imag is not None:
             yout += imag[k - 1] * _np.sin(k * 2 * _np.pi * x / T)
     _plt.plot(x, yout)
     _plt.title(title)
     _plt.xlabel("Time (seconds)")
     _plt.ylabel("Magnitude")
     return _plt
 
@@ -2568,36 +1994,36 @@
                 Function object handle which can be used to
                 call the function to evaluate the harmonic
                 system at specified times.
     """
     # Validate Inputs
     if not isinstance(real, (list, _np.ndarray)):
         raise ValueError("Argument *real* must be array-like.")
-    if imag != None and not isinstance(imag, (list, _np.ndarray)):
+    if imag is not None and not isinstance(imag, (list, _np.ndarray)):
         raise ValueError("Argument *imag* must be array-like.")
     # Calculate Omega
     w = 2 * _np.pi * freq
 
     def _harmonic_(t):
         out = dc
         for k in range(len(real)):
             # Evaluate Current Coefficient
             A = real[k]
-            if imag != None:
+            if imag is not None:
                 B = imag[k]
             else:
                 B = 0
             m = k + 1
             # Calculate Output
             out += A * _np.cos(m * w * t) + B * _np.sin(m * w * t)
         # Return Value
         return (out)
 
     if domain is None:
-        return _harmonic_ # Return as callable for external use
+        return _harmonic_  # Return as callable for external use
     else:
         return _harmonic_(domain)
 
 
 # Define Single Phase Motor Startup Capacitor Formula
 def motorstartcap(V, I, freq=60):
     """
@@ -2670,24 +2096,24 @@
     Pold = S * PFold
     Qold = _np.sqrt(S ** 2 - Pold ** 2)
     # Evaluate Reactive Power Requirements
     Scorrected = Pold / PFnew
     Qcorrected = _np.sqrt(Scorrected ** 2 - Pold ** 2)
     Qc = Qold - Qcorrected
     # Evaluate Capacitance Based on Voltage Input
-    if VLL == VLN == V == None:
+    if VLL == VLN == V is None:
         raise ValueError("One voltage must be specified.")
-    elif VLN != None:
+    elif VLN is not None:
         C = Qc / (2 * _np.pi * freq * 3 * VLN ** 2)
     else:
-        if VLL != None:
+        if VLL is not None:
             V = VLL
         C = Qc / (2 * _np.pi * freq * V ** 2)
     # Return Value
-    return (C, Qc)
+    return C, Qc
 
 
 # Define Apparent Power / Voltage / Current Relation Function
 def acpiv(S=None, I=None, VLL=None, VLN=None, V=None, PF=None):
     """
     AC Power-Voltage-Current Relation Function.
 
@@ -2703,14 +2129,17 @@
                 Phase current in amps
     VLL:        complex, optional
                 Line-to-Line voltage in volts
     VLN:        complex, optional
                 Line-to-Neutral voltage in volts
     V:          complex, optional
                 Single-phase voltage in volts
+    PF:         float, optional
+                Power factor to condition the apparent power to an appropriate
+                complex value.
 
     Returns
     -------
     S:          complex
                 Apparent power, returned only if one voltage
                 and current is specified
     I:          complex
@@ -2727,51 +2156,59 @@
     V:          complex
                 Single-phase voltage, returned only if current
                 and apparent power specified, returned as set
                 with other voltages in form: (VLL, VLN, V)
     PF:         float, optional
                 Supporting argument to convert floating-point
                 apparent power to complex representation.
+
+    Examples
+    --------
+    >>> import electricpy as ep
+    >>> ep.acpiv(S=550, V=167)
+    3.2934131736526946
+    >>> ep.acpiv(S=550, I=3.2934131736526946)
+    (96.4174949546675, 55.66666666666667, 167.0)
     """
     # Validate Inputs
-    if S == I == None:
+    if S == I is None:
         raise ValueError("To few arguments.")
     # Convert Apparent Power to Complex
-    if PF != None:
+    if PF is not None:
         S = S * PF + 1j * _np.sqrt(S ** 2 - (S * PF) ** 2)
     # Solve Single-Phase
-    if V != None:
-        if S == None:  # Solve for Apparent Power
+    if V is not None:
+        if S is None:  # Solve for Apparent Power
             S = V * _np.conj(I)
-            return (S)
+            return S
         else:  # Solve for Current
             I = _np.conj(S / V)
-            return (I)
+            return I
     # Solve Line-to-Line
-    elif VLL != None:
-        if S == None:  # Solve for Apparent Power
+    elif VLL is not None:
+        if S is None:  # Solve for Apparent Power
             S = _np.sqrt(3) * VLL * _np.conj(I)
-            return (S)
+            return S
         else:  # Solve for Current
             I = _np.conj(S / (_np.sqrt(3) * VLL))
-            return (I)
+            return I
     # Solve Line-to-Neutral
-    elif VLN != None:
-        if S == None:  # Solve for Apparent Power
+    elif VLN is not None:
+        if S is None:  # Solve for Apparent Power
             S = 3 * VLN * _np.conj(I)
-            return (S)
+            return S
         else:  # Solve for Current
             I = _np.conj(S / (3 * VLN))
-            return (I)
+            return I
     # Solve for Voltages
     else:
         V = S / _np.conj(I)
         VLL = S / (_np.sqrt(3) * _np.conj(I))
         VLN = S / (3 * _np.conj(I))
-        return (VLL, VLN, V)
+        return VLL, VLN, V
 
 
 # Define Primary Ratio Function
 def primary(val, Np, Ns=1, invert=False):
     """
     Electrical Transformer Primary Evaluator.
 
@@ -2796,16 +2233,16 @@
     Returns
     -------
     reflection: complex
                 The reflected value referred to the primary
                 side according to Np and Ns.
     """
     if invert:
-        return (val * Ns / Np)
-    return (val * Np / Ns)
+        return val * Ns / Np
+    return val * Np / Ns
 
 
 # Define Secondary Ratio Function
 def secondary(val, Np, Ns=1, invert=False):
     """
     Electrical Transformer Secondary Evaluator.
 
@@ -2830,26 +2267,26 @@
     Returns
     -------
     reflection: complex
                 The reflected value referred to the secondary
                 side according to Np and Ns.
     """
     if invert:
-        return (val * Np / Ns)
-    return (val * Ns / Np)
+        return val * Np / Ns
+    return val * Ns / Np
 
 
 def tap_changing_transformer(Vgen, Vdis, Pload, Qload, R, X):
     r"""
     Calculate Turn Ratio of Load Tap Changing Transformer.
 
     The purpose of a tap changer is to regulate the output voltage of a
     transformer. It does this by altering the number of turns in one winding and
     thereby changing the turns ratio of the transformer
-    
+
     .. math:: \sqrt{\frac{Vgen^2}{Vgen \cdot Vdis - R \cdot P - X \cdot Q}}
 
     Parameters
     ----------
     Vgen:   float
             Generating station voltage
     Vdis:   float
@@ -2858,50 +2295,53 @@
             Transmission line load active power in Watt
     Qload:  float
             Transmission line load reactive power in VAR
     R:      float
             Resistance of transmission line
     X:      float
             Reactance of transmission line
-    
+
     Returns
     -------
     ts:     float
             Turns ration of transformer
     """
     # Evaluate the turns ratio
-    ts = (Vgen*Vgen) / (Vgen*Vdis - (R * Pload + X * Qload) )
+    ts = (Vgen * Vgen) / (Vgen * Vdis - (R * Pload + X * Qload))
     return pow(ts, 0.5)
 
+
 def suspension_insulators(number_capacitors, capacitance_ratio, Voltage):
     r"""
     Discrete Capacitors Voltage in a Suspension Insulator Strain.
 
     To perform the calculations described here, the following formulas are
     satisfied, and used to construct a matrix used to solve for
     :math:`V_i \text{i in range(1,n)}`.
 
     .. math:: \sum_{i=1}^{n-2} V_{i} + V_{n-1} \cdot (1+m) - V_{n} \cdot m=0
 
     .. math:: \sum_{i=1}^{n} V_{i} = V_{\text{transmission line}}
-    
+
     .. image:: /static/SuspensionInuslator.png
-    
+
     `Additional Information
     <https://electrical-engineering-portal.com/download-center/books-and-guides/power-substations/insulator-pollution>`_
-    
+
     Parameters
     ----------
     number_capacitors:  int
                         Number of disk capacitors hung to transmission line
     capacitance_ratio:  float
-                        Ratio of disk capacitance and pin to pole air capacitance
+                        Ratio of disk capacitance and pin to pole air
+                        capacitance
     Voltage:            float
-                        Voltage difference between the transmission line and ground
-    
+                        Voltage difference between the transmission line and
+                        ground
+
     Returns
     -------
     string_efficiency:          float
                                 String efficiency of capacitive disks
     capacitor_disk_voltages:    float
                                 Voltage across each capacitive disk starting
                                 from top to bottom
@@ -2924,18 +2364,21 @@
 
     v = _np.zeros((number_capacitors, 1))
 
     v[number_capacitors - 1, 0] = Voltage
 
     capacitor_disk_voltages = _np.matmul(_np.linalg.inv(m), v)
 
-    string_efficiency = (Voltage * 100) / (number_capacitors * capacitor_disk_voltages[-1, 0])
+    string_efficiency = (
+        (Voltage * 100) / (number_capacitors * capacitor_disk_voltages[-1, 0])
+    )
 
     return capacitor_disk_voltages, string_efficiency
 
+
 # Define Natural Frequency/Resonant Frequency Calculator
 def natfreq(C, L, Hz=True):
     r"""
     Natural Frequency Evaluator.
 
     Evaluates the natural frequency (resonant frequency) of a circuit given the
     circuit's C and L values. Defaults to returning values in Hz, but may also
@@ -3007,17 +2450,17 @@
     dC = abs(C - avg)
     # Gather Maximum Variation
     mx = max(dA, dB, dC)
     # Calculate Maximum Variation
     unbalance = mx / avg
     # Return Results
     if all:
-        return (dA / avg, dB / avg, dC / avg)
+        return dA / avg, dB / avg, dC / avg
     else:
-        return (unbalance)
+        return unbalance
 
 
 # Define Cosine Filter Function
 def cosfilt(arr, Srate, domain=False):
     """
     Cosine Filter Function.
 
@@ -3044,31 +2487,31 @@
                 X-axis array for the filtered data.
     """
     # Evaluate index set
     ind = _np.arange(Srate - 1, len(arr) - 1)
 
     # Define Cosine Coefficient Function
     def cos(k, Srate):
-        return (_np.cos(2 * _np.pi * k / Srate))
+        return _np.cos(2 * _np.pi * k / Srate)
 
     # Calculate Constant
     const = 2 / Srate
     # Iteratively Calculate
     cosf = 0
     for k in range(0, Srate - 1):
         slc = (ind - (Srate - 1)) + k
         cosf += cos(k, Srate) * arr[slc]
     # Scale
     cosf = const * cosf
     # Return Cosine-Filtered Array
     if domain:
         xarray = _np.linspace(Srate + Srate / 4 - 1, len(arr) - 1, len(cosf))
         xarray = xarray / Srate
-        return (cosf, xarray)
-    return (cosf)
+        return cosf, xarray
+    return cosf
 
 
 # Define Sine Filter Function
 def sinfilt(arr, Srate, domain=False):
     """
     Sine Filter Function.
 
@@ -3095,31 +2538,31 @@
                 X-axis array for the filtered data.
     """
     # Evaluate index set
     ind = _np.arange(Srate - 1, len(arr) - 1)
 
     # Define Cosine Coefficient Function
     def sin(k, Srate):
-        return (_np.sin(2 * _np.pi * k / Srate))
+        return _np.sin(2 * _np.pi * k / Srate)
 
     # Calculate Constant
     const = 2 / Srate
     # Iteratively Calculate
     sinf = 0
     for k in range(0, Srate - 1):
         slc = (ind - (Srate - 1)) + k
         sinf += sin(k, Srate) * arr[slc]
     # Scale
     sinf = const * sinf
     # Return Cosine-Filtered Array
     if domain:
         xarray = _np.linspace(Srate + Srate / 4 - 1, len(arr) - 1, len(sinf))
         xarray = xarray / Srate
-        return (sinf, xarray)
-    return (sinf)
+        return sinf, xarray
+    return sinf
 
 
 # Define Characteristic Impedance Calculator
 def characterz(R, G, L, C, freq=60):
     r"""
     Characteristic Impedance Calculator.
 
@@ -3152,47 +2595,48 @@
     """
     # Evaluate omega
     w = 2 * _np.pi * freq
     # Evaluate Zc
     Zc = _np.sqrt((R + 1j * w * L) / (G + 1j * w * C))
     return (Zc)
 
+
 # Define propagation_constants for long transmission line
 def propagation_constants(z, y, length):
     r"""
     Transaction Line Propagation Constant Calculator.
 
     This function will evaluate the propagation constants for a long transmission
     line whose properties are governed by the differential equation:
-    
+
     .. math:: \frac{d^2V}{dx^2} = \gamma V
-    
+
     From the above equation, the following formulas are derived to evaluate the
     desired constants.
-    
+
     .. math:: \gamma = \sqrt( z * y )
-    
+
     .. math:: Z_{\text{surge}} = \sqrt( z / y )
-    
+
     .. math:: \alpha = \Re{ \gamma }
-    
+
     .. math:: \beta = \Im{ \gamma }
-    
+
     Parameters
     ----------
     z:              complex
                     Impedence of the transmission line: R+j*2*pi*f*L
     y:              complex
                     Admitance of the transmission line g+j*2*pi*f*C
-        
+
     Returns
     -------
     params:    dict
                Dictionary of propagation constants including:
-                    
+
                          gamma:   Propagation constant
                          zc:            Surge impedance
                          alpha:      Attenuation constant
                          beta:        Imaginary portion of gamma
     """
     # Validate the line length is substantial enough for calculation
     if not (length > 500):
@@ -3209,882 +2653,14 @@
         'beta': beta,
         'Surge_impedance': zc
     }
 
     return params
 
 
-# Define Simple Transformer Phase Shift Function
-def xfmphs(style="DY", shift=30):
-    """
-    Electrical Transformer Phase-Shift Calculator.
-
-    Use with transformer orientation to evaluate the phase-shift across a
-    transformer. For example, find the phase shift for a Delta-Wye transformer
-    as seen from the delta side.
-
-    Parameters
-    ----------
-    style:      {'DY','YD','DD','YY'}, optional
-                String that denotes the transformer
-                orientation. default='DY'
-    shift:      float, optional
-                Transformer angle shift, default=30
-
-    Returns
-    -------
-    phase:      complex
-                Phasor including the phase shift and
-                positive or negative characteristic.
-
-    Examples
-    --------
-    >>> import electricpy as ep
-    >>> # Find shift of Delta-Wye Transformer w/ 30° shift
-    >>> shift = ep.xfmphs(style="DY",shift=30)
-    >>> ep.cprint(shift)
-    1.0 ∠ 30.0°
-    """
-    # Define Direction Dictionary
-    orientation = {
-        "DY": 1,
-        "YD": -1,
-        "DD": 0,
-        "YY": 0,
-    }
-    # Find Direction
-    v = orientation[style.upper()]
-    # Calculate Shift
-    phase = _np.exp(1j * _np.radians(v * abs(shift)))
-    # Return
-    return (phase)
-
-
-# Define Induction Machine Thevenin Voltage Calculator
-def indmachvth(Vas, Rs, Lm, Lls=0, Ls=None, freq=60, calcX=True):
-    r"""
-    Induction Machine Thevenin Voltage Calculator.
-
-    Function to calculate the Thevenin equivalent voltage of an
-    induction machine given a specific set of parameters.
-
-    .. math:: V_{th}=\frac{j\omega L_m}{R_s+j\omega(L_{ls}+L_m)}V_{as}
-
-    where:
-
-    .. math:: \omega = \omega_{es} = 2\pi\cdot f_{\text{electric}}
-
-    Parameters
-    ----------
-    Vas:        complex
-                Terminal Stator Voltage in Volts
-    Rs:         float
-                Stator resistance in ohms
-    Lm:         float
-                Magnetizing inductance in Henrys
-    Lls:        float, optional
-                Stator leakage inductance in Henrys, default=0
-    Ls:         float, optional
-                Stator inductance in Henrys
-    freq:       float, optional
-                System (electrical) frequency in Hz, default=60
-    calcX:      bool, optional
-                Control argument to force system to calculate
-                system reactances with system frequency, or to
-                treat them as previously-calculated reactances.
-                default=True
-
-    Returns
-    -------
-    Vth:        complex
-                Thevenin-Equivalent voltage (in volts) of induction
-                machine described.
-
-    See Also
-    --------
-    indmachzth:         Induction Machine Thevenin Impedance Calculator
-    indmachpem:         Induction Machine Electro-Mechanical Power Calculator
-    indmachtem:         Induction Machine Electro-Mechanical Torque Calculator
-    indmachpkslip:      Induction Machine Peak Slip Calculator
-    indmachpktorq:      Induction Machine Peak Torque Calculator
-    indmachiar:         Induction Machine Phase-A Rotor Current Calculator
-    indmachstarttorq:   Induction Machine Starting Torque Calculator
-    """
-    # Condition Inputs
-    if Ls != None:  # Use Ls instead of Lls
-        Lls = Ls - Lm
-    if calcX:  # Convert Inductances to Reactances
-        w = 2 * _np.pi * freq
-        Lm *= w
-        Lls *= w
-    # Calculate Thevenin Voltage, Return
-    Vth = 1j * Lm / (Rs + 1j * (Lls + Lm)) * Vas
-    return (Vth)
-
-
-# Define Induction Machine Thevenin Impedance Calculator
-def indmachzth(Rs, Lm, Lls=0, Llr=0, Ls=None, Lr=None, freq=60, calcX=True):
-    r"""
-    Induction Machine Thevenin Impedance Calculator.
-
-    Function to calculate the Thevenin equivalent impedance of an
-    induction machine given a specific set of parameters.
-
-    .. math::
-       Z_{th} = \frac{(R_s+j\omega L_{ls})j\omega L_m}
-       {R_s+j\omega(L_{ls}+L_m)}+j\omega L_{lr}
-
-    where:
-
-    .. math:: \omega = \omega_{es} = 2\pi\cdot f_{\text{electric}}
-
-    Parameters
-    ----------
-    Rs:         float
-                Stator resistance in ohms
-    Lm:         float
-                Magnetizing inductance in Henrys
-    Lls:        float, optional
-                Stator leakage inductance in Henrys, default=0
-    Llr:        float, optional
-                Rotor leakage inductance in Henrys, default=0
-    Ls:         float, optional
-                Stator inductance in Henrys
-    Lr:         float, optional
-                Rotor inductance in Henrys
-    freq:       float, optional
-                System (electrical) frequency in Hz, default=60
-    calcX:      bool, optional
-                Control argument to force system to calculate
-                system reactances with system frequency, or to
-                treat them as previously-calculated reactances.
-                default=True
-
-    Returns
-    -------
-    Zth:        complex
-                Thevenin-Equivalent impedance (in ohms) of induction
-                machine described.
-
-    See Also
-    --------
-    indmachvth:         Induction Machine Thevenin Voltage Calculator
-    indmachpem:         Induction Machine Electro-Mechanical Power Calculator
-    indmachtem:         Induction Machine Electro-Mechanical Torque Calculator
-    indmachpkslip:      Induction Machine Peak Slip Calculator
-    indmachpktorq:      Induction Machine Peak Torque Calculator
-    indmachiar:         Induction Machine Phase-A Rotor Current Calculator
-    indmachstarttorq:   Induction Machine Starting Torque Calculator
-    """
-    # Condition Inputs
-    if Ls != None:  # Use Ls instead of Lls
-        Lls = Ls - Lm
-    if Lr != None:  # Use Lr instead of Llr
-        Llr = Lr - Lm
-    if calcX:  # Convert Inductances to Reactances
-        w = 2 * _np.pi * freq
-        Lm *= w
-        Lls *= w
-        Llr *= w
-    # Calculate Thevenin Impedance
-    Zth = (Rs + 1j * Lls) * (1j * Lm) / (Rs + 1j * (Lls + Lm)) + 1j * Llr
-    return (Zth)
-
-
-# Define Induction Machine Mechancal Power Calculator
-def indmachpem(slip, Rr, Vth=None, Zth=None, Vas=0, Rs=0, Lm=0, Lls=0,
-               Llr=0, Ls=None, Lr=None, freq=60, calcX=True):
-    r"""
-    Mechanical Power Calculator for Induction Machines.
-
-    Function to calculate the mechanical power using the thevenin
-    equivalent circuit terms.
-
-    .. math::
-       P_{em}=\frac{|V_{th_{\text{stator}}}|^2\cdot\frac{R_r}{slip}}
-       {\left[\left(\frac{R_r}{slip}+R_{th_{\text{stator}}}\right)^2
-       +X_{th_{\text{stator}}}^2\right]\cdot\omega_{es}}\cdot(1-slip)
-
-    Parameters
-    ----------
-    slip:       float
-                The mechanical/electrical slip factor of the
-                induction machine.
-    Rr:         float
-                Rotor resistance in ohms
-    Vth:        complex, optional
-                Thevenin-equivalent stator voltage of the
-                induction machine, may be calculated internally
-                if given stator voltage and machine parameters.
-    Zth:        complex, optional
-                Thevenin-equivalent inductance (in ohms) of the
-                induction machine, may be calculated internally
-                if given machine parameters.
-    Vas:        complex, optional
-                Terminal Stator Voltage in Volts
-    Rs:         float, optional
-                Stator resistance in ohms
-    Lm:         float, optional
-                Magnetizing inductance in Henrys
-    Lls:        float, optional
-                Stator leakage inductance in Henrys, default=0
-    Llr:        float, optional
-                Rotor leakage inductance in Henrys, default=0
-    Ls:         float, optional
-                Stator inductance in Henrys
-    Lr:         float, optional
-                Rotor inductance in Henrys
-    freq:       float, optional
-                System (electrical) frequency in Hz, default=60
-    calcX:      bool, optional
-                Control argument to force system to calculate
-                system reactances with system frequency, or to
-                treat them as previously-calculated reactances.
-                default=True
-
-    Returns
-    -------
-    Pem:        float
-                Power (in watts) that is produced or consumed
-                by the mechanical portion of the induction machine.
-
-    See Also
-    --------
-    indmachvth:         Induction Machine Thevenin Voltage Calculator
-    indmachzth:         Induction Machine Thevenin Impedance Calculator
-    indmachtem:         Induction Machine Electro-Mechanical Torque Calculator
-    indmachpkslip:      Induction Machine Peak Slip Calculator
-    indmachpktorq:      Induction Machine Peak Torque Calculator
-    indmachiar:         Induction Machine Phase-A Rotor Current Calculator
-    indmachstarttorq:   Induction Machine Starting Torque Calculator
-    """
-    # Condition Inputs
-    w = 2 * _np.pi * freq
-    if Ls != None:  # Use Ls instead of Lls
-        Lls = Ls - Lm
-    if Lr != None:  # Use Lr instead of Llr
-        Llr = Lr - Lm
-    if calcX:  # Convert Inductances to Reactances
-        Lm *= w
-        Lls *= w
-        Llr *= w
-    # Test for Valid Input Set
-    if Vth == None:
-        if not all((Vas, Rs, Lm, Lls)):
-            raise ValueError("Invalid Argument Set, too few provided.")
-        # Valid Argument Set, Calculate Vth
-        Vth = indmachvth(Vas, Rs, Lm, Lls, Ls, freq, calcX)
-    if Zth == None:
-        if not all((Rs, Llr, Lm, Lls)):
-            raise ValueError("Invalid Argument Set, too few provided.")
-        # Valid Argument Set, Calculate Zth
-        Zth = indmachzth(Rs, Lm, Lls, Llr, Ls, Lr, freq, calcX)
-    # Use Terms to Calculate Pem
-    Rth = Zth.real
-    Xth = Zth.imag
-    Pem = (abs(Vth) ** 2 * Rr / slip) / (((Rr / slip + Rth) ** 2 + Xth ** 2) * w) * (1 - slip)
-    return (Pem)
-
-
-# Define Induction Machine Torque Calculator
-def indmachtem(slip, Rr, p=0, Vth=None, Zth=None, Vas=0, Rs=0, Lm=0, Lls=0,
-               Llr=0, Ls=None, Lr=None, wsyn=None, freq=60, calcX=True):
-    r"""
-    Induction Machine Torque Calculator.
-
-    Calculate the torque generated or consumed by an induction
-    machine given the machine parameters of Vth and Zth by use
-    of the equation below.
-
-    .. math::
-       T_{em}=\frac{3|V_{th_{\text{stator}}}|^2}
-       {\left[\left(\frac{R_r}{slip}+R_{th_{\text{stator}}}\right)^2
-       +X_{th_{\text{stator}}}\right]}\frac{R_r}{slip*\omega_{sync}}
-
-    where:
-
-    .. math::
-       \omega_{sync}=\frac{\omega_{es}}{\left(\frac{poles}{2}\right)}
-
-    Parameters
-    ----------
-    slip:       float
-                The mechanical/electrical slip factor of the
-                induction machine.
-    Rr:         float
-                Rotor resistance in ohms
-    p:          int, optional
-                Number of poles in the induction machine
-    Vth:        complex, optional
-                Thevenin-equivalent stator voltage of the
-                induction machine, may be calculated internally
-                if given stator voltage and machine parameters.
-    Zth:        complex, optional
-                Thevenin-equivalent inductance (in ohms) of the
-                induction machine, may be calculated internally
-                if given machine parameters.
-    Vas:        complex, optional
-                Terminal Stator Voltage in Volts
-    Rs:         float, optional
-                Stator resistance in ohms
-    Lm:         float, optional
-                Magnetizing inductance in Henrys
-    Lls:        float, optional
-                Stator leakage inductance in Henrys, default=0
-    Llr:        float, optional
-                Rotor leakage inductance in Henrys, default=0
-    Ls:         float, optional
-                Stator inductance in Henrys
-    Lr:         float, optional
-                Rotor inductance in Henrys
-    wsync:       float, optional
-                Synchronous speed in rad/sec, may be specified
-                directly as a replacement of p (number of poles).
-    freq:       float, optional
-                System (electrical) frequency in Hz, default=60
-    calcX:      bool, optional
-                Control argument to force system to calculate
-                system reactances with system frequency, or to
-                treat them as previously-calculated reactances.
-                default=True
-
-    Returns
-    -------
-    Tem:        float
-                Torque (in Newton-meters) that is produced or consumed
-                by the mechanical portion of the induction machine.
-
-    See Also
-    --------
-    indmachvth:         Induction Machine Thevenin Voltage Calculator
-    indmachzth:         Induction Machine Thevenin Impedance Calculator
-    indmachpem:         Induction Machine Electro-Mechanical Power Calculator
-    indmachpkslip:      Induction Machine Peak Slip Calculator
-    indmachpktorq:      Induction Machine Peak Torque Calculator
-    indmachiar:         Induction Machine Phase-A Rotor Current Calculator
-    indmachstarttorq:   Induction Machine Starting Torque Calculator
-    """
-    # Condition Inputs
-    w = 2 * _np.pi * freq
-    if Ls != None:  # Use Ls instead of Lls
-        Lls = Ls - Lm
-    if Lr != None:  # Use Lr instead of Llr
-        Llr = Lr - Lm
-    if p != 0:  # Calculate Sync. Speed from Num. Poles
-        wsyn = w / (p / 2)
-    if calcX:  # Convert Inductances to Reactances
-        Lm *= w
-        Lls *= w
-        Llr *= w
-    # Test for Valid Input Set
-    if not any((p, wsyn)):
-        raise ValueError("Poles or Synchronous Speed must be specified.")
-    if Vth == None:
-        if not all((Vas, Rs, Lm, Lls)):
-            raise ValueError("Invalid Argument Set, too few provided.")
-        # Valid Argument Set, Calculate Vth
-        Vth = indmachvth(Vas, Rs, Lm, Lls, Ls, freq, calcX)
-    if Zth == None:
-        if not all((Rs, Llr, Lm, Lls)):
-            raise ValueError("Invalid Argument Set, too few provided.")
-        # Valid Argument Set, Calculate Zth
-        Zth = indmachzth(Rs, Lm, Lls, Llr, Ls, Lr, freq, calcX)
-    # Use Terms to Calculate Pem
-    Rth = Zth.real
-    Xth = Zth.imag
-    Tem = 3 * abs(Vth) ** 2 / ((Rr / slip + Rth) ** 2 + Xth) * Rr / (slip * wsyn)
-    return (Tem)
-
-
-# Define Induction Machine Peak Slip Calculator
-def indmachpkslip(Rr, Zth=None, Rs=0, Lm=0, Lls=0, Llr=0, Ls=None,
-                  Lr=None, freq=60, calcX=True):
-    r"""
-    Induction Machine Slip at Peak Torque Calculator.
-
-    Function to calculate the slip encountered by an induction machine
-    with the parameters specified when the machine is generating peak
-    torque. Uses formula as shown below.
-
-    .. math:: \text{slip} = \frac{R_r}{|Z_{th}|}
-
-    where:
-
-    .. math::
-       Z_{th} = \frac{(R_s+j\omega L_{ls})j\omega L_m}
-       {R_s+j\omega(L_{ls}+L_m)}+j\omega L_{lr}
-
-    Parameters
-    ----------
-    Rr:         float
-                Rotor resistance in ohms
-    Zth:        complex, optional
-                Thevenin-equivalent inductance (in ohms) of the
-                induction machine, may be calculated internally
-                if given machine parameters.
-    Rs:         float, optional
-                Stator resistance in ohms
-    Lm:         float, optional
-                Magnetizing inductance in Henrys
-    Lls:        float, optional
-                Stator leakage inductance in Henrys, default=0
-    Llr:        float, optional
-                Rotor leakage inductance in Henrys, default=0
-    Ls:         float, optional
-                Stator inductance in Henrys
-    Lr:         float, optional
-                Rotor inductance in Henrys
-    freq:       float, optional
-                System (electrical) frequency in Hz, default=60
-    calcX:      bool, optional
-                Control argument to force system to calculate
-                system reactances with system frequency, or to
-                treat them as previously-calculated reactances.
-                default=True
-
-    Returns
-    -------
-    s_peak:     float
-                The peak slip for the induction machine described.
-
-    See Also
-    --------
-    indmachvth:         Induction Machine Thevenin Voltage Calculator
-    indmachzth:         Induction Machine Thevenin Impedance Calculator
-    indmachpem:         Induction Machine Electro-Mechanical Power Calculator
-    indmachtem:         Induction Machine Electro-Mechanical Torque Calculator
-    indmachpktorq:      Induction Machine Peak Torque Calculator
-    indmachiar:         Induction Machine Phase-A Rotor Current Calculator
-    indmachstarttorq:   Induction Machine Starting Torque Calculator
-    """
-    # Condition Inputs
-    w = 2 * _np.pi * freq
-    if Ls != None:  # Use Ls instead of Lls
-        Lls = Ls - Lm
-    if Lr != None:  # Use Lr instead of Llr
-        Llr = Lr - Lm
-    if calcX:  # Convert Inductances to Reactances
-        Lm *= w
-        Lls *= w
-        Llr *= w
-    # Test for Valid Input Set
-    if Zth == None:
-        if not all((Rs, Llr, Lm, Lls)):
-            raise ValueError("Invalid Argument Set, too few provided.")
-        # Valid Argument Set, Calculate Zth
-        Zth = indmachzth(Rs, Lm, Lls, Llr, Ls, Lr, freq, calcX)
-    # Calculate Peak Slip
-    s_peak = Rr / abs(Zth)
-    return (s_peak)
-
-
-# Define Induction Machine Phase-A, Rotor Current Calculator
-def indmachiar(Vth=None, Zth=None, Vas=0, Rs=0, Lm=0, Lls=0,
-               Llr=0, Ls=None, Lr=None, freq=60, calcX=True):
-    r"""
-    Induction Machine Rotor Current Calculator.
-
-    Calculation function to find the phase-A, rotor current for an
-    induction machine given the thevenin voltage and impedance.
-
-    This current is calculated using the following formulas:
-
-    .. math:: I_{a_{\text{rotor}}} = \frac{V_{th}}{|Z_{th}|+Z_{th}}
-
-    where:
-
-    .. math:: V_{th}=\frac{j\omega L_m}{R_s+j\omega(L_{ls}+L_m)}V_{as}
-
-    .. math::
-       Z_{th} = \frac{(R_s+j\omega L_{ls})j\omega L_m}
-       {R_s+j\omega(L_{ls}+L_m)}+j\omega L_{lr}
-
-    .. math:: \omega = \omega_{es} = 2\pi\cdot f_{\text{electric}}
-
-    Parameters
-    ----------
-    Vth:        complex, optional
-                Thevenin-equivalent stator voltage of the
-                induction machine, may be calculated internally
-                if given stator voltage and machine parameters.
-    Zth:        complex, optional
-                Thevenin-equivalent inductance (in ohms) of the
-                induction machine, may be calculated internally
-                if given machine parameters.
-    Vas:        complex, optional
-                Terminal Stator Voltage in Volts
-    Rs:         float, optional
-                Stator resistance in ohms
-    Lm:         float, optional
-                Magnetizing inductance in Henrys
-    Lls:        float, optional
-                Stator leakage inductance in Henrys, default=0
-    Llr:        float, optional
-                Rotor leakage inductance in Henrys, default=0
-    Ls:         float, optional
-                Stator inductance in Henrys
-    Lr:         float, optional
-                Rotor inductance in Henrys
-    freq:       float, optional
-                System (electrical) frequency in Hz, default=60
-    calcX:      bool, optional
-                Control argument to force system to calculate
-                system reactances with system frequency, or to
-                treat them as previously-calculated reactances.
-                default=True
-
-    Returns
-    -------
-    Iar:        complex
-                The rotor, phase-A current in amps.
-
-    See Also
-    --------
-    indmachvth:         Induction Machine Thevenin Voltage Calculator
-    indmachzth:         Induction Machine Thevenin Impedance Calculator
-    indmachpem:         Induction Machine Electro-Mechanical Power Calculator
-    indmachtem:         Induction Machine Electro-Mechanical Torque Calculator
-    indmachpkslip:      Induction Machine Peak Slip Calculator
-    indmachpktorq:      Induction Machine Peak Torque Calculator
-    indmachstarttorq:   Induction Machine Starting Torque Calculator
-    """
-    # Condition Inputs
-    w = 2 * _np.pi * freq
-    if Ls != None:  # Use Ls instead of Lls
-        Lls = Ls - Lm
-    if Lr != None:  # Use Lr instead of Llr
-        Llr = Lr - Lm
-    if p != 0:  # Calculate Sync. Speed from Num. Poles
-        wsyn = w / (p / 2)
-    if calcX:  # Convert Inductances to Reactances
-        Lm *= w
-        Lls *= w
-        Llr *= w
-    # Test for Valid Input Set
-    if Vth == None:
-        if not all((Vas, Rs, Lm, Lls)):
-            raise ValueError("Invalid Argument Set, too few provided.")
-        # Valid Argument Set, Calculate Vth
-        Vth = indmachvth(Vas, Rs, Lm, Lls, Ls, freq, calcX)
-    if Zth == None:
-        if not all((Rs, Llr, Lm, Lls)):
-            raise ValueError("Invalid Argument Set, too few provided.")
-        # Valid Argument Set, Calculate Zth
-        Zth = indmachzth(Rs, Lm, Lls, Llr, Ls, Lr, freq, calcX)
-    # Calculate Rotor Current
-    Iar = Vth / (Zth.real + Zth)
-    return (Iar)
-
-
-# Define Induction Machine Peak Torque Calculator
-def indmachpktorq(Rr, s_pk=None, Iar=None, Vth=None, Zth=None, Vas=0, Rs=0,
-                  Lm=0, Lls=0, Llr=0, Ls=None, Lr=None, freq=60, calcX=True):
-    r"""
-    Induction Machine Peak Torque Calculator.
-
-    Calculation function to find the peak torque for an
-    induction machine given the thevenin voltage and impedance.
-
-    This current is calculated using the following formulas:
-
-    .. math::
-       T_{em}=(|I_{a_{\text{rotor}}}|)^2\cdot\frac{R_r}
-       {\text{slip}_{\text{peak}}}
-
-    where:
-
-    .. math:: I_{a_{\text{rotor}}} = \frac{V_{th}}{|Z_{th}|+Z_{th}}
-
-    .. math:: V_{th}=\frac{j\omega L_m}{R_s+j\omega(L_{ls}+L_m)}V_{as}
-
-    .. math::
-       Z_{th} = \frac{(R_s+j\omega L_{ls})j\omega L_m}
-       {R_s+j\omega(L_{ls}+L_m)}+j\omega L_{lr}
-
-    .. math:: \omega = \omega_{es} = 2\pi\cdot f_{\text{electric}}
-
-    Parameters
-    ----------
-    Rr:         float
-                Rotor resistance in Ohms
-    s_pk:       float, optional
-                Peak induction machine slip, may be calculated
-                internally if remaining machine characteristics are
-                provided.
-    Iar:        complex, optional
-                Phase-A, Rotor Current in Amps, may be calculated
-                internally if remaining machine characteristics are
-                provided.
-    Vth:        complex, optional
-                Thevenin-equivalent stator voltage of the
-                induction machine, may be calculated internally
-                if given stator voltage and machine parameters.
-    Zth:        complex, optional
-                Thevenin-equivalent inductance (in ohms) of the
-                induction machine, may be calculated internally
-                if given machine parameters.
-    Vas:        complex, optional
-                Terminal Stator Voltage in Volts
-    Rs:         float, optional
-                Stator resistance in ohms
-    Lm:         float, optional
-                Magnetizing inductance in Henrys
-    Lls:        float, optional
-                Stator leakage inductance in Henrys, default=0
-    Llr:        float, optional
-                Rotor leakage inductance in Henrys, default=0
-    Ls:         float, optional
-                Stator inductance in Henrys
-    Lr:         float, optional
-                Rotor inductance in Henrys
-    freq:       float, optional
-                System (electrical) frequency in Hz, default=60
-    calcX:      bool, optional
-                Control argument to force system to calculate
-                system reactances with system frequency, or to
-                treat them as previously-calculated reactances.
-                default=True
-
-    Returns
-    -------
-    Tpk:        float
-                Peak torque of specified induction machine in
-                newton-meters.
-
-    See Also
-    --------
-    indmachvth:         Induction Machine Thevenin Voltage Calculator
-    indmachzth:         Induction Machine Thevenin Impedance Calculator
-    indmachpem:         Induction Machine Electro-Mechanical Power Calculator
-    indmachtem:         Induction Machine Electro-Mechanical Torque Calculator
-    indmachpkslip:      Induction Machine Peak Slip Calculator
-    indmachiar:         Induction Machine Phase-A Rotor Current Calculator
-    indmachstarttorq:   Induction Machine Starting Torque Calculator
-    """
-    # Condition Inputs
-    w = 2 * _np.pi * freq
-    if Ls != None:  # Use Ls instead of Lls
-        Lls = Ls - Lm
-    if Lr != None:  # Use Lr instead of Llr
-        Llr = Lr - Lm
-    if p != 0:  # Calculate Sync. Speed from Num. Poles
-        wsyn = w / (p / 2)
-    if calcX:  # Convert Inductances to Reactances
-        Lm *= w
-        Lls *= w
-        Llr *= w
-    # Test for Valid Input Set
-    if Vth == None:
-        if not all((Vas, Rs, Lm, Lls)):
-            raise ValueError("Invalid Argument Set, too few provided.")
-        # Valid Argument Set, Calculate Vth
-        Vth = indmachvth(Vas, Rs, Lm, Lls, Ls, freq, calcX)
-    if Zth == None:
-        if not all((Rs, Llr, Lm, Lls)):
-            raise ValueError("Invalid Argument Set, too few provided.")
-        # Valid Argument Set, Calculate Zth
-        Zth = indmachzth(Rs, Lm, Lls, Llr, Ls, Lr, freq, calcX)
-    if Iar == None:
-        if not all((Vth, Zth)):
-            raise ValueError("Invalid Argument Set, too few provided.")
-        # Valid Argument Set, Calculate Ias
-        Iar = indmachiar(Vth=Vth, Zth=Zth)
-    if s_pk == None:
-        if not all((Rr, Zth)):
-            raise ValueError("Invalid Argument Set, too few provided.")
-        # Valid Argument Set, Calculate Peak Slip
-        s_pk = indmachpkslip(Rr=Rr, Zth=Zth)
-    # Use Terms to Calculate Peak Torque
-    Tpk = abs(Iar) ** 2 * Rr / s_pk
-    return (Tpk)
-
-
-# Define Induction Machine Starting Torque Calculator
-def indmachstarttorq(Rr, Iar=None, Vth=None, Zth=None, Vas=0, Rs=0, Lm=0,
-                     Lls=0, Llr=0, Ls=None, Lr=None, freq=60, calcX=True):
-    r"""
-    Induction Machine Starting Torque Calculator.
-
-    Calculation function to find the starting torque for an
-    induction machine given the thevenin voltage and impedance.
-
-    This current is calculated using the following formulas:
-
-    .. math::
-       T_{em}=(|I_{a_{\text{rotor}}}|)^2\cdot\frac{R_r}
-       {\text{slip}_{\text{peak}}}
-
-    where:
-
-    .. math:: \text{slip} = 1
-
-    .. math::
-       I_{a_{\text{rotor}}} = \frac{V_{th}}{\frac{R_r}{\text{slip}}+Z_{th}}
-
-    .. math:: V_{th}=\frac{j\omega L_m}{R_s+j\omega(L_{ls}+L_m)}V_{as}
-
-    .. math::
-       Z_{th} = \frac{(R_s+j\omega L_{ls})j\omega L_m}
-       {R_s+j\omega(L_{ls}+L_m)}+j\omega L_{lr}
-
-    .. math:: \omega = \omega_{es} = 2\pi\cdot f_{\text{electric}}
-
-    Parameters
-    ----------
-    Rr:         float
-                Rotor resistance in Ohms
-    Iar:        complex, optional
-                Phase-A, Rotor Current in Amps, may be calculated
-                internally if remaining machine characteristics are
-                provided.
-    Vth:        complex, optional
-                Thevenin-equivalent stator voltage of the
-                induction machine, may be calculated internally
-                if given stator voltage and machine parameters.
-    Zth:        complex, optional
-                Thevenin-equivalent inductance (in ohms) of the
-                induction machine, may be calculated internally
-                if given machine parameters.
-    Vas:        complex, optional
-                Terminal Stator Voltage in Volts
-    Rs:         float, optional
-                Stator resistance in ohms
-    Lm:         float, optional
-                Magnetizing inductance in Henrys
-    Lls:        float, optional
-                Stator leakage inductance in Henrys, default=0
-    Llr:        float, optional
-                Rotor leakage inductance in Henrys, default=0
-    Ls:         float, optional
-                Stator inductance in Henrys
-    Lr:         float, optional
-                Rotor inductance in Henrys
-    freq:       float, optional
-                System (electrical) frequency in Hz, default=60
-    calcX:      bool, optional
-                Control argument to force system to calculate
-                system reactances with system frequency, or to
-                treat them as previously-calculated reactances.
-                default=True
-
-    Returns
-    -------
-    Tstart:     float
-                Peak torque of specified induction machine in
-                newton-meters.
-
-    See Also
-    --------
-    indmachvth:         Induction Machine Thevenin Voltage Calculator
-    indmachzth:         Induction Machine Thevenin Impedance Calculator
-    indmachpem:         Induction Machine Electro-Mechanical Power Calculator
-    indmachtem:         Induction Machine Electro-Mechanical Torque Calculator
-    indmachpkslip:      Induction Machine Peak Slip Calculator
-    indmachpktorq:      Induction Machine Peak Torque Calculator
-    indmachiar:         Induction Machine Phase-A Rotor Current Calculator
-    """
-    # Condition Inputs
-    w = 2 * _np.pi * freq
-    if Ls != None:  # Use Ls instead of Lls
-        Lls = Ls - Lm
-    if Lr != None:  # Use Lr instead of Llr
-        Llr = Lr - Lm
-    if p != 0:  # Calculate Sync. Speed from Num. Poles
-        wsyn = w / (p / 2)
-    if calcX:  # Convert Inductances to Reactances
-        Lm *= w
-        Lls *= w
-        Llr *= w
-    # Slip is 1 (one) for starting
-    slip = 1
-    # Test for Valid Input Set
-    if Vth == None:
-        if not all((Vas, Rs, Lm, Lls)):
-            raise ValueError("Invalid Argument Set, too few provided.")
-        # Valid Argument Set, Calculate Vth
-        Vth = indmachvth(Vas, Rs, Lm, Lls, Ls, freq, calcX)
-    if Zth == None:
-        if not all((Rs, Llr, Lm, Lls)):
-            raise ValueError("Invalid Argument Set, too few provided.")
-        # Valid Argument Set, Calculate Zth
-        Zth = indmachzth(Rs, Lm, Lls, Llr, Ls, Lr, freq, calcX)
-    if Iar == None:
-        if not all((Vth, Zth)):
-            raise ValueError("Invalid Argument Set, too few provided.")
-        # Valid Argument Set, Calculate Ias
-        Iar = Vth / (Rr / slip + Zth)
-    # Use Terms to Calculate Peak Torque
-    Tstart = abs(Iar) ** 2 * Rr / slip
-    return (Tstart)
-
-
-# Define Induction Machine Stator Torque Calculator
-def pstator(Pem, slip):
-    r"""
-    Stator Power Calculator for Induction Machine.
-
-    Given the electromechanical power and the slip,
-    this function will calculate the power related to the
-    stator (provided or consumed).
-
-    .. math:: P_s=\frac{P_{em}}{1-\text{slip}}
-
-    Parameters
-    ----------
-    Pem:        float
-                Electromechanical power in watts.
-    slip:       float
-                Slip factor in rad/sec.
-
-    Returns
-    -------
-    Ps:         float
-                Power related to the stator in watts.
-
-    See Also
-    --------
-    protor:         Rotor Power Calculator for Induction Machines
-    """
-    # Calculate and Return
-    Ps = Pem / (1 - slip)
-    return (Ps)
-
-
-# Define Induction Machine Rotor Torque Calculator
-def protor(Pem, slip):
-    r"""
-    Rotor Power Calculator for Induction Machine.
-
-    Given the electromechanical power and the slip,
-    this function will calculate the power related to the
-    rotor (provided or consumed).
-
-    .. math:: P_r=-\text{slip}\cdot\frac{P_{em}}{1-\text{slip}}
-
-    Parameters
-    ----------
-    Pem:        float
-                Electromechanical power in watts.
-    slip:       float
-                Slip factor in rad/sec.
-
-    Returns
-    -------
-    Pr:         float
-                Power related to the rotor in watts.
-
-    See Also
-    --------
-    pstator:         Stator Power Calculator for Induction Machines
-    """
-    # Calculate and Return
-    Pr = -slip * (Pem / (1 - slip))
-    return (Pr)
-
-
 # Define De Calculator for Transmission Lines
 def de_calc(rho, freq=60):
     r"""
     De Transmission Line Value Calculator.
 
     Simple calculator to find the De value for a line
     with particular earth resistivity (rho).
@@ -4106,15 +2682,15 @@
         try:
             rho = RHO_VALUES[rho]
         except KeyError:
             raise ValueError("Invalid Earth Resistivity string try to select \
             from set of (SEA, SWAMP, AVG, AVERAGE, DAMP, DRY, SAND, SANDSTONE")
     # Calculate De
     De = De0 * _np.sqrt(rho / freq)
-    return (De)
+    return De
 
 
 # Define Impedance Per Length Calculator
 def zperlength(Rd=None, Rself=None, Rac=None, Rgwac=None, De=None,
                rho="AVG", Ds=None, Dsgw=None, dia_gw=None, Dab=None,
                Dbc=None, Dca=None, Dagw=None, Dbgw=None, Dcgw=None,
                resolve=True, freq=60):
@@ -4170,23 +2746,23 @@
     freq:       float, optional
                 System frequency in Hertz.
     """
     # Start with Empty Arrays
     Rperlen = 0
     Lperlen = 0
     # Generate Rd
-    if Rd == None:
+    if Rd is None:
         Rd = freq * carson_r
     # Generate Dsgw if Not Provided
-    if Dsgw == None and dia_gw != None:
+    if Dsgw is None and dia_gw is not None:
         Dsgw = _np.exp(-1 / 4) * dia_gw / 2
     # Generate Real Part
     if Rd > 0:
         # Generate Rself if not Provided
-        if Rself == None:
+        if Rself is None:
             # Validate Inputs
             if not all((Rd, Rac)):
                 raise ValueError("Too few arguments")
             Rself = Rac + Rd
         # Generate RperLength Matrix
         Rperlen = _np.array([
             [Rself, Rd, Rd],
@@ -4204,32 +2780,33 @@
             Rperlen = _np.append(Rperlen,
                                  [[Rd, Rd, Rd, Rselfgw]], axis=0)
     # Generate Imaginary Part
     if any((De, Ds, rho)):
         # Validate Inputs
         if not all((Dab, Dbc, Dca)):
             raise ValueError("Distance Terms [Dab,Dbc,Dca] Required")
-        if Ds == None:
+        if Ds is None:
             raise ValueError("Distance Self (Ds) Required")
         # De must be generated
-        if De == None:
-            if rho == None:
+        if De is None:
+            if rho is None:
                 raise ValueError("Too few arguments")
             De = de_calc(rho, freq)
         # Generate LperLength Matrix
         Lperlen = _np.array([
             [_np.log(De / Ds), _np.log(De / Dab), _np.log(De / Dca)],
             [_np.log(De / Dab), _np.log(De / Ds), _np.log(De / Dbc)],
             [_np.log(De / Dca), _np.log(De / Dbc), _np.log(De / Ds)]
         ])
         # Add GW effects If Necessary
         if all((Rgwac, Dsgw, Dagw, Dbgw, Dcgw)):
             # Append Right-Most Column
             Lperlen = _np.append(Lperlen,
-                                 [[_np.log(De / Dagw)], [_np.log(De / Dbgw)], [_np.log(De / Dcgw)]],
+                                 [[_np.log(De / Dagw)], [_np.log(De / Dbgw)],
+                                  [_np.log(De / Dcgw)]],
                                  axis=1)
             # Append New Row
             Lperlen = _np.append(Lperlen,
                                  [[_np.log(De / Dagw), _np.log(De / Dbgw),
                                    _np.log(De / Dcgw), _np.log(De / Dsgw)]], axis=0)
         Lperlen = Lperlen * (1j * u0 * freq)
     # Add Real and Imaginary Parts
@@ -4239,15 +2816,15 @@
         # Perform Slicing to Retrieve Useful Arrays
         Za = Zperlen[:3, :3]
         Zb = Zperlen[:3, 3:4]
         Zc = Zperlen[3:4, :3]
         Zd = Zperlen[3:4, 3:4]
         # Calculate New (3x3) Equivalent Zperlen
         Zperlen = Za - _np.dot(Zb, _np.dot(_np.linalg.inv(Zd), Zc))
-    return (Zperlen)
+    return Zperlen
 
 
 # Define Transposition Matrix Formula
 def transposez(Zeq, fabc=1 / 3, fcab=1 / 3, fbca=1 / 3, linelen=1):
     r"""
     Transmission Matrix Equivalent Transposition Calculator.
 
@@ -4288,17 +2865,18 @@
     Rp = _np.array([
         [0, 0, 1],
         [1, 0, 0],
         [0, 1, 0]
     ])
     # Define Inverse Rp Array
     _Rp = _np.linalg.inv(Rp)
-    Zeq = fabc * Zeq + fcab * (_Rp.dot(Zeq.dot(Rp))) + fbca * (Rp.dot(Zeq.dot(_Rp)))
+    Zeq = fabc * Zeq + fcab * (_Rp.dot(Zeq.dot(Rp))) + \
+        fbca * (Rp.dot(Zeq.dot(_Rp)))
     Zeq = Zeq * linelen
-    return (Zeq)
+    return Zeq
 
 
 # Define GMD Calculator
 def gmd(Ds, *args):
     r"""
     GMD (Geometric Mean Distance) Calculator.
 
@@ -4319,264 +2897,15 @@
     root = len(args) + 1
     # Calculate the Root Term
     gmdx = Ds
     for dist in args:
         gmdx *= dist
     # Apply Root Calculation
     GMD = gmdx ** (1 / root)
-    return (GMD)
-
-
-# Define FOC IM Rated Value Calculator
-def indmachfocratings(Rr, Rs, Lm, Llr=0, Lls=0, Lr=None,
-                      Ls=None, Vdqs=1, Tem=1, wes=1):
-    r"""
-    FOC Ind. Machine Rated Operation Calculator.
-
-    Determines the parameters and characteristics of a Field-
-    Oriented-Controlled Induction Machine operating at its
-    rated limits.
-
-    Parameters
-    ----------
-    Rr:         float
-                Rotor resistance in per-unit-ohms
-    Rs:         float
-                Stator resistance in per-unit-ohms
-    Lm:         float
-                Magnetizing inductance in per-unit-Henrys
-    Llr:        float, optional
-                Rotor leakage inductance in per-unit-Henrys,
-                default=0
-    Lls:        float, optional
-                Stator leakage inductance in per-unit-Henrys,
-                default=0
-    Lr:         float, optional
-                Rotor inductance in per-unit-Henrys
-    Ls:         float, optional
-                Stator inductance in per-unit-Henrys
-    Vdqs:       complex, optional
-                The combined DQ-axis voltage required for rated
-                operation, in per-unit-volts, default=1+j0
-    Tem:        float, optional
-                The mechanical torque required for rated operation,
-                in per-unit-newton-meters, default=1
-    wes:        float, optional
-                The per-unit electrical system frequency, default=1
-
-    Returns
-    -------
-    Idqr:       complex
-                Combined DQ-axis Rotor Current in per-unit-amps
-    Idqs:       complex
-                Combined DQ-axis Stator Current in per-unit-amps
-    LAMdqr:     complex
-                Combined DQ-axis Rotor Flux in per-unit
-    LAMdqs:     complex
-                Combined DQ-axis Stator Flux in per-unit
-    slip_rat:   float
-                Rated Slip as percent of rotational and system frequencies
-    w_rat:      float
-                Rated System frequency in per-unit-rad/sec
-    lamdr_rat:  float
-                Rated D-axis rotor flux in per-unit
-    """
-    # Condition Inputs:
-    if Ls == None:  # Use Lls instead of Ls
-        Ls = Lls + Lm
-    if Lr == None:  # Use Llr instead of Lr
-        Lr = Llr + Lm
-
-    # Define Equations Function as Solver
-    def equations(val):
-        Idr, Iqr, Ids, Iqs, LAMdr, LAMqr, LAMds, LAMqs, wr = val
-        A = (Rs * Ids - wes * LAMqs) - Vdqs
-        B = Rs * Iqs - wes * LAMds
-        C = Rr * Idr - (wes - wr) * LAMqr
-        D = Rr * Iqr + (wes - wr) * LAMdr
-        E = (Ls * Ids + Lm * Idr) - LAMds
-        F = (Ls * Iqs + Lm * Iqr) - LAMqs
-        G = (Lm * Ids + Lr * Idr) - LAMdr
-        H = (Lm * Iqs + Lr * Iqr) - LAMqr
-        I = (Lm / Lr * (LAMdr * Iqs - LAMqr * Ids)) - Tem
-        return (A, B, C, D, E, F, G, H, I)
-
-    # Define Initial Guesses
-    Idr0 = -1
-    Iqr0 = -1
-    Ids0 = 1
-    Iqs0 = 1
-    LAMdr0 = Lm * Ids0 + Lr * Idr0
-    LAMqr0 = Lm * Iqs0 + Lr * Iqr0
-    LAMds0 = Ls * Ids0 + Lm * Idr0
-    LAMqs0 = Ls * Iqs0 + Lm * Iqr0
-    wr = 1
-    # Use Iterative Solver to Find Results
-    Idr, Iqr, Ids, Iqs, LAMdr, LAMqr, LAMds, LAMqs, wr = _fsolve(equations, (
-        Idr0, Iqr0, Ids0, Iqs0, LAMdr0, LAMqr0, LAMds0, LAMqs0, wr))
-    # Calculate Remaining Rating Terms
-    slip_rated = (wes - wr) / wes
-    w_rated = wr
-    lamdr_rated = abs(LAMdr + 1j * LAMqr)
-    return (
-        compose(Idr, Iqr),
-        compose(Ids, Iqs),
-        compose(LAMdr, LAMqr),
-        compose(LAMds, LAMqs),
-        slip_rated,
-        w_rated,
-        lamdr_rated
-    )
-
-
-# Define FOC IM Control Equation Evaluation Function
-def imfoc_control(Tem_cmd, LAMdr_cmd, wr_cmd, Rr, Rs, Lm,
-                  Llr=0, Lls=0, Lr=None, Ls=None, s_err=0):
-    """
-    FOC Ind. Machine Rated Operation Calculator.
-
-    Determines the parameters and characteristics of a Field-
-    Oriented-Controlled Induction Machine operating at its
-    rated limits.
-
-    Parameters
-    ----------
-    Tem_cmd:    float
-                Mechanical torque setpoint in per-unit-newton-meters
-    LAMdr_cmd:  float
-                D-axis flux setpoint in per-unit
-    wr_cmd:     float
-                Mechanical (rotor) speed in per-unit-rad/sec
-    Rr:         float
-                Rotor resistance in per-unit-ohms
-    Rs:         float
-                Stator resistance in per-unit-ohms
-    Lm:         float
-                Magnetizing inductance in per-unit-Henrys
-    Llr:        float, optional
-                Rotor leakage inductance in per-unit-Henrys,
-                default=0
-    Lls:        float, optional
-                Stator leakage inductance in per-unit-Henrys,
-                default=0
-    Lr:         float, optional
-                Rotor inductance in per-unit-Henrys
-    Ls:         float, optional
-                Stator inductance in per-unit-Henrys
-    s_err:      float, optional
-                Error in slip calculation as a percent (e.g. 0.25),
-                default=0
-
-    Returns
-    -------
-    Vdqs:       complex
-                Combined DQ-axis Stator Voltage in per-unit volts
-    Idqr:       complex
-                Combined DQ-axis Rotor Current in per-unit-amps
-    Idqs:       complex
-                Combined DQ-axis Stator Current in per-unit-amps
-    LAMdqr:     complex
-                Combined DQ-axis Rotor Flux in per-unit
-    LAMdqs:     complex
-                Combined DQ-axis Stator Flux in per-unit
-    wslip:      float
-                Machine Slip frequency in per-unit-rad/sec
-    wes:        float
-                The electrical system frequency in per-unit-rad/sec
-    """
-    # Condition Inputs:
-    if Ls == None:  # Use Lls instead of Ls
-        Ls = Lls + Lm
-    if Lr == None:  # Use Llr instead of Lr
-        Lr = Llr + Lm
-    # Calculate Additional Constraints
-    sigma = (1 - Lm ** 2 / (Ls * Lr))
-    accuracy = 1 + s_err
-    # Command Values (Transient and Steady State)
-    Ids = LAMdr_cmd / Lm
-    Iqs = Tem_cmd / ((Lm / Lr) * LAMdr_cmd)
-    wslip = Rr / (Lr * accuracy) * (Lm * Iqs) / LAMdr_cmd
-    wes = wslip + wr_cmd
-    # Stator dq Voltages (Steady State)
-    Vds = Rs * Ids - wes * sigma * Ls * Iqs
-    Vqs = Rs * Iqs - wes * Ls * Ids
-    # Remaining Steady State
-    Iqr = -Lm / Lr * Iqs
-    Idr = 0
-    LAMqr = 0
-    LAMqs = sigma * Ls * Iqs
-    LAMds = Ls * Ids
-    return (
-        compose(Vds, Vqs),
-        compose(Idr, Iqr),
-        compose(Ids, Iqs),
-        compose(LAMdr_cmd, LAMqr),
-        compose(LAMds, LAMqs),
-        wslip,
-        wes
-    )
-
-
-# Define Synch. Machine Eq Calculator
-def synmach_Eq(Vt_pu, Itmag, PF, Ra, Xd, Xq):
-    # noqa: D401   "Synchronous" is an intentional descriptor
-    r"""
-    Synchronous Machine Eq Calculator.
-
-    Given specified parameter set, will calculate
-    the internal voltage on the q-axis (Eq).
-
-    .. math:: E_q=V_{t_{pu}}-\left[R_a\cdot I_{t_{pu}}+
-       j\cdot X_q\cdot I_{t_{pu}}+j(X_d-X_q)\cdot I_{ad}\right]
-
-    where:
-
-    .. math:: I_{t_{pu}}=I_{t_{mag}}\cdot e^{-j(
-       \angle{V_{t_{pu}}}-\cos^{-1}(PF))}
-
-    .. math:: \theta_q=\angle{V_{t_{pu}}-\left(R_a
-       I_{t_{pu}}+j\cdot X_qI_{t_{pu}}\right)
-
-    .. math:: I_{ad}=\left|I_{t_{pu}}\cdot\sin(
-       -\cos^{-1}(PF)+\theta_q)\right|e^{j(\theta_q
-       -90°)}
-
-    Parameters
-    ----------
-    Vt_pu:      complex
-                Terminal voltage in per-unit-volts
-    Itmag:      float
-                Terminal current magnitude in per-
-                unit-amps
-    PF:         float
-                Machine Power Factor, (+)ive values denote
-                leading power factor, (-)ive values denote
-                lagging power factor
-    Ra:         float
-                AC resistance in per-unit-ohms
-    Xd:         float
-                D-axis reactance in per-unit-ohms
-    Xq:         float
-                Q-axis reactance in per-unit-ohms
-
-    Returns
-    -------
-    Eq:         complex
-                Internal Synchronous Machine Voltage
-                in per-unit-volts
-    """
-    # Calculate Required Terms
-    phi = _np.arccos(PF)
-    Itmag = abs(Itmag)
-    It_pu = Itmag * _np.exp(-1j * (_np.angle(Vt_pu) + phi))
-    th_q = _np.angle(Vt_pu - (Ra * It_pu + 1j * Xq * It_pu))
-    Iad = (abs(It_pu) * _np.sin(phi + th_q)) * _np.exp(1j * (th_q - _np.pi / 2))
-    # Calculate Eq
-    Eq = Vt_pu - (Ra * It_pu + 1j * Xq * It_pu + 1j * (Xd - Xq) * Iad)
-    return (Eq)
+    return GMD
 
 
 # Define Power-Factor Voltage/Current Relation
 def vipf(V=None, I=None, PF=1, find=''):
     """
     Voltage / Current / Power Factor Solver.
 
@@ -4603,14 +2932,24 @@
                 System voltage (in volts), default=None
     I:          complex
                 System current (in amps), default=None
     PF:         float
                 System power factor, (+)ive values denote
                 leading power factor, (-)ive values denote
                 lagging poer factor; default=1
+
+    Examples
+    --------
+    >>> import electricpy as ep
+    >>> # Demonstrate the generic functionality
+    >>> ep.vipf(V=480, I=ep.phasors.phasor(20, 120))
+    (480, (-9.999999999999996+17.320508075688775j), -0.499999...)
+    >>> # Find the power factor
+    >>> ep.vipf(V=480, I=ep.phasors.phasor(20, 120), find="PF")
+    -0.49999...
     """
     # Test to find Voltage
     if isinstance(V, float) and isinstance(I, complex):
         phi = -_np.sign(PF) * _np.arccos(PF)
         V = V * _np.exp(-1j * phi)
     # Test to find Current
     elif isinstance(V, complex) and isinstance(I, float):
@@ -4622,25 +2961,24 @@
         PF = _np.cos(phi)
     # Failed Mode
     else:
         raise ValueError("All values must be provided.")
     # Return
     find = find.upper()
     if find == 'V':
-        return (V)
-    elif find == 'I':
-        return (I)
-    elif find == 'PF':
-        return (PF)
-    else:
-        return (V, I, PF)
+        return V
+    if find == 'I':
+        return I
+    if find == 'PF':
+        return PF
+    return V, I, PF
 
 
 # Define Synchronous Speed Calculator
-def syncspeed(Npol, freq=60, Hz=False):
+def syncspeed(Npol, freq=60, Hz=False, rpm=False):
     # noqa: D401   "Synchronous" is an intentional descriptor
     r"""
     Synchronous Speed Calculator Function.
 
     Simple method of calculating the synchronous speed of an induction machine
     given the number of poles in the machine's construction, and
     the machine's operating electrical frequency.
@@ -4652,25 +2990,33 @@
     ----------
     Npol:       int
                 Number of electrical poles in machine's construction.
     freq:       float, optional
                 Frequency of electrical system in Hertz, default=60
     Hz:         bool, optional
                 Boolean control to enable return in Hertz. default=False
+    rpm:        bool, optional
+                Boolean control to enable return in rpm. default=False
+
 
     Returns
     -------
     wsyn:       float
                 Synchronous Speed of Induction Machine, defaults to units of
-                rad/sec, but may be set to Hertz if `Hz` set to True.
+                rad/sec, but may be set to Hertz or RPM if `Hz` or `rpm` set to True.
     """
+    if Npol == 0:
+        raise ZeroDivisionError("Poles of an electrical machine \
+        can not be zero")
     wsyn = 2 * _np.pi * freq / (Npol / 2)
     if Hz:
-        return (wsyn / (2 * _np.pi))
-    return (wsyn)
+        return (2*freq / (Npol))
+    if rpm:
+        return (120 * freq)/(Npol)
+    return wsyn
 
 
 # Define Machine Slip Calculation Function
 def machslip(mech, syn=60):
     r"""
     Machine Slip Calculator.
 
@@ -4690,15 +3036,15 @@
 
     Returns
     -------
     slip:       float
                 The rotating machine's slip constant.
     """
     slip = (syn - mech) / syn
-    return (slip)
+    return slip
 
 
 # Define 3-Phase Valpha Calculator
 def phs3valpha(VA, VB=0, VC=0):
     r"""
     Three-Phase V-Alpha Calculator.
 
@@ -4719,28 +3065,29 @@
     Returns
     -------
     Valpha:     [float, complex]
                 Alpha-voltage as calculated from input three-phase voltages.
                 Matches type of inputs.
     """
     # Handle Combined (list/tuple) Input
-    if (isinstance(VA, (tuple, list)) and VB == 0 and VC == 0):
+    if isinstance(VA, (tuple, list)) and VB == 0 and VC == 0:
         if len(VA) != 3:
             raise ValueError("Invalid input set, must "
                              "be list of three elements, three inputs,"
                              " or three array-like objects of equal "
                              "length.")
         Valpha = VA[0] - VA[1] / 2 - VA[2] / 2
     # Handle Separated Inputs
     else:
         Valpha = VA - VB / 2 - VC / 2
     # Return the Alpha-Voltage
-    return (Valpha)
+    return Valpha
 
-def wireresistance(length=None,diameter=None,rho=16.8*10**-9,R=None):
+
+def wireresistance(length=None, diameter=None, rho=16.8 * 10 ** -9, R=None):
     r"""
     Wire Resistance Calculator.
 
     Enter three values to calculate the remaing one. Even though every variable
     is unitless, please use the International System of Units.
 
     .. math:: R = \frac{\rho*l}{A}
@@ -4749,46 +3096,47 @@
     ----------
     length:     [float], optional
                 Wire length, unitless
     diameter:   [float], optional
                 Wire diameter, unitless.
     rho:        [float], optional
                 Material resistivity, unitless
-                Default value is copper resistivity: 16.8*10-9 
+                Default value is copper resistivity: 16.8*10-9
     R:          [float], optional
                 Wire resistance, unitless.
 
     Returns
     -------
     length:     [float], optional
                 Wire length, unitless
     diameter:   [float], optional
                 Wire diameter, unitless.
     rho:        [float], optional
                 Material resistivity, unitless
-                Default value is copper resistivity: 16.8*10-9 
+                Default value is copper resistivity: 16.8*10-9
     R:          [float], optional
                 Wire resistance, unitless.
     """
-    if R == length == diameter == None:
+    if R == length == diameter is None:
         raise ValueError("To few arguments.")
     # Given length and diameter
-    if length != None and diameter != None:
+    if length is not None and diameter is not None:
         # calculating the area
-        A = pi*( diameter ** 2 ) / 4
-        return rho*length/A
+        A = pi * (diameter ** 2) / 4
+        return rho * length / A
     # Given resistance and diameter
-    elif R != None and diameter != None:
+    if R is not None and diameter is not None:
         # calculating the area
-        A = pi*( diameter ** 2 ) / 4
-        return R*A/rho
+        A = pi * (diameter ** 2) / 4
+        return R * A / rho
     # Given resistance and length
-    elif R != None and length != None:
-        A = rho*length/R
-        return _np.sqrt(4*A/pi)
+    if R is not None and length is not None:
+        A = rho * length / R
+        return _np.sqrt(4 * A / pi)
+
 
 def parallel_plate_capacitance(A=None, d=None, e=e0, C=None):
     r"""
     Parallel-Plate Capacitance Calculator.
 
     Enter three values to calculate the remaing one. Even though every variable
     is unitless, please use the International System of Units.
@@ -4815,25 +3163,26 @@
         Distance between the plates, unitless.
     e:  float, optional
         Permitivity of the dielectric, unitless.
         Default value is the permittivity of free space: 8.854E-12
     C:  float, optional
         Capacitance, unitless.
     """
-    if C == A == d == None:
+    if C == A == d is None:
         raise ValueError("To few arguments.")
     # Given area and distance
-    if A != None and d != None:
-        return e*A/d
+    if A is not None and d is not None:
+        return e * A / d
     # Given capacitance and distance
-    elif C != None and d != None:
-        return d*C/e
+    if C is not None and d is not None:
+        return d * C / e
     # Given capacitance and area
-    elif C != None and A != None:
-        return e*A/C
+    if C is not None and A is not None:
+        return e * A / C
+
 
 def solenoid_inductance(A=None, l=None, N=None, u=u0, L=None):
     r"""
     Solenoid Inductance Calculator.
 
     Enter four values to calculate the remaing one. Even though every variable
     is unitless, please use the International System of Units.
@@ -4864,217 +3213,345 @@
         Number of turns, unitless.
     u:  float, optional
         Core permeability, unitless.
         Default value is the permeability of free space: 4πE-7
     L:  float, optional
         Inductance, unitless.
     """
-    if L == A == l == N == None:
+    if L == A == l == N is None:
         raise ValueError("To few arguments.")
     # Given area, length and number of turns
-    if A != None and l != None and N != None:
-        return N**2*u*A/l
+    if A is not None and l is not None and N is not None:
+        return N ** 2 * u * A / l
     # Given inductance, length and number of turns
-    elif L != None and l != None and N != None:
-        return L*l/(N**2*u)
+    if L is not None and l is not None and N is not None:
+        return L * l / (N ** 2 * u)
     # Given inductance, area and number of turns
-    elif L != None and A != None and N != None:
-        return N**2*u*A/L
+    if L is not None and A is not None and N is not None:
+        return N ** 2 * u * A / L
     # Given inductance, area and length
-    elif L != None and A != None and l != None:
-        return _np.sqrt(L*l/(u*A))
-        
-def ic_555_astable(R=None,C=None,freq=None,t_high=None,t_low=None):
+    if L is not None and A is not None and l is not None:
+        return _np.sqrt(L * l / (u * A))
+
+
+def ic_555_astable(R=None, C=None, freq=None, t_high=None, t_low=None):
     """
     555 Integrated Circuit Calculator.
-    
+
     Evaluate a number of common attributes related to the common 555 integrated
     circuit including time period, frequency, duty cycle, time spent low during
     each cycle, time spent high during each cycle.
 
     TODO: This function should be broken into multiple smaller functions.
-    
+
     Parameters
-    ---------- 
+    ----------
     R:      list[float, float] or tuple(float, float), optional
             List of 2 resistor which are need in configuring IC 555.
     C:      float, optional
             Capacitance between Threshold Pin and ground
     f:      float, optional
-            Electrical system frequency in Hertz. 
+            Electrical system frequency in Hertz.
     t_high: float, optional
-            ON time of IC 555 
+            ON time of IC 555
     t_low:  float, optional
-            OFF time of IC 555 
-    
-    Returns 
-    ------- 
-    dict:   "time_period": Time period of oscillating IC 555 
-            "frequency": frequency of oscilation of IC 555 
+            OFF time of IC 555
+
+    Returns
+    -------
+    dict:   "time_period": Time period of oscillating IC 555
+            "frequency": frequency of oscilation of IC 555
             "duty_cycle": ration between ON time and total time
-            "t_low": ON time of IC 555 
-            "t_high": OFF time of IC 555 
+            "t_low": ON time of IC 555
+            "t_high": OFF time of IC 555
     """
-    if R!=None and C!=None:
+    if R is not None and C is not None:
         if len(R) != 2:
             raise ValueError(
                 "Monostable 555 IC will have only 2 resitances to be fixed "
                 f"but {len(R)} were given"
             )
 
         [R1, R2] = R
 
-        T = _np.log(2)*C*(R1+2*R2)
-        freq = 1/T
-        t_low = _np.log(2)*C*R2
-        t_high = _np.log(2)*C*(R1+R2)
-        duty_cycle = t_high*100/T
+        T = _np.log(2) * C * (R1 + 2 * R2)
+        freq = 1 / T
+        t_low = _np.log(2) * C * R2
+        t_high = _np.log(2) * C * (R1 + R2)
+        duty_cycle = t_high * 100 / T
 
         return {
-            'time_period':T,
-            'frequency':freq,
-            'duty_cycle':duty_cycle,
-            't_low':t_low,
-            't_high':t_high
+            'time_period': T,
+            'frequency': freq,
+            'duty_cycle': duty_cycle,
+            't_low': t_low,
+            't_high': t_high
         }
-    
-    elif t_high!=None and t_low!=None and C!=None:
 
-        x2 = t_low/C*_np.log(2)
-        x1 = t_high/C*_np.log(2)
-        T = t_high+t_low
-        freq = 1/(T)
-        duty_cycle = t_high/(T)
+    if t_high is not None and t_low is not None and C is not None:
+
+        x2 = t_low / C * _np.log(2)
+        x1 = t_high / C * _np.log(2)
+        T = t_high + t_low
+        freq = 1 / (T)
+        duty_cycle = t_high / (T)
 
         return {
-            'time_period':T,
-            'frequency':freq,
-            'duty_cycle':duty_cycle,
-            'R1':x1-x2,
-            'R2':x2
+            'time_period': T,
+            'frequency': freq,
+            'duty_cycle': duty_cycle,
+            'R1': x1 - x2,
+            'R2': x2
         }
-    else:
-        raise TypeError("Not enough parqmeters are passed")
-            
-def ic_555_monostable(R=None,C=None,freq=None,t_high=None,t_low=None):
+    raise TypeError("Not enough parqmeters are passed")
+
+
+def ic_555_monostable(R=None, C=None, freq=None, t_high=None, t_low=None):
     """
     555 Integrated Circuit Calculator.
-    
+
     Evaluate a number of common attributes related to the common 555 integrated
     circuit including time period, frequency, duty cycle, time spent low during
     each cycle, time spent high during each cycle.
 
     TODO: This function should be broken into multiple smaller functions.
-    
+
     Parameters
-    ---------- 
+    ----------
     R:      list[float, float] or tuple(float, float), optional
             List of 2 resistor which are need in configuring IC 555.
     C:      float, optional
             Capacitance between Threshold Pin and ground
     f:      float, optional
-            Electrical system frequency in Hertz. 
+            Electrical system frequency in Hertz.
     t_high: float, optional
-            ON time of IC 555 
+            ON time of IC 555
     t_low:  float, optional
-            OFF time of IC 555 
-    
-    Returns 
-    ------- 
-    dict:   "time_period": Time period of oscillating IC 555 
-            "frequency": frequency of oscilation of IC 555 
+            OFF time of IC 555
+
+    Returns
+    -------
+    dict:   "time_period": Time period of oscillating IC 555
+            "frequency": frequency of oscilation of IC 555
             "duty_cycle": ration between ON time and total time
-            "t_low": ON time of IC 555 
-            "t_high": OFF time of IC 555 
+            "t_low": ON time of IC 555
+            "t_high": OFF time of IC 555
     """
-    T = t_high+t_low
+    T = t_high + t_low
     if R is None:
-        try:
-            assert C!=None and T!=None
-        except AssertionError:
+        if not (C is not None and T is not None):
             raise ValueError(
                 "To find Resitance, Capacitance and delay time should be "
                 "provided"
             )
-        return T/(_np.log(3)*C)
-    elif C is None:
-        try:
-            assert R!=None and T!=None
-        except AssertionError:
+        return T / (_np.log(3) * C)
+    if C is None:
+        if not (R is not None and T is not None):
             raise ValueError(
                 "To find Capacitance , Resistance and delay time should be "
                 "provided"
             )
-        return T/(_np.log(3)*R)
-
-    elif T is None:
+        return T / (_np.log(3) * R)
 
-        try:
-            assert R!=None and T!=None
-        except AssertionError:
+    if T is None:
+        if not (R is not None and T is not None):
             raise ValueError(
                 "To find Time delay , Resistance and Capacitance should be "
                 "provided"
             )
-        return R*C*_np.log(3)
+        return R * C * _np.log(3)
 
 
 def t_attenuator(Adb, Z0):
     r"""
     T attenuator.
 
-    The T attenuator is a type of attenuator that looks like the letter T. 
-    The T attenuator consists of three resistors. Two of these are connected in 
+    The T attenuator is a type of attenuator that looks like the letter T.
+    The T attenuator consists of three resistors. Two of these are connected in
     series and the other one is connected from between the two other resistors
     to ground. The resistors in series often have the same resistance.
 
     .. math:: R1 = Z0*(\frac{10^{\frac{A_{db}}{20}}-1}{10^{\frac{A_{db}}{20}}+1});
     .. math:: R2 = Z0*(\frac{10^{\frac{A_{db}}{20}}}{10^{\frac{A_{db}}{10}}-1})
 
     .. image:: /static/t-attenuator-circuit.png
 
     Parameters
-    ---------- 
+    ----------
     Adb: float Attenuation in db
     Z0: float Impedence
 
-    Returns 
-    ------- 
+    Returns
+    -------
     R1: float T attenuator R1
     R2: float T attenuator R2
     """
-    x = Adb/20
+    x = Adb / 20
+
+    R1 = Z0 * (_np.power(10, x) - 1) / (_np.power(10, x) + 1)
+    R2 = 2 * Z0 * _np.power(10, x) / (_np.power(10, 2 * x) - 1)
 
-    R1 = Z0*(_np.power(10, x)-1)/(_np.power(10, x)+1)
-    R2 = 2*Z0*_np.power(10, x)/(_np.power(10, 2*x)-1)
+    return R1, R2
 
-    return R1,R2
 
 def pi_attenuator(Adb, Z0):
     r"""
     Pi attenuator.
 
     The Pi attenuator is a type of attenuator that looks like the Greek letter π.
-    The Pi attenuator consists of three resistors. One of these is connected in series and 
+    The Pi attenuator consists of three resistors. One of these is connected in series and
     the other two are connected in parallel to ground. The parallel resistors often have the same resistance.
 
     .. math:: R1 = Z0*(\frac{10^{\frac{A_{db}}{20}}+1}{10^{\frac{A_{db}}{20}}-1})
     .. math:: R2 = \frac{Z0}{2}*(10^{\frac{A_{db}}{20}} - \frac{1}{10^{\frac{A_{db}}{20}}})
     .. image:: /static/pi-attenuator-circuit.png
 
     Parameters
-    ---------- 
+    ----------
     Adb: float Attenuation in db
     Z0: float Impedence
 
-    Returns 
-    ------- 
+    Returns
+    -------
     R1: float π attenuator R1
     R2: float π attenuator R2
     """
-    x = Adb/20
+    x = Adb / 20
+
+    R1 = Z0 * (_np.power(10, x) + 1) / (_np.power(10, x) - 1)
+    R2 = (Z0 / 2) * (_np.power(10, x) - (1 / (_np.power(10, x))))
+
+    return R1, R2
+
+
+# Calculate Zener Diode Resistor
+def zener_diode_required_resistor(Vin, Vo, I):
+    r"""
+    Zener diode required resistance function .
+
+    A zener diode is uses to allow current to flow "backwards" when the zener
+    voltage is reached. This function use to calculate the required resistor
+    value following below formula:
+
+    .. math:: R = \frac{V_{in(min)} - V_{out}}{I_{load}+0.01}
+
+    .. image:: /static/zenerdiode.png
+
+    Parameters
+    ----------
+    Vin:        float
+                Minimum input Voltage in Volt
+    Vo:         float
+                Output Voltage in Volt
+    I:          float
+                Load Current in Ampere
+
+    Returns
+    -------
+    R:          float
+                Load Resistance in Ohm
+    """
+    # Solve Load Resistance
+    R = (Vin - Vo) / (I+0.01)
+    return (R)
+
+# Calculate Zener Diode Power
+
+
+def zener_diode_power(Vin, Vo, R):
+    r"""
+    Zener diode power loss function.
+
+    A zener diode is uses to allow current to flow "backwards" when the zener
+    voltage is reached. This function use to calculate the power in resistor
+    following below formula:
+
+    .. math:: P_R = \frac{(V_{out} - V_{in(max)})^2}{R}
 
-    R1 = Z0*(_np.power(10, x)+1)/(_np.power(10, x)-1)
-    R2 = (Z0/2)*(_np.power(10, x) - (1/(_np.power(10, x))))
+    .. image:: /static/zenerdiode.png
+
+    Parameters
+    ----------
+    Vin:        float
+                Maximum input Voltage in Volt
+    Vo:         float
+                Output Voltage in Volt
+    R:          float
+                Load Resistance in Ohm
+
+    Returns
+    -------
+    P:          float
+                Power on resistance in Watt
+    """
+    # Validate Inputs
+    if R == 0:
+        raise ValueError("Resistance Value can not be zero")
+
+    # Solve Load Resistance
+    P = ((Vo - Vin) ** 2) / R
+    return (P)
+
+
+def lm317(r1, r2, v_out):
+    r"""
+    LM317 linear voltage regulator solver.
+
+    The LM317 is a linear voltage regulator that can be adjusted to supply a
+    specific output voltage. The LM317 has three pins, adjust, output and input.
+    The LM317 is often connected as in the image below. [1]_
+
+
+    .. image:: https://www.basictables.com/media/lm317-circuit.png
+
+
+    Formula to Calculate Output Voltage, R1, R2:
+
+    .. math:: V_{out} = 1.25 * (1+\frac{R2}{R1})
+
+    .. math:: R1 = \frac{1.25*R2}{V_{out}-1.25}
+
+    .. math:: R2 = \frac{R1*V_{out}}{1.25 - R1}
+
+    Parameters
+    ----------
+    v_out: float, Optional
+           Output Voltage in LM317 in Volts
+    r1:    float, Optional
+           r1 is resistance and is measured in ohm
+    r2:    float, Optional
+           r2 is resistance and is measured in ohm
+
+    Returns
+    -------
+    v_out: float
+           v_out is the output voltage and is measured in volt (V)
+    r1:    float
+           r1 is resistance and is measured in ohm
+    r2:    float
+           r2 is resistance and is measured in ohm
+
+
+    .. [1] Electronial, "LM317" BasicTables, Accessed May, 2022
+       https://www.basictables.com/electronics/lm317
+    """
+    if r1 is not None and r2 is not None:
+        # Returns Voltage
+        return 1.25 * (1 + (r2 / r1))
+
+    if r2 is not None and v_out is not None:
+        # Returns R1
+        return (1.25 * r2) / (v_out - 1.25)
+
+    if r1 is not None and v_out is not None:
+        # Returns R2
+        return ((r1 * v_out) / 1.25) - r1
+
+    raise ValueError("Invalid arguments")
+
+
+# Define Module Specific Variables
+_name_ = NAME
+_version_ = VERSION
+__version__ = _version_  # Alias Version for User Ease
 
-    return R1,R2
 # END OF FILE
```

### Comparing `electricpy-0.2.2/electricpy/bode.py` & `electricpy-0.3.0/electricpy/bode.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,63 +1,64 @@
 ################################################################################
 """
-`electricpy.bode`  -  Bode Plotting Module.
+Bode Plotting Functionality for ElectricPy Package.
 
 >>> from electricpy import bode
 """
 ################################################################################
 
-# Import External Dependencies
+from cmath import exp as _exp
+
+
 import matplotlib.pyplot as _plt
 import numpy as _np
 import scipy.signal as _sig
 from numpy import pi as _pi
-from cmath import exp as _exp
 
-# Import Local Dependencies
 from electricpy.math import convolve
 
 # Define System Conditioning Function
-def _sys_condition(system,feedback):
-    if ( len(system) == 2 ):        # System found to be num and den
+def _sys_condition(system, feedback):
+    if len(system) == 2:  # System found to be num and den
         num = system[0]
         den = system[1]
         # Convolve numerator or denominator as needed
-        if (str(type(num)) == tuple):
-            num = convolve(num)        # Convolve terms in numerator
-        if (str(type(den)) == tuple):
-            den = convolve(den)        # Convolve terms in denominator
-        if feedback: # If asked to add the numerator to the denominator
-            ld = len(den) # Length of denominator
-            ln = len(num) # Length of numerator
-            if(ld > ln):
-                num = _np.append(_np.zeros(ld-ln),num) # Pad beginning with zeros
-            if(ld < ln):
-                den = _np.append(_np.zeros(ln-ld),den) # Pad beginning with zeros
-            den = den + num # Add numerator and denominator
-        for i in range( len( num ) ):
-            if (num[i] != 0):
-                num = num[i:]        # Slice zeros off the front of the numerator
-                break                 # Break out of for loop
-        for i in range( len( den ) ):
-            if (den[i] != 0):
-                den = den[i:]        # Slice zeros off the front of the denominator
-                break                 # Break out of for loop
-        system = (num,den)  # Repack system
-    return(system) # Return the conditioned system
+        if str(type(num)) == tuple:
+            num = convolve(num)  # Convolve terms in numerator
+        if str(type(den)) == tuple:
+            den = convolve(den)  # Convolve terms in denominator
+        if feedback:  # If asked to add the numerator to the denominator
+            ld = len(den)  # Length of denominator
+            ln = len(num)  # Length of numerator
+            if ld > ln:
+                num = _np.append(_np.zeros(ld - ln), num)  # Pad beginning with zeros
+            if ld < ln:
+                den = _np.append(_np.zeros(ln - ld), den)  # Pad beginning with zeros
+            den = den + num  # Add numerator and denominator
+        for i in range(len(num)):
+            if num[i] != 0:
+                num = num[i:]  # Slice zeros off the front of the numerator
+                break  # Break out of for loop
+        for i in range(len(den)):
+            if den[i] != 0:
+                den = den[i:]  # Slice zeros off the front of the denominator
+                break  # Break out of for loop
+        system = (num, den)  # Repack system
+    return system  # Return the conditioned system
+
 
 # Define System Bode Plotting Function
-def bode(system,mn=0.001,mx=1000,npts=100,title="",xlim=False,ylim=False,sv=False,
-         disp3db=False,lowcut=None,magnitude=True,angle=True,freqaxis="rad"):
+def bode(system, mn=0.001, mx=1000, npts=100, title="", xlim=False, ylim=False, sv=False,
+         disp3db=False, lowcut=None, magnitude=True, angle=True, freqaxis="rad"):
     """
     System Bode Plotting Function.
-    
+
     A simple function to generate the Bode Plot for magnitude
     and frequency given a transfer function system.
-    
+
     Parameters
     ----------
     system:         transfer function object
                     The Transfer Function; can be provided as the following:
                     - 1 (instance of lti)
                     - 2 (num, den)
                     - 3 (zeros, poles, gain)
@@ -90,83 +91,88 @@
     angle:          bool, optional
                     Control argument to enable plotting of angle, default=True
     freqaxis:       string, optional
                     Control argument to specify the freqency axis in degrees or
                     radians, default is radians (rad)
     """
     # Condition system input to ensure proper execution
-    system = _sys_condition(system,False)
-    
+    system = _sys_condition(system, False)
+
     # Condition min and max freq terms
     degrees = False
-    if freqaxis.lower().find("deg") != -1: # degrees requested
+    if freqaxis.lower().find("deg") != -1:  # degrees requested
         degrees = True
         # Scale Degrees to Radians for calculation
-        mn = 2*_np.pi*mn
-        mx = 2*_np.pi*mx
-    mn = _np.log10(mn) # find the _exponent value
-    mx = _np.log10(mx) # find the _exponent value
-    
+        mn = 2 * _np.pi * mn
+        mx = 2 * _np.pi * mx
+    mn = _np.log10(mn)  # find the _exponent value
+    mx = _np.log10(mx)  # find the _exponent value
+
     # Generate the frequency range to calculate over
-    wover = _np.logspace(mn,mx,npts)
-    
+    wover = _np.logspace(mn, mx, npts)
+
     # Calculate the bode system
     w, mag, ang = _sig.bode(system, wover)
-    
-    # Plot Magnitude
-    if(magnitude):
-        magTitle = "Magnitude "+title
-        _plt.title(magTitle)
-        if degrees: # Plot in degrees
-            _plt.plot(w/(2*_np.pi), mag)
+
+    def _plot(plot_title, y_label):
+        _plt.title(plot_title)
+        _plt.ylabel(y_label)
+        if degrees:  # Plot in degrees
+            _plt.plot(w / (2 * _np.pi), ang)
             _plt.xlabel("Frequency (Hz)")
-        else: # Plot in radians
-            _plt.plot(w, mag)
+        else:  # Plot in radians
+            _plt.plot(w, ang)
             _plt.xlabel("Frequency (rad/sec)")
         _plt.xscale("log")
         _plt.grid(which="both")
-        _plt.ylabel("Magnitude (dB)")
-        if disp3db:
-            _plt.axhline(-3)
-        if lowcut!=None:
-            _plt.axhline(lowcut)
-        if xlim!=False:
+        if xlim:
             _plt.xlim(xlim)
-        if ylim!=False:
+        if ylim:
             _plt.ylim(ylim)
         if sv:
-            _plt.savefig(magTitle+".png")
+            _plt.savefig(title + ".png")
+
+    # Plot Magnitude
+    if magnitude:
+        magTitle = "Magnitude " + title
+        _plot(magTitle, "Magnitude (DB)")
+        if disp3db:
+            _plt.axhline(-3)
+        if lowcut is not None:
+            _plt.axhline(lowcut)
         _plt.show()
 
     # Plot Angle
-    if(angle):
-        angTitle = "Angle "+title
-        _plt.title(angTitle)
-        if degrees: # Plot in degrees
-            _plt.plot(w/(2*_np.pi), ang)
-            _plt.xlabel("Frequency (Hz)")
-        else: # Plot in radians
-            _plt.plot(w, ang)
-            _plt.xlabel("Frequency (rad/sec)")
-        _plt.xscale("log")
-        _plt.grid(which="both")
-        _plt.ylabel("Angle (degrees)")
-        if xlim!=False:
-            _plt.xlim(xlim)
-        if ylim!=False:
-            _plt.ylim(ylim)
-        if sv:
-            _plt.savefig(angTitle+".png")
+    if angle:
+        angTitle = "Angle " + title
+        _plot(angTitle, "Angle (degrees)")
         _plt.show()
 
-def sbode(f,NN=1000,title="",xlim=False,ylim=False,mn=0,mx=1000,
-          sv=False,disp3db=False,lowcut=None,magnitude=True,angle=True):
+
+def _magnitude_plot(title, disp3db, lowcut, xlim, ylim, sv):
+    _plt.title(title + " Magnitude")
+    _plt.grid(which='both')
+    if disp3db:
+        _plt.axhline(-3)
+    if lowcut is not None:
+        _plt.axhline(lowcut)
+    if xlim:
+        _plt.xlim(xlim)
+    if ylim:
+        _plt.ylim(ylim)
+    if sv:
+        _plt.savefig(title + " Magnitude.png")
+    _plt.show()
+
+
+def sbode(f, NN=1000, title="", xlim=False, ylim=False, mn=0, mx=1000,
+          sv=False, disp3db=False, lowcut=None, magnitude=True, angle=True):
     """
     S-Domain Bode Plotting Function.
-    
+
     Parameters
     ----------
     f:              function
                     The Input Function, must be callable function object.
     NN:             int, optional
                     The Interval over which to be generated, default=1000
     title:          string, optional
@@ -190,64 +196,52 @@
     lowcut:         float, optional
                     An additional marking line that can be plotted, default=None
     magnitude:      bool, optional
                     Control argument to enable plotting of magnitude, default=True
     angle:          bool, optional
                     Control argument to enable plotting of angle, default=True
     """
-    W = _np.linspace(mn,mx,NN)
-    H = _np.zeros(NN, dtype = _np.complex)
+    W = _np.linspace(mn, mx, NN)
+    H = _np.zeros(NN, dtype=_np.complex)
 
-    for n in range(0,NN):
-        s = 1j*W[n]
+    for n in range(0, NN):
+        s = 1j * W[n]
         H[n] = f(s)
-    if(magnitude):
-        _plt.semilogx(W,20*_np.log10(abs(H)),'k')
+    if magnitude:
+        _plt.semilogx(W, 20 * _np.log10(abs(H)), 'k')
         _plt.ylabel('|H| dB')
         _plt.xlabel('Frequency (rad/sec)')
-        _plt.title(title+" Magnitude")
-        _plt.grid(which='both')
-        if disp3db:
-            _plt.axhline(-3)
-        if lowcut!=None:
-            _plt.axhline(lowcut)
-        if xlim!=False:
-            _plt.xlim(xlim)
-        if ylim!=False:
-            _plt.ylim(ylim)
-        if sv:
-            _plt.savefig(title+" Magnitude.png")
-        _plt.show()
+        _magnitude_plot(title, disp3db, lowcut, xlim, ylim, sv)
 
     aaa = _np.angle(H)
     for n in range(NN):
         if aaa[n] > _pi:
-            aaa[n] = aaa[n] - 2*_pi
+            aaa[n] = aaa[n] - 2 * _pi
 
-    if(angle):
-        _plt.title(title+" Phase")
-        _plt.semilogx(W,(180/_pi)*aaa,'k')
+    if angle:
+        _plt.title(title + " Phase")
+        _plt.semilogx(W, (180 / _pi) * aaa, 'k')
         _plt.ylabel('H phase (degrees)')
         _plt.xlabel('Frequency (rad/sec)')
         _plt.grid(which='both')
-        if xlim!=False:
+        if xlim:
             _plt.xlim(xlim)
-        if ylim!=False:
+        if ylim:
             _plt.ylim(ylim)
         if sv:
-            _plt.savefig(title+" Phase.png")
+            _plt.savefig(title + " Phase.png")
         _plt.show()
 
 
-def zbode(f,dt=0.01,NN=1000,title="",mn=0,mx=2*_pi,xlim=False,ylim=False,
-          approx=False,sv=False,disp3db=False,lowcut=None,magnitude=True,
+def zbode(f, dt=0.01, NN=1000, title="", mn=0, mx=2 * _pi, xlim=False, ylim=False,
+          approx=False, sv=False, disp3db=False, lowcut=None, magnitude=True,
           angle=True):
     """
     Z-Domain Bode Plotting Function.
-    
+
     Parameters
     ----------
     f:              function
                     The Input Function, must be callable function object.
                     Must be specified as transfer function of type:
                     - S-Domain (when approx=False, default)
                     - Z-Domain (when approx=True)
@@ -255,15 +249,15 @@
                     The time-step used, default=0.01
     NN:             int, optional
                     The Interval over which to be generated, default=1000
     mn:             float, optional
                     The minimum phi value to be generated, default=0
     mx:             float, optional
                     The maximum phi value to be generated, default=2*pi
-    approx:         bool, optional
+    approx:         bool, optional, callable
                     Control argument to specify whether input funciton
                     should be treated as Z-Domain function or approximated
                     Z-Domain function. default=False
     title:          string, optional
                     Additional string to be added to plot titles;
                     default="".
     xlim:           list of float, optional
@@ -280,57 +274,45 @@
     lowcut:         float, optional
                     An additional marking line that can be plotted, default=None
     magnitude:      bool, optional
                     Control argument to enable plotting of magnitude, default=True
     angle:          bool, optional
                     Control argument to enable plotting of angle, default=True
     """
-    phi = _np.linspace(mn,mx,NN)
+    phi = _np.linspace(mn, mx, NN)
 
-    H = _np.zeros(NN, dtype = _np.complex)
-    for n in range(0,NN):
-        z = _exp(1j*phi[n])
-        if(approx!=False): # Approximated Z-Domain
-            s = approx(z,dt) # Pass current z-value and dt
+    H = _np.zeros(NN, dtype=_np.complex)
+    for n in range(0, NN):
+        z = _exp(1j * phi[n])
+        if approx is not False and callable(approx):
+            # Approximated Z-Domain
+            s = approx(z, dt)  # Pass current z-value and dt
             H[n] = f(s)
-        else: # Z-Domain Transfer Function Provided
-            H[n] = dt*f(z)
-            
-    if(magnitude):
-        _plt.semilogx((180/_pi)*phi,20*_np.log10(abs(H)),'k')
+        else:  # Z-Domain Transfer Function Provided
+            H[n] = dt * f(z)
+
+    if magnitude:
+        _plt.semilogx((180 / _pi) * phi, 20 * _np.log10(abs(H)), 'k')
         _plt.ylabel('|H| dB')
         _plt.xlabel('Frequency (degrees)')
-        _plt.title(title+" Magnitude")
-        _plt.grid(which='both')
-        if disp3db:
-            _plt.axhline(-3)
-        if lowcut!=None:
-            _plt.axhline(lowcut)
-        if xlim!=False:
-            _plt.xlim(xlim)
-        if ylim!=False:
-            _plt.ylim(ylim)
-        if sv:
-            _plt.savefig(title+" Magnitude.png")
-        _plt.show()
+        _magnitude_plot(title, disp3db, lowcut, xlim, ylim, sv)
 
     aaa = _np.angle(H)
     for n in range(NN):
         if aaa[n] > _pi:
-            aaa[n] = aaa[n] - 2*_pi
+            aaa[n] = aaa[n] - 2 * _pi
 
-    if(angle):
-        _plt.semilogx((180/_pi)*phi,(180/_pi)*aaa,'k')
+    if angle:
+        _plt.semilogx((180 / _pi) * phi, (180 / _pi) * aaa, 'k')
         _plt.ylabel('H (degrees)')
         _plt.grid(which='both')
         _plt.xlabel('Frequency (degrees)')
-        _plt.title(title+" Phase")
-        if xlim!=False:
+        _plt.title(title + " Phase")
+        if xlim:
             _plt.xlim(xlim)
-        if ylim!=False:
+        if ylim:
             _plt.ylim(ylim)
         if sv:
-            _plt.savefig(title+" Phase.png")
+            _plt.savefig(title + " Phase.png")
         _plt.show()
 
-
-# End of BODE.PY
+# End of BODE.PY
```

### Comparing `electricpy-0.2.2/electricpy/constants.py` & `electricpy-0.3.0/electricpy/constants.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,106 +1,105 @@
 ################################################################################
 """
-`electricpy.constants` - Electrical Engineering Constants.
+Numerical Constants for Electrical Engineering - Pi, Tau, α, etc.
 
 Defenition of all required constants and matricies for
 *electricpy* module.
 """
 ################################################################################
 
-# Import Supporting Dependencies
 import numpy as _np
 import cmath as _c
 
 # Define Electrical Engineering Constants
-pi = _np.pi #: PI Constant 3.14159...
-a = _c.rect(1,_np.radians(120)) #: 'A' Operator for Symmetrical Components
-p = 1e-12 #: Pico Multiple      (10^-12)
-n = 1e-9 #: Nano Multiple       (10^-9)
-u = 1e-6 #: Micro (mu) Multiple (10^-6)
-m = 1e-3 #: Mili Multiple       (10^-3)
-k = 1e+3 #: Kili Multiple       (10^3)
-M = 1e+6 #: Mega Multiple       (10^6)
-G = 1e+9 #: Giga Multiple       (10^9)
-u0 = 4*_np.pi*10**(-7) #: µ0 (mu-not)       4πE-7
+pi = _np.pi  #: PI Constant 3.14159...
+a = _c.rect(1, _np.radians(120))  #: 'A' Operator for Symmetrical Components
+p = 1e-12  #: Pico Multiple      (10^-12)
+n = 1e-9  #: Nano Multiple       (10^-9)
+u = 1e-6  #: Micro (mu) Multiple (10^-6)
+m = 1e-3  #: Mili Multiple       (10^-3)
+k = 1e+3  #: Kili Multiple       (10^3)
+M = 1e+6  #: Mega Multiple       (10^6)
+G = 1e+9  #: Giga Multiple       (10^9)
+u0 = 4 * _np.pi * 10 ** (-7)  #: µ0 (mu-not)       4πE-7
 e0 = 8.8541878128e-12  #: ε0 (epsilon-not)  8.854E-12
-carson_r = 9.869e-7 #: Carson's Ristance Constant  8.869E-7
-De0 = 2160 #: De Constant for Use with Transmission Impedance Calculations =2160
+carson_r = 9.869e-7  #: Carson's Ristance Constant  8.869E-7
+De0 = 2160  #: De Constant for Use with Transmission Impedance Calculations =2160
 NAN = float('nan')
-VLLcVLN = _c.rect(_np.sqrt(3),_np.radians(30)) # Conversion Operator
-ILcIP = _c.rect(_np.sqrt(3),_np.radians(30)) # Conversion Operator
+VLLcVLN = _c.rect(_np.sqrt(3), _np.radians(30))  # Conversion Operator
+ILcIP = _c.rect(_np.sqrt(3), _np.radians(30))  # Conversion Operator
 WATTS_PER_HP = 745.699872
 KWH_PER_BTU = 3412.14
 
 # Define Symmetrical Component Matricies
-Aabc = 1/3 * _np.array([[ 1, 1, 1    ],  # Convert ABC to 012
-                       [ 1, a, a**2 ],  # (i.e. phase to sequence)
-                       [ 1, a**2, a ]])
-A012 = _np.array([[ 1, 1, 1    ],        # Convert 012 to ABC
-                 [ 1, a**2, a ],        # (i.e. sequence to phase)
-                 [ 1, a, a**2 ]])
+Aabc = 1 / 3 * _np.array([[1, 1, 1],  # Convert ABC to 012
+                          [1, a, a ** 2],  # (i.e. phase to sequence)
+                          [1, a ** 2, a]])
+A012 = _np.array([[1, 1, 1],  # Convert 012 to ABC
+                  [1, a ** 2, a],  # (i.e. sequence to phase)
+                  [1, a, a ** 2]])
 # Define Clarke Component Matricies
-Cabc = _np.sqrt(2/3) * _np.array([
-    [ 1, -1/2, -1/2],         # Convert ABC to alpha/beta/gamma
-    [ 0, _np.sqrt(3)/2, -_np.sqrt(3)/2],
-    [ 1/_np.sqrt(2), 1/_np.sqrt(2), 1/_np.sqrt(2)]
+Cabc = _np.sqrt(2 / 3) * _np.array([
+    [1, -1 / 2, -1 / 2],  # Convert ABC to alpha/beta/gamma
+    [0, _np.sqrt(3) / 2, -_np.sqrt(3) / 2],
+    [1 / _np.sqrt(2), 1 / _np.sqrt(2), 1 / _np.sqrt(2)]
 ])
 Cxyz = _np.array([
-    [ 2/_np.sqrt(6), 0, 1/_np.sqrt(3)],       # Convert alpha/beta/gamma to ABC
-    [ -1/_np.sqrt(6), 1/_np.sqrt(2), 1/_np.sqrt(3)],
-    [ -1/_np.sqrt(6), -1/_np.sqrt(2), 1/_np.sqrt(3)]
+    [2 / _np.sqrt(6), 0, 1 / _np.sqrt(3)],  # Convert alpha/beta/gamma to ABC
+    [-1 / _np.sqrt(6), 1 / _np.sqrt(2), 1 / _np.sqrt(3)],
+    [-1 / _np.sqrt(6), -1 / _np.sqrt(2), 1 / _np.sqrt(3)]
 ])
 # Define Park Components Matricies
-_rad = lambda th: _np.radians( th )
-_Pdq0_im = lambda th: _np.sqrt(2/3)*_np.array([
-    [ _np.cos(_rad(th)), _np.cos(_rad(th)-2*pi/3), _np.cos(_rad(th)+2*pi/3)],
-    [-_np.sin(_rad(th)),-_np.sin(_rad(th)-2*pi/3),-_np.sin(_rad(th)+2*pi/3)],
-    [ _np.sqrt(2)/2,     _np.sqrt(2)/2,            _np.sqrt(2)/2]
+_rad = lambda th: _np.radians(th)
+_Pdq0_im = lambda th: _np.sqrt(2 / 3) * _np.array([
+    [_np.cos(_rad(th)), _np.cos(_rad(th) - 2 * pi / 3), _np.cos(_rad(th) + 2 * pi / 3)],
+    [-_np.sin(_rad(th)), -_np.sin(_rad(th) - 2 * pi / 3), -_np.sin(_rad(th) + 2 * pi / 3)],
+    [_np.sqrt(2) / 2, _np.sqrt(2) / 2, _np.sqrt(2) / 2]
 ])
-_Pabc_im = lambda th: _np.sqrt(2/3)*_np.array([
-    [ _np.cos(_rad(th)),      -_np.sin(_rad(th)),        _np.sqrt(2)/2],
-    [_np.cos(_rad(th)-2*pi/3),-_np.sin(_rad(th)-2*pi/3), _np.sqrt(2)/2],
-    [_np.cos(_rad(th)+2*pi/3),-_np.sin(_rad(th)+2*pi/3), _np.sqrt(2)/2]
+_Pabc_im = lambda th: _np.sqrt(2 / 3) * _np.array([
+    [_np.cos(_rad(th)), -_np.sin(_rad(th)), _np.sqrt(2) / 2],
+    [_np.cos(_rad(th) - 2 * pi / 3), -_np.sin(_rad(th) - 2 * pi / 3), _np.sqrt(2) / 2],
+    [_np.cos(_rad(th) + 2 * pi / 3), -_np.sin(_rad(th) + 2 * pi / 3), _np.sqrt(2) / 2]
 ])
-Pdq0 = 2/3 * _np.array([[0,-_np.sqrt(3/2),_np.sqrt(3/2)],
-                        [1,-1/2,-1/2],
-                        [1/2, 1/2, 1/2]])
-Pqd0 = 2/3 * _np.array([[1,-1/2,-1/2],
-                        [0,-_np.sqrt(3/2),_np.sqrt(3/2)],
-                        [1/2, 1/2, 1/2]])
-                 
+Pdq0 = 2 / 3 * _np.array([[0, -_np.sqrt(3 / 2), _np.sqrt(3 / 2)],
+                          [1, -1 / 2, -1 / 2],
+                          [1 / 2, 1 / 2, 1 / 2]])
+Pqd0 = 2 / 3 * _np.array([[1, -1 / 2, -1 / 2],
+                          [0, -_np.sqrt(3 / 2), _np.sqrt(3 / 2)],
+                          [1 / 2, 1 / 2, 1 / 2]])
+
 # Define Transformer Shift Correction Matricies
-XFMY0 = _np.array([[1,0,0],[0,1,0],[0,0,1]])
-XFMD1 = 1/_np.sqrt(3) * _np.array([[1,-1,0],[0,1,-1],[-1,0,1]])
-XFMD11 = 1/_np.sqrt(3) * _np.array([[1,0,-1],[-1,1,0],[0,-1,1]])
-XFM12 = 1/3 * _np.array([[2,-1,-1],[-1,2,-1],[-1,-1,2]])
+XFMY0 = _np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])
+XFMD1 = 1 / _np.sqrt(3) * _np.array([[1, -1, 0], [0, 1, -1], [-1, 0, 1]])
+XFMD11 = 1 / _np.sqrt(3) * _np.array([[1, 0, -1], [-1, 1, 0], [0, -1, 1]])
+XFM12 = 1 / 3 * _np.array([[2, -1, -1], [-1, 2, -1], [-1, -1, 2]])
 
 # Define Complex Angle Terms
-e30 = _c.rect(1,_np.radians(30)) #: 30° Phase Operator
-en30 = _c.rect(1,_np.radians(-30)) #: -30° Phase Operator
-e60 = _c.rect(1,_np.radians(60)) #: 60° Phase Operator
-en60 = _c.rect(1,_np.radians(-60)) #: -60° Phase Operator
-e90 = _c.rect(1,_np.radians(90)) #: 90° Phase Operator
-en90 = _c.rect(1,_np.radians(-90)) #: -90° Phase Operator
-e45 = _c.rect(1,_np.radians(45)) #: 45° Phase Operator
-en45 = _c.rect(1,_np.radians(-45)) #: -45° Phase Operator
+e30 = _c.rect(1, _np.radians(30))  #: 30° Phase Operator
+en30 = _c.rect(1, _np.radians(-30))  #: -30° Phase Operator
+e60 = _c.rect(1, _np.radians(60))  #: 60° Phase Operator
+en60 = _c.rect(1, _np.radians(-60))  #: -60° Phase Operator
+e90 = _c.rect(1, _np.radians(90))  #: 90° Phase Operator
+en90 = _c.rect(1, _np.radians(-90))  #: -90° Phase Operator
+e45 = _c.rect(1, _np.radians(45))  #: 45° Phase Operator
+en45 = _c.rect(1, _np.radians(-45))  #: -45° Phase Operator
 
 # Define Material Resistivity (Rho)
 resistivity_rho = {
-    'silver':       15.9,
-    'copper':       16.8,
-    'aluminium':    6.5,
-    'tungsten':     56,
-    'iron':         97.1,
-    'platinum':     106,
-    'manganin':     482,
-    'lead':         220,
-    'mercury':      980,
-    'nichrome':     1000,
-    'constantan':   490,
+    'silver': 15.9,
+    'copper': 16.8,
+    'aluminium': 6.5,
+    'tungsten': 56,
+    'iron': 97.1,
+    'platinum': 106,
+    'manganin': 482,
+    'lead': 220,
+    'mercury': 980,
+    'nichrome': 1000,
+    'constantan': 490,
 }
 THERMO_COUPLE_DATA = {
     "J": [
         [-6.4936529E+01, 2.5066947E+02, 6.4950262E+02, 9.2510550E+02, 1.0511294E+03],
         [-3.1169773E+00, 1.3592329E+01, 3.6040848E+01, 5.3433832E+01, 6.0956091E+01],
         [2.2133797E+01, 1.8014787E+01, 1.6593395E+01, 1.6243326E+01, 1.7156001E+01],
         [2.0476437E+00, -6.5218881E-02, 7.3009590E-01, 9.2793267E-01, -2.5931041E+00],
@@ -131,25 +130,25 @@
         [3.1009445E-01, 1.0113834E-01],
         [-5.0880251E-01, -1.6145962E-03],
         [-1.6163342E-01, -4.1086314E-06]],
     "E": [
         [-1.1721668E+02, -5.0000000E+01, 2.5014600E+02, 6.0139890E+02, 8.0435911E+02],
         [-5.9901698E+00, -2.7871777E+00, 1.7191713E+01, 4.5206167E+01, 6.1359178E+01],
         [2.3647275E+01, 1.9022736E+01, 1.3115522E+01,
-            1.2399357E+01, 1.2759508E+01],
+         1.2399357E+01, 1.2759508E+01],
         [1.2807377E+01, -1.7042725E+00, 1.1780364E+00,
-            4.3399963E-01, -1.1116072E+00],
+         4.3399963E-01, -1.1116072E+00],
         [2.0665069E+00, -3.5195189E-01, 3.6422433E-02,
-            9.1967085E-03, 3.5332536E-02],
+         9.1967085E-03, 3.5332536E-02],
         [8.6513472E-02, 4.7766102E-03, 3.9584261E-04,
-            1.6901585E-04, 3.3080380E-05],
+         1.6901585E-04, 3.3080380E-05],
         [5.8995860E-01, -6.5379760E-02, 9.3112756E-02,
-            3.4424680E-02, -8.8196889E-02],
+         3.4424680E-02, -8.8196889E-02],
         [1.0960713E-01, -2.1732833E-02, 2.9804232E-03,
-            6.9741215E-04, 2.8497415E-03],
+         6.9741215E-04, 2.8497415E-03],
         [6.1769588E-03, 0.0, 3.3263032E-05, 1.2946992E-05, 0.0]],
     "N": [
         [-5.9610511E+01, 3.1534505E+02, 1.0340172E+03],
         [-1.5000000E+00, 9.8870997E+00, 3.7565475E+01],
         [4.2021322E+01, 2.7988676E+01, 2.6029492E+01],
         [4.7244037E+00, 1.5417343E+00, -6.0783095E-01],
         [-6.1153213E+00, -1.4689457E-01, -9.7742562E-03],
@@ -201,22 +200,30 @@
     "N": [-4.313, 0, 20.613, 47.513, None, None],
     "R": [-0.226, 1.469, 7.461, 14.277, 21.101, None],
     "S": [-0.236, 1.441, 6.913, 12.856, 18.693, None],
     "T": [-6.18, -4.648, 0, 9.288, 20.872, None]
 }
 
 COLD_JUNCTION_DATA = {
-    "To": [4.2000000E+01, 2.5000000E+01, 2.5000000E+01, 2.5000000E+01, 7.0000000E+00, 2.5000000E+01, 2.5000000E+01, 2.5000000E+01],
-    "Vo": [3.3933898E-04, 1.4950582E+00, 1.2773432E+00, 1.0003453E+00, 1.8210024E-01, 1.4067016E-01, 1.4269163E-01, 9.9198279E-01],
-    "P1": [2.1196684E-04, 6.0958443E-02, 5.1744084E-02, 4.0514854E-02, 2.6228256E-02, 5.9330356E-03, 5.9829057E-03, 4.0716564E-02],
-    "P2": [3.3801250E-06, -2.7351789E-04, -5.4138663E-05, -3.8789638E-05, -1.5485539E-04, 2.7736904E-05, 4.5292259E-06, 7.1170297E-04],
-    "P3": [-1.4793289E-07, -1.9130146E-05, -2.2895769E-06, -2.8608478E-06, 2.1366031E-06, -1.0819644E-06, -1.3380281E-06, 6.8782631E-07],
-    "P4": [-3.3571424E-09, -1.3948840E-08, -7.7947143E-10, -9.5367041E-10, 9.2047105E-10, -2.3098349E-09, -2.3742577E-09, 4.3295061E-11],
-    "Q1": [-1.0920410E-02, -5.2382378E-03, -1.5173342E-03, -1.3948675E-03, -6.4070932E-03, 2.6146871E-03, -1.0650446E-03, 1.6458102E-02],
-    "Q2": [-4.9782932E-04, -3.0970168E-04, -4.2314514E-05, -6.7976627E-05, 8.2161781E-05, -1.8621487E-04, -2.2042420E-04, 0.0000000E+00]
+    "To": [4.2000000E+01, 2.5000000E+01, 2.5000000E+01, 2.5000000E+01, 7.0000000E+00, 2.5000000E+01, 2.5000000E+01,
+           2.5000000E+01],
+    "Vo": [3.3933898E-04, 1.4950582E+00, 1.2773432E+00, 1.0003453E+00, 1.8210024E-01, 1.4067016E-01, 1.4269163E-01,
+           9.9198279E-01],
+    "P1": [2.1196684E-04, 6.0958443E-02, 5.1744084E-02, 4.0514854E-02, 2.6228256E-02, 5.9330356E-03, 5.9829057E-03,
+           4.0716564E-02],
+    "P2": [3.3801250E-06, -2.7351789E-04, -5.4138663E-05, -3.8789638E-05, -1.5485539E-04, 2.7736904E-05, 4.5292259E-06,
+           7.1170297E-04],
+    "P3": [-1.4793289E-07, -1.9130146E-05, -2.2895769E-06, -2.8608478E-06, 2.1366031E-06, -1.0819644E-06,
+           -1.3380281E-06, 6.8782631E-07],
+    "P4": [-3.3571424E-09, -1.3948840E-08, -7.7947143E-10, -9.5367041E-10, 9.2047105E-10, -2.3098349E-09,
+           -2.3742577E-09, 4.3295061E-11],
+    "Q1": [-1.0920410E-02, -5.2382378E-03, -1.5173342E-03, -1.3948675E-03, -6.4070932E-03, 2.6146871E-03,
+           -1.0650446E-03, 1.6458102E-02],
+    "Q2": [-4.9782932E-04, -3.0970168E-04, -4.2314514E-05, -6.7976627E-05, 8.2161781E-05, -1.8621487E-04,
+           -2.2042420E-04, 0.0000000E+00]
 }
 COLD_JUNCTION_KEYS = ["To", "Vo", "P1", "P2", "P3", "P4", "Q1", "Q2"]
 
 RTD_TYPES = {
     "PT100": [100, 0.00385],
     "PT1000": [1000, 0.00385],
     "CU100": [100, 0.00427],
@@ -231,8 +238,9 @@
     'AVG': 100,
     'AVERAGE': 100,
     'DAMP': 100,
     'DRY': 1000,
     'SAND': 1E9,
     'SANDSTONE': 1E9,
 }
-# END OF FILE
+
+# END OF FILE
```

### Comparing `electricpy-0.2.2/electricpy/conversions.py` & `electricpy-0.3.0/electricpy/phasors.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,444 +1,410 @@
 ################################################################################
 """
-`electricpy` Package - `conversions` Module.
+Functions to Support Common Electrical Engineering Formulas Related to Phasors.
 
->>> from electricpy import conversions
+>>> from electricpy import phasors
 
-Filled with simple conversion functions to help manage unit conversions and the
-like, this module is very helpful to electrical engineers.
+Filled with calculators, evaluators, and plotting functions related to
+electrical phasors, this package will provide a wide array of capabilities to
+any electrical engineer.
 
 Built to support operations similar to Numpy and Scipy, this package is designed
 to aid in scientific calculations.
 """
 ################################################################################
 
-# Import Local Requirements
-from electricpy.constants import WATTS_PER_HP, Aabc, A012, KWH_PER_BTU
-
-# Import Required Packages
 import numpy as _np
+import cmath as _c
 
 
-# Define HP to Watts Calculation
-def hp_to_watts(hp):
-    r"""
-    Horsepower to Watts Formula.
-
-    Calculates the power (in watts) given the
-    horsepower.
-
-    .. math:: P_{\text{watts}}=P_{\text{horsepower}}\cdot745.699872
-
-    Same as `watts`.
-
-    Parameters
-    ----------
-    hp:         float
-                The horspower to compute.
-
-    Returns
-    -------
-    watts:      float
-                The power in watts.
+# Define Phase Angle Generator
+def phs(ang):
     """
-    return (hp * WATTS_PER_HP)
-
-
-watts = hp_to_watts  # Make Duplicate Name
-
-
-# Define Watts to HP Calculation
-def watts_to_hp(watts):
-    r"""
-    Watts to Horsepower Function.
+    Complex Phase Angle Generator.
 
-    Calculates the power (in horsepower) given
-    the power in watts.
+    Generate a complex value given the phase angle
+    for the complex value.
 
-    .. math:: P_{\text{horsepower}}=\frac{P_{\text{watts}}}{745.699872}
-
-    Same as `horsepower`.
+    Same as `phase`.
 
     Parameters
     ----------
-    watts:      float
-                The wattage to compute.
+    ang:        float
+                The angle (in degrees) for which
+                the value should be calculated.
 
-    Returns
-    -------
-    hp:         float
-                The power in horsepower.
+    See Also
+    --------
+    electricpy.cprint:              Complex Variable Printing Function
+    electricpy.phasors.phasorlist:   Phasor Generator for List or Array
+    electricpy.phasors.phasorz:      Impedance Phasor Generator
+    electricpy.phasors.phasor:       Phasor Generating Function
     """
-    return (watts / WATTS_PER_HP)
-
+    # Return the Complex Angle Modulator
+    return _np.exp(1j * _np.radians(ang))
 
-horsepower = watts_to_hp  # Make Duplicate Name
 
+phase = phs  # Create Duplicate Name
 
-# Define kWh to BTU function and vice-versa
-def kwh_to_btu(kWh):
-    r"""
-    Killo-Watt-Hours to BTU Function.
-
-    Converts kWh (killo-Watt-hours) to BTU (British Thermal Units).
 
-    .. math:: \text{BTU} = \text{kWh}\cdot3412.14
-
-    Same as `btu`.
-
-    Parameters
-    ----------
-    kWh:        float
-                The number of killo-Watt-hours
-
-    Returns
-    -------
-    BTU:        float
-                The number of British Thermal Units
+# Define Phasor Generator
+def phasor(mag, ang=0):
     """
-    return (kWh * KWH_PER_BTU)
+    Complex Phasor Generator.
 
-
-btu = kwh_to_btu  # Make Duplicate Name
-
-
-def btu_to_kwh(BTU):
-    r"""
-    BTU to Killo-Watt-Hours Function.
-
-    Converts BTU (British Thermal Units) to kWh (killo-Watt-hours).
-
-    .. math:: \text{kWh} = \frac{\text{BTU}}{3412.14}
-
-    Same as `kwh`.
+    Generates the standard Pythonic complex representation
+    of a phasor voltage or current when given the magnitude
+    and angle of the specific voltage or current.
 
     Parameters
     ----------
-    BTU:        float
-                The number of British Thermal Units
+    mag:        float
+                The Magnitude of the Voltage/Current
+    ang:        float
+                The Angle (in degrees) of the Voltage/Current
 
     Returns
     -------
-    kWh:        float
-                The number of killo-Watt-hours
-    """
-    return (BTU / KWH_PER_BTU)
+    phasor:     complex
+                Standard Pythonic Complex Representation of
+                the specified voltage or current.
 
+    Examples
+    --------
+    >>> from electricpy import phasors
+    >>> phasor(67, 120) # 67 volts at angle 120 degrees
+    (-33.499999999999986+58.02370205355739j)
 
-kwh = btu_to_kwh  # Make Duplicate Name
+    See Also
+    --------
+    electricpy.cprint:              Complex Variable Printing Function
+    electricpy.phasors.phasorlist:   Phasor Generator for List or Array
+    electricpy.phasors.phasorz:      Impedance Phasor Generator
+    electricpy.phasors.phs:          Complex Phase Angle Generator
+    """
+    # Test for Tuple/List Arg
+    if isinstance(mag, (tuple, list, _np.ndarray)):
+        ang = mag[1]
+        mag = mag[0]
+    return _c.rect(mag, _np.radians(ang))
 
 
-# Define Simple Radians to Hertz Converter
-def rad_to_hz(radians):
+# Define Impedance Conversion function
+def phasorz(C=None, L=None, freq=60, complex=True):
     r"""
-    Radians to Hertz Converter.
+    Phasor Impedance Generator.
 
-    Accepts a frequency in radians/sec and calculates
-    the hertzian frequency (in Hz).
+    This function's purpose is to generate the phasor-based
+    impedance of the specified input given as either the
+    capacitance (in Farads) or the inductance (in Henreys).
+    The function will return the phasor value (in Ohms).
 
-    .. math:: f_{\text{Hz}} = \frac{f_{\text{rad/sec}}}{2\cdot\pi}
+    .. math:: Z = \frac{-j}{\omega*C}
 
-    Same as `hertz`.
+    .. math:: Z = j*\omega*L
 
-    Parameters
-    ----------
-    radians:    float
-                The frequency (represented in radians/sec)
+    where:
 
-    Returns
-    -------
-    hertz:      float
-                The frequency (represented in Hertz)
-    """
-    return (radians / (2 * _np.pi))  # Evaluate and Return
-
-
-hertz = rad_to_hz  # Make Duplicate Name
-
-
-# Define Simple Hertz to Radians Converter
-def hz_to_rad(hertz):
-    r"""
-    Hertz to Radians Converter.
-
-    Accepts a frequency in Hertz and calculates
-    the frequency in radians/sec.
-
-    .. math:: f_{\text{rad/sec}} = f_{\text{Hz}}\cdot2\cdot\pi
-
-    Same as `radsec`.
+    .. math:: \omega = 2*\pi*freq
 
     Parameters
     ----------
-    hertz:      float
-                The frequency (represented in Hertz)
+    C:          float, optional
+                The capacitance value (specified in Farads),
+                default=None
+    L:          float, optional
+                The inductance value (specified in Henreys),
+                default=None
+    freq:       float, optional
+                The system frequency to be calculated upon, default=60
+    complex:    bool, optional
+                Control argument to specify whether the returned
+                value should be returned as a complex value.
+                default=True
 
     Returns
     -------
-    radians:    float
-                The frequency (represented in radians/sec)
+    Z:      complex
+            The ohmic impedance of either C or L (respectively).
     """
-    return (hertz * (2 * _np.pi))  # Evaluate and Return
-
-
-radsec = hz_to_rad  # Make Duplicate Name
-
-
-# Define Sequence Component Conversion Function
-def abc_to_seq(Mabc, reference='A'):
-    r"""
-    Phase-System to Sequence-System Conversion.
-
-    Converts phase-based values to sequence
-    components.
-
-    .. math:: M_{\text{012}}=A_{\text{012}}\cdot M_{\text{ABC}}
+    w = 2 * _np.pi * freq
+    # C Given in ohms, return as Z
+    if C is not None:
+        Z = -1 / (w * C)
+    # L Given in ohms, return as Z
+    if L is not None:
+        Z = w * L
+    # If asked for imaginary number
+    if complex:
+        Z *= 1j
+    return Z
 
-    Same as phs_to_seq.
 
-    Parameters
-    ----------
-    Mabc:       list of complex
-                Phase-based values to be converted.
-    reference:  {'A', 'B', 'C'}
-                Single character denoting the reference,
-                default='A'
-
-    Returns
-    -------
-    M012:       numpy.ndarray
-                Sequence-based values in order of 0-1-2
-
-    See Also
-    --------
-    seq_to_abc: Sequence to Phase Conversion
-    sequencez:  Phase Impedance to Sequence Converter
+# Define Phasor Array Generator
+def phasorlist(arr):
     """
-    # Condition Reference:
-    reference = reference.upper()
-    if reference == 'A':
-        M = Aabc
-    elif reference == 'B':
-        M = _np.roll(Aabc, 1, 0)
-    elif reference == 'C':
-        M = _np.roll(Aabc, 2, 0)
-    else:
-        raise ValueError("Invalid Phase Reference.")
-    return (M.dot(Mabc))
-
-
-# Define Second Name for abc_to_seq
-phs_to_seq = abc_to_seq
-
-
-# Define Phase Component Conversion Function
-def seq_to_abc(M012, reference='A'):
-    r"""
-    Sequence-System to Phase-System Conversion.
-
-    Converts sequence-based values to phase
-    components.
-
-    .. math:: M_{\text{ABC}}=A_{\text{012}}^{-1}\cdot M_{\text{012}}
+    Complex Phasor Generator for 2-D Array or 2-D List.
 
-    Same as seq_to_phs.
+    Generates the standard Pythonic complex representation
+    of a phasor voltage or current when given the magnitude
+    and angle of the specific voltage or current for a list
+    or array of values.
 
     Parameters
     ----------
-    M012:       list of complex
-                Sequence-based values to convert.
-    reference:  {'A', 'B', 'C'}
-                Single character denoting the reference,
-                default='A'
+    arr:        array-like
+                2-D array or list of magnitudes and angles.
+                Each item must be set of magnitude and angle
+                in form of: [mag, ang].
 
     Returns
     -------
-    Mabc:       numpy.ndarray
-                Phase-based values in order of A-B-C
+    list[complex]:  List of standard Pythonic complex representation of the
+                    specified voltage or current.
 
-    See Also
+    Examples
     --------
-    abc_to_seq: Phase to Sequence Conversion
-    sequencez:  Phase Impedance to Sequence Converter
-    """
-    # Compute Dot Product
-    M = A012.dot(M012)
-    # Condition Reference:
-    reference = reference.upper()
-    if reference == 'A':
-        pass
-    elif reference == 'B':
-        M = _np.roll(M, 1, 0)
-    elif reference == 'C':
-        M = _np.roll(M, 2, 0)
-    else:
-        raise ValueError("Invalid Phase Reference.")
-    return (M)
-
-
-# Define Second Name for seq_to_abc
-seq_to_phs = seq_to_abc
-
-
-# Define Sequence Impedance Calculator
-def sequencez(Zabc, reference='A', resolve=False, diag=False, round=3):
-    r"""
-    Sequence Impedance Calculator.
-
-    Accepts the phase (ABC-domain) impedances for a
-    system and calculates the sequence (012-domain)
-    impedances for the same system. If the argument
-    `resolve` is set to true, the function will
-    combine terms into the set of [Z0, Z1, Z2].
-
-    When resolve is False:
-
-    .. math:: Z_{\text{012-M}}=A_{\text{012}}^{-1}Z_{\text{ABC}}A_{\text{012}}
-
-    When resolve is True:
-
-    .. math:: Z_{\text{012}}=A_{\text{012}}Z_{\text{ABC}}A_{\text{012}}^{-1}
-
-    Parameters
-    ----------
-    Zabc:       numpy.ndarray of complex
-                2-D (3x3) matrix of complex values
-                representing the phasor impedances
-                in the ABC-domain.
-    reference:  {'A', 'B', 'C'}
-                Single character denoting the reference,
-                default='A'
-    resolve:    bool, optional
-                Control argument to force the function to
-                evaluate the individual sequence impedances
-                [Z0, Z1, Z2], default=False
-    diag:       bool, optional
-                Control argument to force the function to
-                reduce the matrix to its diagonal terms.
-    round:      int, optional
-                Integer denoting number of decimal places
-                resulting matrix should be rounded to.
-                default=3
-
-    Returns
-    -------
-    Z012:       numpy.ndarray of complex
-                2-D (3x3) matrix of complex values
-                representing the sequence impedances
-                in the 012-domain
+    >>> import numpy as np
+    >>> from electricpy import phasors
+    >>> voltages = np.array([
+    ...     [67,0],
+    ...     [67,-120],
+    ...     [67,120]
+    ... ])
+    >>> Vset = phasors.phasorlist( voltages )
+    >>> print(Vset)
 
     See Also
     --------
-    seq_to_abc: Sequence to Phase Conversion
-    abc_to_seq: Phase to Sequence Conversion
-    """
-    # Condition Reference
-    reference = reference.upper()
-    rollrate = {'A': 0, 'B': 1, 'C': 2}
-    # Test Validity
-    if reference not in rollrate:
-        raise ValueError("Invalad Phase Reference")
-    # Determine Roll Factor
-    roll = rollrate[reference]
-    # Evaluate Matricies
-    M012 = _np.roll(A012, roll, 0)
-    Minv = _np.linalg.inv(M012)
-    # Compute Sequence Impedances
-    if resolve:
-        Z012 = M012.dot(Zabc.dot(Minv))
-    else:
-        Z012 = Minv.dot(Zabc.dot(M012))
-    # Reduce to Diagonal Terms if Needed
-    if diag:
-        Z012 = [Z012[0][0], Z012[1][1], Z012[2][2]]
-    return (_np.around(Z012, round))
-
-
-# Define Angular Velocity Conversion Functions
-def rad_to_rpm(rad):
+    electricpy.cprint:              Complex Variable Printing Function
+    electricpy.phasors.phasor:       Phasor Generating Function
+    electricpy.phasors.vectarray:    Magnitude/Angle Array Pairing Function
+    electricpy.phasors.phasorz:      Impedance Phasor Generator
     """
-    Radians-per-Second to RPM Converter.
+    # Use List Comprehension to Process
 
-    Given the angular velocity in rad/sec, this function will evaluate the
-    velocity in RPM (Revolutions-Per-Minute).
-
-    Parameters
-    ----------
-    rad:        float
-                The angular velocity in radians-per-second
-
-    Returns
-    -------
-    rpm:        float
-                The angular velocity in revolutions-per-minute (RPM)
-    """
-    rpm = 60 / (2 * _np.pi) * rad
-    return (rpm)
+    # Return Array
+    return _np.array([phasor(i) for i in arr])
 
 
-# Define Angular Velocity Conversion Functions
-def rpm_to_rad(rpm):
+# Define Vector Array Generator
+def vectarray(arr, degrees=True, flatarray=False):
     """
-    RPM to Radians-per-Second Converter.
+    Format Complex as Array of Magnitude/Angle Pairs.
 
-    Given the angular velocity in RPM (Revolutions-Per-Minute), this function
-    will evaluate the velocity in rad/sec.
+    Consume an iterable (list/tuple/ndarray/etc.) of
+    complex numbers and generate an ndarray of magnitude
+    and angle pairs, formatted as a 2-dimension (or
+    optionally 1-dimension) array.
 
     Parameters
     ----------
-    rpm:        float
-                The angular velocity in revolutions-per-minute (RPM)
+    arr:        array-like
+                Array or list of complex numbers to be
+                cast to magnitude/angle pairs.
+    degrees:    bool, optional
+                Control option to set the angles in
+                degrees. Defaults to True.
+    flatarray:  bool, optional
+                Control option to set the array return
+                to work as a 1-dimension list. Defaults
+                to False, formatting as a 2-dimension
+                list.
 
     Returns
     -------
-    rad:        float
-                The angular velocity in radians-per-second
-    """
-    rad = 2 * _np.pi / 60 * rpm
-    return (rad)
-
+    polararr:   ndarray
+                Array of magnitude/angle pairs as a
+                2-dimension array (or optionally
+                1-dimension array).
 
-# Define Angular Velocity Conversion Functions
-def hz_to_rpm(hz):
+    See Also
+    --------
+    electricpy.phasors.phasor:       Phasor Generating Function
+    electricpy.phasors.phasorlist:   Phasor Generator for List or Array
     """
-    Hertz to RPM Converter.
+    # Iteratively Append Arrays to the Base
 
-    Given the angular velocity in Hertz, this function will evaluate the
-    velocity in RPM (Revolutions-Per-Minute).
+    def vector_cast(num):
+        mag, ang = _c.polar(num)
 
-    Parameters
-    ----------
-    hz:         float
-                The angular velocity in Hertz
-
-    Returns
-    -------
-    rpm:        float
-                The angular velocity in revolutions-per-minute (RPM)
-    """
-    rpm = hz * 60
-    return (rpm)
+        if degrees:
+            ang = _np.degrees(ang)
+
+        return [mag, ang]
+
+    polararr = _np.array([vector_cast(num) for num in arr])
+    # Reshape Array if Needed
+    if not flatarray:
+        polararr = _np.reshape(polararr, (-1, 2))
+    return polararr
+
+
+# Define Phasor Data Generator
+def phasordata(mn, mx=None, npts=1000, mag=1, ang=0, freq=60,
+               retstep=False, rettime=False, sine=False):
+    """
+    Complex Phasor Data Generator.
+
+    Generates a sinusoidal data set with minimum, maximum,
+    frequency, magnitude, and phase angle arguments.
+
+    Parameters
+    ----------
+    mn:         float, optional
+                Minimum time (in seconds) to generate data for.
+                default=0
+    mx:         float
+                Maximum time (in seconds) to generate data for.
+    npts:       float, optional
+                Number of data samples. default=1000
+    mag:        float, optional
+                Sinusoid magnitude, default=1
+    ang:        float, optional
+                Sinusoid angle in degrees, default=0
+    freq:       float, optional
+                Sinusoid frequency in Hz
+    retstep:    bool, optional
+                Control argument to request return of time
+                step size (dt) in seconds.
+    sine:       bool, optional
+                Control argument to require data be generated
+                with a sinusoidal function instead of cosine.
+
+    Returns
+    -------
+    data:       numpy.ndarray
+                The resultant data array.
+    """
+    # Test Inputs for Min/Max
+    if mx == None:
+        # No Minimum provided, use Value as Maximum
+        mx = mn
+        mn = 0
+    # Generate Omega
+    w = 2 * _np.pi * freq
+    # Generate Time Array
+    t, dt = _np.linspace(mn, mx, npts, retstep=True)
+    # Generate Data Array
+    if not sine:
+        data = mag * _np.cos(w * t + _np.radians(ang))
+    else:
+        data = mag * _np.sin(w * t + _np.radians(ang))
+    # Generate Return Data Set
+    dataset = [data]
+    if retstep:
+        dataset.append(dt)
+    if rettime:
+        dataset.append(t)
+    # Return Dataset
+    if len(dataset) == 1:
+        return dataset[0]
+    return dataset
+
+
+# Define Complex Composition Function
+def compose(*arr):
+    """
+    Complex Composition Function.
+
+    Accepts a set of real values and generates an array
+    of complex values. Input must be array-like, but can
+    appear in various forms:
+
+    - [ real, imag]
+    - [ [ real1, ..., realn ], [ imag1, ..., imagn ] ]
+    - [ [ real1, imag1 ], ..., [ realn, imagn ] ]
+
+    Will always return values in form:
+
+    [ complex1, ... complexn ]
+
+    Parameters
+    ----------
+    arr:        array_like
+                The input of real and imaginary term(s)
+    """
+    # Condition Input
+    if len(arr) == 1:
+        arr = arr[0]  # Extract 0-th term
+    # Input comes in various forms, we must first detect shape
+    arr = _np.asarray(arr)  # Format as Numpy Array
+    # Gather Shape to Detect Format
+    try:
+        row, col = arr.shape
+        # Passed Test, Valid Shape
+        retarr = _np.array([])  # Empty Return Array
+        # Now, Determine whether is type 2 or 3
+        if col == 2:  # Type 3
+            for i in range(row):  # Iterate over each row
+                item = arr[i][0] + 1j * arr[i][1]
+                retarr = _np.append(retarr, item)
+        elif row == 2:  # Type 2
+            for i in range(col):  # Iterate over each column
+                item = arr[0][i] + 1j * arr[1][i]
+                retarr = _np.append(retarr, item)
+        else:
+            raise ValueError("Invalid Array Shape, must be 2xN or Nx2.")
+        # Successfully Generated Array, Return
+        return (retarr)
+    except:  # 1-Dimension Array
+        length = arr.size
+        # Test for invalid Array Size
+        if length != 2:
+            raise ValueError("Invalid Array Size, Saw Length of " + str(length))
+        # Valid Size, Calculate and Return
+        return arr[0] + 1j * arr[1]
 
 
-# Define Angular Velocity Conversion Functions
-def rpm_to_hz(rpm):
-    """
-    RPM to Hertz Converter.
+# Define Parallel Impedance Adder
+def parallelz(*args):
+    r"""
+    Parallel Impedance Calculator.
 
-    Given the angular velocity in RPM (Revolutions-Per-Minute), this function
-    will evaluate the velocity in Hertz.
+    This function is designed to generate the total parallel
+    impedance of a set (tuple) of impedances specified as real
+    or complex values.
+
+    .. math::
+       Z_{eq}=(\frac{1}{Z_1}+\frac{1}{Z_2}+\dots+\frac{1}{Z_n})^{-1}
 
     Parameters
     ----------
-    rpm:        float
-                The angular velocity in revolutions-per-minute (RPM)
+    Z:      tuple of complex
+            The tupled input set of impedances, may be a tuple
+            of any size greater than 2. May be real, complex, or
+            a combination of the two.
 
     Returns
     -------
-    hz:         float
-                The angular velocity in Hertz
-    """
-    hz = rpm / 60
-    return (hz)
+    Zp:     complex
+            The calculated parallel impedance of the input tuple.
+    """
+    # Gather length (number of elements in tuple)
+    L = len(args)
+    if L == 1:
+        Z = args[0]  # Only One Tuple Provided
+        try:
+            L = len(Z)
+            if L == 1:
+                Zp = Z[0]  # Only one impedance, burried in tuple
+            else:
+                # Inversely add the first two elements in tuple
+                Zp = (1 / Z[0] + 1 / Z[1]) ** (-1)
+                # If there are more than two elements, add them all inversely
+                if L > 2:
+                    for i in range(2, L):
+                        Zp = (1 / Zp + 1 / Z[i]) ** (-1)
+        except ValueError or IndexError:
+            Zp = Z  # Only one impedance
+    else:
+        Z = args  # Set of Args acts as Tuple
+        # Inversely add the first two elements in tuple
+        Zp = (1 / Z[0] + 1 / Z[1]) ** (-1)
+        # If there are more than two elements, add them all inversely
+        if L > 2:
+            for i in range(2, L):
+                Zp = (1 / Zp + 1 / Z[i]) ** (-1)
+    return Zp
 
-# END
+# END
```

### Comparing `electricpy-0.2.2/electricpy/fault.py` & `electricpy-0.3.0/electricpy/fault.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,474 +1,506 @@
 ################################################################################
 """
-`electricpy.fault` - Electrical Power Engineering Faults Calculations.
+Electrical Power Engineering Faults Calculations.
 
 >>> from electricpy import fault
 """
 ################################################################################
 
-# Import Necessary Dependencies
 import numpy as _np
 import matplotlib.pyplot as _plt
 from scipy.optimize import fsolve as _fsolve
 
-# Import Local Dependencies
-from .constants import *
+from electricpy.constants import *
+from electricpy.conversions import seq_to_abc
 
-def _phaseroll(M012,reference):
+
+def _phaseroll(M012, reference):
     # Compute Dot Product
-    M = A012.dot(M012)
-    # Condition Reference:
-    reference = reference.upper()
-    if reference == 'A':
-        pass
-    elif reference == 'B':
-        M = _np.roll(M, 1, 0)
-    elif reference == 'C':
-        M = _np.roll(M, 2, 0)
-    else:
-        raise ValueError("Invalid Phase Reference.")
-    return(M)
+    return seq_to_abc(M012, reference)
+
 
 # Define Single Line to Ground Fault Function
-def phs1g(Vth,Zseq,Rf=0,sequence=True,reference='A'):
+def single_phase_to_ground_fault(Vth, Zseq, Rf=0, sequence=True, reference='A'):
     r"""
     Single-Phase-to-Ground Fault Calculator.
-    
+
     This function will evaluate the Zero, Positive, and Negative
     sequence currents for a single-line-to-ground fault.
-    
+
     .. math:: I_1 = \frac{V_{th}}{Z_0+Z_1+Z_2+3*R_f}
-    
+
     .. math:: I_2 = I_1
-    
+
     .. math:: I_0 = I_1
-    
+
     Parameters
     ----------
     Vth:        complex
                 The Thevenin-Equivalent-Voltage
     Zseq:       list of complex
                 Tupple of sequence reactances as (Z0, Z1, Z2)
     Rf:         complex, optional
                 The fault resistance, default=0
     sequence:   bool, optional
                 Control argument to force return into symmetrical-
                 or phase-domain values.
     reference:  {'A', 'B', 'C'}
                 Single character denoting the reference,
                 default='A'
-    
+
     Returns
     -------
     Ifault:     list of complex,
                 The Array of Fault Currents as (If0, If1, If2)
     """
     # Decompose Reactance Tuple
     X0, X1, X2 = Zseq
     # Ensure that X-components are imaginary
-    if(not isinstance(X0, complex)): X0 *= 1j
-    if(not isinstance(X1, complex)): X1 *= 1j
-    if(not isinstance(X2, complex)): X2 *= 1j
+    if not isinstance(X0, complex):
+        X0 *= 1j
+    if not isinstance(X1, complex):
+        X1 *= 1j
+    if not isinstance(X2, complex):
+        X2 *= 1j
     # Calculate Fault Current
-    Ifault = Vth / (X0 + X1 + X2 + 3*Rf)
-    Ifault = _np.array([ Ifault, Ifault, Ifault ])
+    Ifault = Vth / (X0 + X1 + X2 + 3 * Rf)
+    Ifault = _np.array([Ifault, Ifault, Ifault])
     # Prepare Value for return
     if not sequence:
-        Ifault = _phaseroll( Ifault, reference ) # Convert to ABC-Domain
+        Ifault = _phaseroll(Ifault, reference)  # Convert to ABC-Domain
     # Return Value
-    return(Ifault)
-    
+    return Ifault
+
+# Alias Original Name
+phs1g = single_phase_to_ground_fault
+
+
 # Define Double Line to Ground Fault Current Calculator
-def phs2g(Vth,Zseq,Rf=0,sequence=True,reference='A'):
+def double_phase_to_ground_fault(Vth, Zseq, Rf=0, sequence=True, reference='A'):
     r"""
     Double-Line-to-Ground Fault Calculator.
-    
+
     This function will evaluate the Zero, Positive, and Negative
     sequence currents for a double-line-to-ground fault.
-    
+
     .. math:: I_1 = \frac{V_{th}}{Z_1+\frac{Z_2*(Z_0+3*R_f)}{Z_0+Z_2+3*R_f}}
-    
+
     .. math:: I_2 = -\frac{V_{th}-Z_1*I_1}{X_2}
-    
+
     .. math:: I_0 = -\frac{V_{th}-Z_1*I_1}{X_0+3*R_f}
-    
+
     Parameters
     ----------
     Vth:        complex
                 The Thevenin-Equivalent-Voltage
     Zseq:       list of complex
                 Tupple of sequence reactances as (Z0, Z1, Z2)
     Rf:         complex, optional
                 The fault resistance, default=0
     sequence:   bool, optional
                 Control argument to force return into symmetrical-
                 or phase-domain values.
     reference:  {'A', 'B', 'C'}
                 Single character denoting the reference,
                 default='A'
-    
+
     Returns
     -------
     Ifault:     list of complex,
                 The Array of Fault Currents as (If0, If1, If2)
     """
     # Decompose Reactance Tuple
     X0, X1, X2 = Zseq
     # Ensure that X-components are imaginary
-    if(not isinstance(X0, complex)): X0 *= 1j
-    if(not isinstance(X1, complex)): X1 *= 1j
-    if(not isinstance(X2, complex)): X2 *= 1j
+    if not isinstance(X0, complex):
+        X0 *= 1j
+    if not isinstance(X1, complex):
+        X1 *= 1j
+    if not isinstance(X2, complex):
+        X2 *= 1j
     # Calculate Fault Currents
-    If1 = Vth / (X1 + (X2*(X0+3*Rf))/(X0+X2+3*Rf))
-    If2 = -(Vth - X1*If1)/X2
-    If0 = -(Vth - X1*If1)/(X0+3*Rf)
+    If1 = Vth / (X1 + (X2 * (X0 + 3 * Rf)) / (X0 + X2 + 3 * Rf))
+    If2 = -(Vth - X1 * If1) / X2
+    If0 = -(Vth - X1 * If1) / (X0 + 3 * Rf)
     Ifault = _np.array([If0, If1, If2])
     # Return Currents
     if not sequence:
-        Ifault = _phaseroll( Ifault, reference ) # Convert to ABC-Domain
-    return(Ifault)
+        Ifault = _phaseroll(Ifault, reference)  # Convert to ABC-Domain
+    return Ifault
+
+# Alias Original Name
+phs2g = double_phase_to_ground_fault
+
 
 # Define Phase-to-Phase Fault Current Calculator
-def phs2(Vth,Zseq,Rf=0,sequence=True,reference='A'):
+def phase_to_phase_fault(Vth, Zseq, Rf=0, sequence=True, reference='A'):
     r"""
     Line-to-Line Fault Calculator.
-    
+
     This function will evaluate the Zero, Positive, and Negative
     sequence currents for a phase-to-phase fault.
-    
+
     .. math:: I_1 = \frac{V_{th}}{Z_1+Z_2+R_f}
-    
+
     .. math:: I_2 = -I_1
-    
+
     .. math:: I_0 = 0
-    
+
     Parameters
     ----------
     Vth:        complex
                 The Thevenin-Equivalent-Voltage
     Zseq:       list of complex
                 Tupple of sequence reactances as (Z0, Z1, Z2)
     Rf:         complex, optional
                 The fault resistance, default=0
     sequence:   bool, optional
                 Control argument to force return into symmetrical-
                 or phase-domain values.
     reference:  {'A', 'B', 'C'}
                 Single character denoting the reference,
                 default='A'
-    
+
     Returns
     -------
     Ifault:     list of complex,
                 The Array of Fault Currents as (If0, If1, If2)
     """
     # Decompose Reactance Tuple
     X0, X1, X2 = Zseq
     # Ensure that X-components are imaginary
-    if(not isinstance(X0, complex)): X0 *= 1j
-    if(not isinstance(X1, complex)): X1 *= 1j
-    if(not isinstance(X2, complex)): X2 *= 1j
+    if not isinstance(X0, complex):
+        X0 *= 1j
+    if not isinstance(X1, complex):
+        X1 *= 1j
+    if not isinstance(X2, complex):
+        X2 *= 1j
     # Calculate Fault Currents
     If0 = 0
     If1 = Vth / (X1 + X2 + Rf)
     If2 = -If1
     Ifault = _np.array([If0, If1, If2])
     # Return Currents
     if not sequence:
-        Ifault = _phaseroll( Ifault, reference ) # Convert to ABC-Domain
-    return(Ifault)
+        Ifault = _phaseroll(Ifault, reference)  # Convert to ABC-Domain
+    return Ifault
+
+# Alias Original Name
+phs2 = phase_to_phase_fault
+
 
 # Define Three-Phase Fault Current Calculator
-def phs3(Vth,Zseq,Rf=0,sequence=True,reference='A'):
+def three_phase_fault(Vth, Zseq, Rf=0, sequence=True, reference='A'):
     r"""
     Three-Phase Fault Calculator.
-    
+
     This function will evaluate the Zero, Positive, and Negative
     sequence currents for a three-phase fault.
-    
+
     .. math:: I_1 = \frac{V_{th}}{Z_1+R_1}
-    
+
     .. math:: I_2 = 0
-    
+
     .. math:: I_0 = 0
-    
+
     Parameters
     ----------
     Vth:        complex
                 The Thevenin-Equivalent-Voltage
     Zseq:       list of complex
                 Tupple of sequence reactances as (Z0, Z1, Z2)
     Rf:         complex, optional
                 The fault resistance, default=0
     sequence:   bool, optional
                 Control argument to force return into symmetrical-
                 or phase-domain values.
     reference:  {'A', 'B', 'C'}
                 Single character denoting the reference,
                 default='A'
-    
+
     Returns
     -------
     Ifault:     list of complex
                 The Fault Current, equal for 0, pos., and neg. seq.
     """
     # Decompose Reactance Tuple
     X0, X1, X2 = Zseq
     # Ensure that X-components are imaginary
-    if(not isinstance(X1, complex)): X1 *= 1j
+    if not isinstance(X1, complex):
+        X1 *= 1j
     # Calculate Fault Currents
-    Ifault = Vth/(X1 + Rf)
-    Ifault = _np.array([ 0, Ifault, 0 ])
+    Ifault = Vth / (X1 + Rf)
+    Ifault = _np.array([0, Ifault, 0])
     # Prepare to Return Value
     if not sequence:
-        Ifault = _phaseroll( Ifault, reference ) # Convert to ABC-Domain
-    return(Ifault)
+        Ifault = _phaseroll(Ifault, reference)  # Convert to ABC-Domain
+    return Ifault
+
+# Alias Original Name
+phs3 = three_phase_fault
+
 
 # Define Single Pole Open Calculator
-def poleopen1(Vth,Zseq,sequence=True,reference='A'):
+def poleopen1(Vth, Zseq, sequence=True, reference='A'):
     r"""
     Single Pole Open Fault Calculator.
-    
+
     This function will evaluate the Zero, Positive, and Negative
     sequence currents for a single pole open fault.
-    
+
     .. math:: I_1 = \frac{V_{th}}{Z_1+(\frac{1}{Z_2}+\frac{1}{Z_0})^-1}
-    
+
     .. math:: I_2 = -I_1 * \frac{Z_0}{Z_2+Z_0}
-    
+
     .. math:: I_0 = -I_1 * \frac{Z_2}{Z_2+Z_0}
-    
+
     Parameters
     ----------
     Vth:        complex
                 The Thevenin-Equivalent-Voltage
     Zseq:       list of complex
                 Tupple of sequence reactances as (Z0, Z1, Z2)
     sequence:   bool, optional
                 Control argument to force return into symmetrical-
                 or phase-domain values.
     reference:  {'A', 'B', 'C'}
                 Single character denoting the reference, or the
                 faulted phase indicator; default='A'
-    
+
     Returns
     -------
     Ifault:     list of complex,
                 The Array of Fault Currents as (If0, If1, If2)
     """
     # Decompose Reactance Tuple
     X0, X1, X2 = Zseq
     # Ensure that X-components are imaginary
-    if(not isinstance(X0, complex)): X0 *= 1j
-    if(not isinstance(X1, complex)): X1 *= 1j
-    if(not isinstance(X2, complex)): X2 *= 1j
+    if not isinstance(X0, complex):
+        X0 *= 1j
+    if not isinstance(X1, complex):
+        X1 *= 1j
+    if not isinstance(X2, complex):
+        X2 *= 1j
     # Calculate Fault Currents
-    If1 = Vth / (X1 + (1/X2 + 1/X0)**(-1))
-    If2 = -If1 * X0/(X2 + X0)
-    If0 = -If1 * X2/(X2 + X0)
+    If1 = Vth / (X1 + (1 / X2 + 1 / X0) ** (-1))
+    If2 = -If1 * X0 / (X2 + X0)
+    If0 = -If1 * X2 / (X2 + X0)
     Ifault = _np.array([If0, If1, If2])
     # Return Currents
     if not sequence:
-        Ifault = _phaseroll( Ifault, reference ) # Convert to ABC-Domain
-    return(Ifault)
+        Ifault = _phaseroll(Ifault, reference)  # Convert to ABC-Domain
+    return Ifault
+
 
 # Define Double Pole Open Calculator
-def poleopen2(Vth,Zseq,sequence=True,reference='A'):
+def poleopen2(Vth, Zseq, sequence=True, reference='A'):
     r"""
     Single Pole Open Fault Calculator.
-    
+
     This function will evaluate the Zero, Positive, and Negative
     sequence currents for a single pole open fault.
-    
+
     .. math:: I_1 = \frac{V_{th}}{Z_1+Z_2+Z_0}
-    
+
     .. math:: I_2 = I_1
-    
+
     .. math:: I_0 = I_1
-    
+
     Parameters
     ----------
     Vth:        complex
                 The Thevenin-Equivalent-Voltage
     Zseq:       list of complex
                 Tupple of sequence reactances as (Z0, Z1, Z2)
     sequence:   bool, optional
                 Control argument to force return into symmetrical-
                 or phase-domain values.
     reference:  {'A', 'B', 'C'}
                 Single character denoting the reference, or the
                 faulted phase indicator; default='A'
-    
+
     Returns
     -------
     Ifault:     list of complex,
                 The Array of Fault Currents as (If0, If1, If2)
     """
     # Decompose Reactance Tuple
     X0, X1, X2 = Zseq
     # Ensure that X-components are imaginary
-    if(not isinstance(X0, complex)): X0 *= 1j
-    if(not isinstance(X1, complex)): X1 *= 1j
-    if(not isinstance(X2, complex)): X2 *= 1j
+    if not isinstance(X0, complex):
+        X0 *= 1j
+    if not isinstance(X1, complex):
+        X1 *= 1j
+    if not isinstance(X2, complex):
+        X2 *= 1j
     # Calculate Fault Currents
     If1 = Vth / (X1 + X2 + X0)
     If2 = If1
     If0 = If1
     Ifault = _np.array([If0, If1, If2])
     # Return Currents
     if not sequence:
-        Ifault = _phaseroll( Ifault, reference ) # Convert to ABC-Domain
-    return(Ifault)
+        Ifault = _phaseroll(Ifault, reference)  # Convert to ABC-Domain
+    return Ifault
+
 
 # Define MVA Short Circuit
-def scMVA(Zth=None,Isc=None,Vth=1):
+def short_circuit_mva(Zth=None, Isc=None, Vth=1):
     r"""
     Short-Circuit MVA Calculator.
-    
+
     Function defines a method of interpretively
     calculating the short-circuit MVA value
     given two of the three arguments. The formulas
     are all based around the following:
-    
+
     .. math:: MVA_{sc} = V_{th}*I_{sc}
-    
+
     .. math:: V_{th} = I_{sc}*Z_{th}
-    
+
     Parameters
     ----------
     Zth:        float
                 The Thevenin-Equivalent-Impedance
     Isc:        float, optional
                 Short-Circuit-Current, if left as
                 None, will force function to use
                 default setting for Vth.
                 default=None
     Vth:        float, optional
                 The Thevenin-Equivalent-Voltage,
                 defaults to a 1-per-unit value.
                 default=1
-    
+
     Returns
     -------
     MVA:        float
                 Short-Circuit MVA, not described
                 as three-phase or otherwise, such
                 determination is dependent upon
                 inputs.
     """
     # Test for too few inputs
-    if not any((Zth,Isc)):
+    if not any((Zth, Isc)):
         raise ValueError("Either Zth or Isc must be specified.")
     # Condition Inputs
     if Zth is not None:
         Zth = abs(Zth)
     if Isc is not None:
         Isc = abs(Isc)
     if Vth != 1:
         Vth = abs(Vth)
     # Calculate MVA from one of the available methods
-    if all((Zth,Isc)):
-        MVA = Isc**2 * Zth
-    elif all((Zth,Vth)):
-        MVA = Vth**2 / Zth
+    if all((Zth, Isc)):
+        MVA = Isc ** 2 * Zth
+    elif all((Zth, Vth)):
+        MVA = Vth ** 2 / Zth
     else:
         MVA = Vth * Isc
     # Return Value
-    return(MVA)
+    return MVA
+
+# Alias Original Name
+scMVA = short_circuit_mva
+
 
 # Define Explicitly 3-Phase MVAsc Calculator
-def phs3mvasc(Vth,Zseq,Rf=0,Sbase=1):
+def phs3mvasc(Vth, Zseq, Rf=0, Sbase=1):
     r"""
     Three-Phase MVA Short-Circuit Calculator.
-    
+
     Calculator to evaluate the Short-Circuit MVA of a three-phase fault given the system
     parameters of Vth, Zseq, and an optional Rf. Uses the formula as follows:
-    
+
     .. math:: MVA_{sc} = \frac{\left|V_{th}^2\right|}{|Z_1|} * Sbase
-    
+
     Parameters
     ----------
     Vth:        complex
                 The Thevenin-Equivalent-Voltage
     Zseq:       list of complex
                 Tupple of sequence reactances as (Z0, Z1, Z2)
     Rf:         complex, optional
                 The fault resistance, default=0
     Sbase:      real, optional
                 The per-unit base for power. default=1
-    
+
     Returns
     -------
     MVA:        real
                 Three-Phase Short-Circuit MVA.
     """
     # Calculate Three-Phase MVA
-    MVA = abs(Vth)**2 / abs(Zseq[1]) * Sbase
+    MVA = abs(Vth) ** 2 / abs(Zseq[1]) * Sbase
     # Scale VA to MVA if Sbase is not 1
     if Sbase != 1:
-        MVA = MVA * 1e-6 # Divide by 1e6 (M)
+        MVA = MVA * 1e-6  # Divide by 1e6 (M)
     # Return
-    return(MVA)
-    
-    
+    return MVA
+
+
 # Define Explicitly 1-Phase MVAsc Calculator
-def phs1mvasc(Vth,Zseq,Rf=0,Sbase=1):
+def phs1mvasc(Vth, Zseq, Rf=0, Sbase=1):
     r"""
     Single-Phase MVA Short-Circuit Calculator.
-    
+
     Calculator to evaluate the Short-Circuit MVA of a single-phase fault given the system
     parameters of Vth, Zseq, and an optional Rf. Uses the formula as follows:
-    
+
     .. math:: MVA_{sc} = \left|I_1^2\right|*|Z_1| * Sbase
-    
+
     where:
-    
+
     .. math:: I_1 = \frac{V_{th}}{Z_0+Z_1+Z_2+3*R_f}
-    
+
     Parameters
     ----------
     Vth:        complex
                 The Thevenin-Equivalent-Voltage
     Zseq:       list of complex
                 Tupple of sequence reactances as (Z0, Z1, Z2)
     Rf:         complex, optional
                 The fault resistance, default=0
     Sbase:      real, optional
                 The per-unit base for power. default=1
-    
+
     Returns
     -------
     MVA:        real
                 Single-Phase Short-Circuit MVA.
     """
     # Decompose Reactance Tuple
     X0, X1, X2 = Zseq
     # Ensure that X-components are imaginary
-    if(not isinstance(X0, complex)): X0 *= 1j
-    if(not isinstance(X1, complex)): X1 *= 1j
-    if(not isinstance(X2, complex)): X2 *= 1j
+    if not isinstance(X0, complex):
+        X0 *= 1j
+    if not isinstance(X1, complex):
+        X1 *= 1j
+    if not isinstance(X2, complex):
+        X2 *= 1j
     # Calculate Fault Current
-    Ifault = Vth / (X0 + X1 + X2 + 3*Rf)
+    Ifault = Vth / (X0 + X1 + X2 + 3 * Rf)
     # Calculate MVA
-    MVA = abs(Ifault)**2 * abs(X1) * Sbase
+    MVA = abs(Ifault) ** 2 * abs(X1) * Sbase
     # Scale VA to MVA if Sbase is not 1
     if Sbase != 1:
-        MVA = MVA * 1e-6 # Divide by 1e6 (M)
+        MVA = MVA * 1e-6  # Divide by 1e6 (M)
     # Return
-    return(MVA)
+    return MVA
+
 
 # Define Faulted Bus Voltage Calculator
-def busvolt(k,n,Vpf,Z0,Z1,Z2,If,sequence=True,reference='A'):
+def busvolt(k, n, Vpf, Z0, Z1, Z2, If, sequence=True, reference='A'):
     """
     Faulted Bus Voltage Calculator.
-    
+
     This function is designed to calculate the bus voltage(s)
     given a specific set of fault characteristics.
-    
+
     Parameters
     ----------
     k:          float
                 Bus index at which to calculate faulted voltage
     n:          float
                 Bus index at which fault occurred
     Vpf:        complex
@@ -483,55 +515,56 @@
                 Sequence Fault Current Evaluated at Bus *n*
     sequence:   bool, optional
                 Control argument to force return into symmetrical-
                 or phase-domain values.
     reference:  {'A', 'B', 'C'}
                 Single character denoting the reference,
                 default='A'
-    
+
     Returns
     -------
     Vf:         complex
                 The Fault Voltage, set of sequence or phase voltages as
                 specified by *sequence*
     """
     # Condition Inputs
-    k = k-1
-    n = n-1
+    k = k - 1
+    n = n - 1
     Z0 = _np.asarray(Z0)
     Z1 = _np.asarray(Z1)
     Z2 = _np.asarray(Z2)
     If = _np.asarray(If)
     # Generate Arrays For Calculation
     Vfmat = _np.array([0, Vpf, 0]).T
-    Zmat = _np.array([[Z0[k,n], 0, 0],
-                     [0, Z1[k,n], 0],
-                     [0, 0, Z2[k,n]]])
+    Zmat = _np.array([[Z0[k, n], 0, 0],
+                      [0, Z1[k, n], 0],
+                      [0, 0, Z2[k, n]]])
     # Perform Calculation
     Vf = Vfmat - Zmat.dot(If)
     if not sequence:
-        Vf = _phaseroll( Vf, reference ) # Convert to ABC-Domain
-    return(Vf)
+        Vf = _phaseroll(Vf, reference)  # Convert to ABC-Domain
+    return Vf
 
 
 # Define CT Saturation Function
-def ct_saturation(XoR,Imag,Vrated,Irated,CTR,Rb,Xb,remnance=0,freq=60,ALF=20):
+def ct_saturation(XoR, Imag, Vrated, Irated, CTR, Rb, Xb, remnance=0, freq=60,
+                  ALF=20):
     r"""
     Electrical Current Transformer Saturation Calculator.
-    
+
     A function to determine the saturation value and a boolean indicator
     showing whether or not CT is -in fact- saturated.
-    
+
     To perform this evaluation, we must satisfy the equation:
-    
+
     .. math::
        20\geq(1+\frac{X}{R})*\frac{|I_{mag}|}{I_{rated}*CTR}
        *\frac{\left|R_{burden}+j*\omega*\frac{X_{burden}}
        {\omega}\right|*100}{V_{rated}*(1-remnanc)}
-    
+
     Parameters
     ----------
     XoR:        float
                 The X-over-R ratio of the system.
     Imag:       float
                 The (maximum) current magnitude to use for calculation,
                 typically the fault current.
@@ -549,67 +582,67 @@
     remnance:   float, optional
                 The system flux remnance, default=0.
     freq:       float, optional
                 The system frequency in Hz, default=60.
     ALF:        float, optional
                 The Saturation Constant which must be satisfied,
                 default=20.
-    
+
     Returns
     -------
     result:     float
                 The calculated Saturation value.
     saturation: bool
                 Boolean indicator to mark presence of saturation.
     """
     # Define omega
-    w = 2*_np.pi*freq
+    w = 2 * _np.pi * freq
     # Find Lb
-    Lb = Xb/w
+    Lb = Xb / w
     # Re-evaluate Vrated
-    Vrated = Vrated*(1-remnance)
+    Vrated = Vrated * (1 - remnance)
     # Calculate each "term" (multiple)
-    t1 = (1+XoR)
-    t2 = (Imag/(Irated*CTR))
-    t3 = abs(Rb+1j*w*Lb)*100/Vrated
+    t1 = (1 + XoR)
+    t2 = (Imag / (Irated * CTR))
+    t3 = abs(Rb + 1j * w * Lb) * 100 / Vrated
     # Evaluate
-    result = t1*t2*t3
+    result = t1 * t2 * t3
     # Test for saturation
     saturation = result >= ALF
     # Return Results
-    return(result,saturation)
+    return result, saturation
 
 
 # Define C-Class Calculator
-def ct_cclass(XoR,Imag,Irated,CTR,Rb,Xb,remnance=0,sat_crit=20):
+def ct_cclass(XoR, Imag, Irated, CTR, Rb, Xb, remnance=0, sat_crit=20):
     r"""
     Electrical Current Transformer (CT) C-Class Function.
-    
+
     A function to determine the C-Class rated voltage for a CT.
     The formula shown below demonstrates the standard formula
     which is normally used to evaluate the saturation criteria.
     Worth noting here, is the fact that :math:`V_{rated}` is the
     CT C-Class.
-    
+
     .. math::
        \text{Saturation Criteria}=\frac{(1+\frac{X}{R})\cdot
        \frac{|I_{mag}|}{I_{rated}\cdot CTR}\cdot\frac{\left|
        R_{burden}+j\cdot X_{burden}\right|\cdot100}{V_{rated}}}
        {1-remnance}
-    
+
     For the purposes of this function, the above formula is applied
     as follows to evaluate the CT C-Class such as to satisfy the
     saturation criteria defined.
-    
+
     .. math::
        \text{CT C-Class}=\frac{(1+\frac{X}{R})\cdot
        \frac{|I_{mag}|}{I_{rated}\cdot CTR}\cdot\frac{
        \left|R_{burden}+j\cdot X_{burden}\right|\cdot100}
        {\text{Saturation Criteria (i.e., 20)}}}{1-remnance}
-    
+
     Parameters
     ----------
     XoR:        float
                 The X-over-R ratio of the system.
     Imag:       float
                 The (maximum) current magnitude to use for calculation,
                 typically the fault current.
@@ -623,105 +656,106 @@
                 The total burden reactance in ohms.
     remnance:   float, optional
                 The system flux remnance, default=0.
     sat_crit:   float, optional
                 The saturation criteria which must be satisfied,
                 typically such that CT saturation will not occur,
                 default=20.
-    
+
     Returns
     -------
     c_class:    float
                 The calculated C-Class rated voltage.
     """
     # Calculate each "term" (multiple)
-    t1 = (1+XoR)
-    t2 = (Imag/(Irated*CTR))
-    t3 = abs(Rb+1j*Xb)*100/sat_crit
+    t1 = (1 + XoR)
+    t2 = (Imag / (Irated * CTR))
+    t3 = abs(Rb + 1j * Xb) * 100 / sat_crit
     # Evaluate
-    Vr_w_rem = t1*t2*t3
-    c_class = Vr_w_rem/(1-remnance)
+    Vr_w_rem = t1 * t2 * t3
+    c_class = Vr_w_rem / (1 - remnance)
     # Return Result
-    return(c_class)
+    return c_class
 
 
 # Define Saturation Voltage at Rated Burden
-def ct_satratburden(Inom,VArat=None,ANSIv=None,ALF=20,):
+def ct_satratburden(Inom, VArat=None, ANSIv=None, ALF=20, ):
     r"""
     Electrical Current Transformer (CT) Saturation at Rated Burden Calculator.
-    
+
     A function to determine the Saturation at rated burden.
-    
+
     .. math:: V_{saturated}=ALF*\frac{VA_{rated}}{I_{nominal}}
-    
+
     where:
-    
+
     .. math:: VA_{rated}=I_{nominal}*\frac{ANSI_{voltage}}{20}
-    
+
     Parameters
     ----------
     Inom:       float
                 Nominal Current
     VArat:      float, optional, exclusive
                 The apparent power (VA) rating of the CT.
     ANSIv:      float, optional, exclusive
                 The ANSI voltage requirement to meet.
     ALF:        float, optional
                 Accuracy Limit Factor, default=20.
-    
+
     Returns
     -------
     Vsat:       float
                 The saturated voltage.
     """
     # Validate Inputs
-    if VArat == None and ANSIv == None:
+    if VArat is None and ANSIv is None:
         raise ValueError("VArat or ANSIv must be specified.")
-    elif VArat==None:
+    elif VArat is None:
         # Calculate VArat from ANSIv
-        VArat = Inom*ANSIv/(20)
+        VArat = Inom * ANSIv / (20)
     # Determine Vsaturation
-    Vsat = ALF * VArat/Inom
-    return(Vsat)
+    Vsat = ALF * VArat / Inom
+    return Vsat
 
 
 # Define CT Vpeak Formula
-def ct_vpeak(Zb,Ip,CTR):
+def ct_vpeak(Zb, Ip, CTR):
     r"""
     Electrical Current Transformer (CT) Peak Voltage Calculator.
-    
+
     Simple formula to calculate the Peak Voltage of a CT.
-    
+
     .. math:: \sqrt{3.5*|Z_burden|*I_{peak}*CTR}
-    
+
     Parameters
     ----------
     Zb:         float
                 The burden impedance magnitude (in ohms).
     Ip:         float
                 The peak current for the CT.
     CTR:        float
                 The CTR turns ratio of the CT.
-    
+
     Returns
     -------
     Vpeak:      float
                 The peak voltage.
     """
-    return(_np.sqrt(3.5*abs(Zb)*Ip*CTR))
+    return _np.sqrt(3.5 * abs(Zb) * Ip * CTR)
 
 
 # Define Saturation Time Calculator
-def ct_timetosat(Vknee,XoR,Rb,CTR,Imax,ts=None,npts=100,freq=60,plot=False):
+def ct_timetosat(Vknee, XoR, Rb, CTR, Imax, ts=None, npts=100, freq=60,
+                 plot=False):
     r"""
     Electrical Current Transformer (CT) Time to Saturation Function.
-    
+
     Function to determine the "time to saturate" for an underrated C-Class
     CT using three standard curves described by Juergen Holbach.
-    
+
     Parameters
     ----------
     Vknee:      float
                 The knee-voltage for the CT.
     XoR:        float
                 The X-over-R ratio of the system.
     Rb:         float
@@ -740,62 +774,63 @@
     freq:       float, optional
                 The system frequency in Hz, default=60.
     plot:       bool, optional
                 Control argument to enable plotting of calculated curves,
                 default=False.
     """
     # Calculate omega
-    w = 2*_np.pi*freq
+    w = 2 * _np.pi * freq
     # Calculate Tp
-    Tp = XoR/w
+    Tp = XoR / w
     # If ts isn't specified, generate it
-    if ts==None:
-        ts = _np.linspace(0,0.1,freq*npts)
+    if ts is None:
+        ts = _np.linspace(0, 0.1, freq * npts)
     # Calculate inner term
-    term = -XoR*(_np.exp(-ts/Tp)-1)
+    term = -XoR * (_np.exp(-ts / Tp) - 1)
     # Calculate Vsaturation terms
-    Vsat1 = Imax*Rb*(term+1)
-    Vsat2 = Imax*Rb*(term-_np.sin(w*ts))
-    Vsat3 = Imax*Rb*(1-_np.cos(w*ts))
+    Vsat1 = Imax * Rb * (term + 1)
+    Vsat2 = Imax * Rb * (term - _np.sin(w * ts))
+    Vsat3 = Imax * Rb * (1 - _np.cos(w * ts))
     # If plotting requested
-    if plot and isinstance(ts,_np.ndarray):
-        _plt.plot(ts,Vsat1,label="Vsat1")
-        _plt.plot(ts,Vsat2,label="Vsat2")
-        _plt.plot(ts,Vsat3,label="Vsat3")
-        _plt.axhline(Vknee,label="V-knee",linestyle='--')
+    if plot and isinstance(ts, _np.ndarray):
+        _plt.plot(ts, Vsat1, label="Vsat1")
+        _plt.plot(ts, Vsat2, label="Vsat2")
+        _plt.plot(ts, Vsat3, label="Vsat3")
+        _plt.axhline(Vknee, label="V-knee", linestyle='--')
         _plt.title("Saturation Curves")
         _plt.xlabel("Time (ts)")
         _plt.legend()
         _plt.show()
     elif plot:
         print("Unable to plot a single point, *ts* must be a numpy-array.")
     # Determine the crossover points for each saturation curve
     Vsat1c = Vsat2c = Vsat3c = 0
-    if isinstance(ts,_np.ndarray):
+    if isinstance(ts, _np.ndarray):
         for i in range(len(ts)):
-            if Vsat1[i]>Vknee and Vsat1c==0:
-                Vsat1c = ts[i-1]
-            if Vsat2[i]>Vknee and Vsat2c==0:
-                Vsat2c = ts[i-1]
-            if Vsat3[i]>Vknee and Vsat3c==0:
-                Vsat3c = ts[i-1]
-        results = (Vsat1c,Vsat2c,Vsat3c)
+            if Vsat1[i] > Vknee and Vsat1c == 0:
+                Vsat1c = ts[i - 1]
+            if Vsat2[i] > Vknee and Vsat2c == 0:
+                Vsat2c = ts[i - 1]
+            if Vsat3[i] > Vknee and Vsat3c == 0:
+                Vsat3c = ts[i - 1]
+        results = (Vsat1c, Vsat2c, Vsat3c)
     else:
-        results = (Vsat1,Vsat2,Vsat3)
-    return(results)
+        results = (Vsat1, Vsat2, Vsat3)
+    return results
+
 
 # Define Function to Calculate TRV
-def pktransrecvolt(C,L,R=0,VLL=None,VLN=None,freq=60):
+def pktransrecvolt(C, L, R=0, VLL=None, VLN=None, freq=60):
     """
     Peak Transient Recovery Function.
-    
+
     Peak Transient Recovery Voltage calculation function, evaluates the peak
     transient recovery voltage (restriking voltage) and the
     Rate-of-Rise-Recovery Voltage.
-    
+
     Parameters
     ----------
     C:          float
                 Capacitance Value in Farads.
     L:          float
                 Inductance in Henries.
     R:          float, optional
@@ -805,187 +840,193 @@
                 Line-to-Line voltage, exclusive
                 optional argument.
     VLN:        float, exclusive
                 Line-to-Neutral voltage, exclusive
                 optional argument.
     freq:       float, optional
                 System frequency in Hz.
-    
+
     Returns
     -------
     Vcpk:       float
                 Peak Transient Recovery Voltage in volts.
     RRRV:       float
                 The RRRV (Rate-of-Rise-Recovery Voltage)
                 calculated given the parameters in volts
                 per second.
     """
     # Evaluate alpha, omega-n, and fn
-    alpha = R/(2*L)
-    wn = 1/_np.sqrt(L*C) - alpha
-    fn = wn/(2*_np.pi)
+    alpha = R / (2 * L)
+    wn = 1 / _np.sqrt(L * C) - alpha
+    fn = wn / (2 * _np.pi)
     # Evaluate Vm
-    if VLL!=None:
-        Vm = _np.sqrt(2/3)*VLL
-    elif VLN!=None:
-        Vm = _np.sqrt(2)*VLN
+    if VLL is not None:
+        Vm = _np.sqrt(2 / 3) * VLL
+    elif VLN is not None:
+        Vm = _np.sqrt(2) * VLN
     else:
         raise ValueError("One voltage must be specified.")
     # Evaluate Vcpk (worst case)
-    Vcpk = wn**2/(wn**2-2*_np.pi*freq)*Vm*2
+    Vcpk = wn ** 2 / (wn ** 2 - 2 * _np.pi * freq) * Vm * 2
     # Evaluate RRRV
-    RRRV = 2*Vm*fn/0.5
-    return(Vcpk,RRRV)
+    RRRV = 2 * Vm * fn / 0.5
+    return Vcpk, RRRV
+
 
 # Define TRV Reduction Resistor Function
-def trvresistor(C,L,reduction,Rd0=500,wd0=260e3,tpk0=10e-6):
+def trvresistor(C, L, reduction, Rd0=500, wd0=260e3, tpk0=10e-6):
     """
     Transient Recovery Voltage (TRV) Reduction Resistor Function.
-    
+
     Function to find the resistor value that will reduce the TRV by a specified
     percentage.
-    
+
     Parameters
     ----------
     C:          float
                 Capacitance Value in Farads.
     L:          float
                 Inductance in Henries.
     reduction:  float
                 The percentage that the TRV should be reduced by.
     Rd0:        float, optional
                 Damping Resistor Evaluation Starting Point, default=500
     wd0:        float, optional
                 Omega-d evaluation starting point, default=260*k
     tpk0:       float, optional
                 Time of peak voltage evaluation starting point, default=10*u
-    
+
     Returns
     -------
     Rd:         float
                 Damping resistor value, in ohms.
     wd:         float
                 Omega-d
     tpk:        float
                 Time of peak voltage.
     """
     # Evaluate omega-n
-    wn = 1/_np.sqrt(L*C)
+    wn = 1 / _np.sqrt(L * C)
     # Generate Constant Factor
-    fctr = (1-reduction)*2 - 1
+    fctr = (1 - reduction) * 2 - 1
+
     # Define Function Set
     def equations(data):
         Rd, wd, tpk = data
-        X = _np.sqrt(wn**2-(1/(2*Rd*C))**2) - wd
-        Y = _np.exp(-tpk/(2*Rd*C))-fctr
-        Z = wd*tpk - _np.pi
-        return(X,Y,Z)
-    Rd, wd, tpk = _fsolve(equations, (Rd0,wd0,tpk0))
-    return(Rd, wd, tpk)
+        X = _np.sqrt(wn ** 2 - (1 / (2 * Rd * C)) ** 2) - wd
+        Y = _np.exp(-tpk / (2 * Rd * C)) - fctr
+        Z = wd * tpk - _np.pi
+        return (X, Y, Z)
+
+    Rd, wd, tpk = _fsolve(equations, (Rd0, wd0, tpk0))
+    return Rd, wd, tpk
+
 
 # Define Time-Overcurrent Trip Time Function
-def toctriptime(I,Ipickup,TD,curve="U1",CTR=1):
+def toctriptime(I, Ipickup, TD, curve="U1", CTR=1):
     """
     Time OverCurrent Trip Time Function.
-    
+
     Time-OverCurrent Trip Time Calculator, evaluates the time
     to trip for a specific TOC (51) element given the curve
     type, current characteristics and time-dial setting.
-    
+
     Parameters
     ----------
     I:          float
                 Measured Current in Amps
     Ipickup:    float
                 Fault Current Pickup Setting (in Amps)
     TD:         float
                 Time Dial Setting
     curve:      string, optional
                 Name of specified TOC curve, may be entry from set:
                 {U1,U2,U3,U4,U5,C1,C2,C3,C4,C5}, default=U1
     CTR:        float, optional
                 Current Transformer Ratio, default=1
-    
+
     Returns
     -------
     tt:         float
                 Time-to-Trip for characterized element.
     """
     # Condition Inputs
     curve = curve.upper()
     # Define Dictionary of Constants
-    const = {   "U1" : {"A": 0.0104, "B": 0.2256, "P": 0.02},
-                "U2" : {"A": 5.95, "B": 0.180, "P": 2.00},
-                "U3" : {"A": 3.88, "B": 0.0963, "P": 2.00},
-                "U4" : {"A": 5.67, "B": 0.352, "P": 2.00},
-                "U5" : {"A": 0.00342, "B": 0.00262, "P": 0.02},
-                "C1" : {"A": 0.14, "B":0, "P": 0.02},
-                "C2" : {"A": 13.5, "B":0, "P": 2.00},
-                "C3" : {"A": 80.0, "B":0, "P": 2.00},
-                "C4" : {"A": 120.0, "B":0, "P": 2.00},
-                "C5" : {"A": 0.05, "B":0, "P": 0.04}}
+    const = {"U1": {"A": 0.0104, "B": 0.2256, "P": 0.02},
+             "U2": {"A": 5.95, "B": 0.180, "P": 2.00},
+             "U3": {"A": 3.88, "B": 0.0963, "P": 2.00},
+             "U4": {"A": 5.67, "B": 0.352, "P": 2.00},
+             "U5": {"A": 0.00342, "B": 0.00262, "P": 0.02},
+             "C1": {"A": 0.14, "B": 0, "P": 0.02},
+             "C2": {"A": 13.5, "B": 0, "P": 2.00},
+             "C3": {"A": 80.0, "B": 0, "P": 2.00},
+             "C4": {"A": 120.0, "B": 0, "P": 2.00},
+             "C5": {"A": 0.05, "B": 0, "P": 0.04}}
     # Load Constants
     A = const[curve]["A"]
     B = const[curve]["B"]
     P = const[curve]["P"]
     # Evaluate M
     M = I / (CTR * Ipickup)
     # Evaluate Trip Time
-    tt = TD * (A/(M**P-1)+B)
-    return(tt)
+    tt = TD * (A / (M ** P - 1) + B)
+    return tt
+
 
 # Define Time Overcurrent Reset Time Function
-def tocreset(I,Ipickup,TD,curve="U1",CTR=1):
+def tocreset(I, Ipickup, TD, curve="U1", CTR=1):
     """
     Time OverCurrent Reset Time Function.
-    
+
     Function to calculate the time to reset for a TOC
     (Time-OverCurrent, 51) element.
-    
+
     Parameters
     ----------
     I:          float
                 Measured Current in Amps
     Ipickup:    float
                 Fault Current Pickup Setting (in Amps)
     TD:         float
                 Time Dial Setting
     curve:      string, optional
                 Name of specified TOC curve, may be entry from set:
                 {U1,U2,U3,U4,U5,C1,C2,C3,C4,C5}, default=U1
     CTR:        float, optional
                 Current Transformer Ratio, default=1
-    
+
     Returns
     -------
     tr:         float
                 Time-to-Reset for characterized element.
     """
     # Condition Inputs
     curve = curve.upper()
     # Define Dictionary of Constants
-    C = {   "U1" : 1.08,"U2" : 5.95,"U3" : 3.88,
-            "U4" : 5.67,"U5" : 0.323,"C1" : 13.5,
-            "C2" : 47.3,"C3" : 80.0,"C4" : 120.0,
-            "C5" : 4.85}
+    C = {"U1": 1.08, "U2": 5.95, "U3": 3.88,
+         "U4": 5.67, "U5": 0.323, "C1": 13.5,
+         "C2": 47.3, "C3": 80.0, "C4": 120.0,
+         "C5": 4.85}
     # Evaluate M
     M = I / (CTR * Ipickup)
     # Evaluate Reset Time
-    tr = TD * (C[curve]/(1-M**2))
-    return(tr)
+    tr = TD * (C[curve] / (1 - M ** 2))
+    return tr
+
 
 # Define Pickup Current Calculation
-def pickup(Iloadmax,Ifaultmin,scale=0,printout=False,units="A"):
+def pickup(Iloadmax, Ifaultmin, scale=0, printout=False, units="A"):
     """
     Electrical Current Pickup Selection Assistant.
-    
+
     Used to assist in evaluating an optimal phase-over-current pickup
     setting. Uses maximum load and minimum fault current to provide
     user assistance.
-    
+
     Parameters
     ----------
     Iloadmax:   float
                 The maximum load current in amps.
     Ifaultmin:  float
                 The minimum fault current in amps.
     scale:      int, optional
@@ -993,46 +1034,47 @@
                 default=0
     printout:   boolean, optional
                 Control argument to enable printing of intermediate
                 stages, default=False.
     units:      string, optional
                 String to be appended to any printed output denoting
                 the units of which are being printed, default="A"
-    
+
     Returns
     -------
     setpoint:   float
                 The evaluated setpoint at which the function suggests
                 the phase-over-current pickup setting be placed.
     """
-    IL2 = 2*Iloadmax
-    IF2 = Ifaultmin/2
+    IL2 = 2 * Iloadmax
+    IF2 = Ifaultmin / 2
     exponent = len(str(IL2).split('.')[0])
-    setpoint = _np.ceil(IL2*10**(-exponent+1+scale))*10**(exponent-1-scale)
+    setpoint = _np.ceil(IL2 * 10 ** (-exponent + 1 + scale)) * 10 ** (exponent - 1 - scale)
     if printout:
-        print("Range Min:",IL2,units,"\t\tRange Max:",IF2,units)
+        print("Range Min:", IL2, units, "\t\tRange Max:", IF2, units)
     if IF2 < setpoint:
         setpoint = IL2
         if IL2 > IF2:
             raise ValueError("Invalid Parameters.")
     if printout:
-        print("Current Pickup:",setpoint,units)
-    return(setpoint)
+        print("Current Pickup:", setpoint, units)
+    return setpoint
+
 
 # Define Time-Dial Coordination Function
-def tdradial(I,CTI,Ipu_up,Ipu_dn=0,TDdn=0,curve="U1",scale=2,freq=60,
-                  CTR_up=1,CTR_dn=1,tfixed=None):
+def tdradial(I, CTI, Ipu_up, Ipu_dn=0, TDdn=0, curve="U1", scale=2, freq=60,
+             CTR_up=1, CTR_dn=1, tfixed=None):
     """
     Radial Time Dial Coordination Function.
-    
+
     Function to evaluate the Time-Dial (TD) setting in radial schemes
     where the Coordinating Time Interval (CTI) and the up/downstream
     pickup settings are known along with the TD setting for the
     downstream protection.
-    
+
     Parameters
     ----------
     I:          float
                 Measured fault current in Amps, typically set using the
                 maximum fault current available.
     CTI:        float
                 Coordinating Time Interval in cycles.
@@ -1061,155 +1103,155 @@
                 default=1
     tfixed:     float, optional
                 Used to specify a fixed time delay for coordinated
                 protection elements, primarily used for coordinating
                 TOC elements (51) with OC elements (50) with a fixed
                 tripping time. Overrides downstream TOC arguments
                 including *Ipu_dn* and *TDdn*.
-    
+
     Returns
     -------
     TD:         float
                 Calculated Time-Dial setting according to radial
                 scheme logical analysis.
     """
     # Condition Inputs
     curve = curve.upper()
     # Define Dictionary of Constants
-    const = {   "U1" : {"A": 0.0104, "B": 0.2256, "P": 0.02},
-                "U2" : {"A": 5.95, "B": 0.180, "P": 2.00},
-                "U3" : {"A": 3.88, "B": 0.0963, "P": 2.00},
-                "U4" : {"A": 5.67, "B": 0.352, "P": 2.00},
-                "U5" : {"A": 0.00342, "B": 0.00262, "P": 0.02},
-                "C1" : {"A": 0.14, "B":0, "P": 0.02},
-                "C2" : {"A": 13.5, "B":0, "P": 2.00},
-                "C3" : {"A": 80.0, "B":0, "P": 2.00},
-                "C4" : {"A": 120.0, "B":0, "P": 2.00},
-                "C5" : {"A": 0.05, "B":0, "P": 0.04}}
+    const = {"U1": {"A": 0.0104, "B": 0.2256, "P": 0.02},
+             "U2": {"A": 5.95, "B": 0.180, "P": 2.00},
+             "U3": {"A": 3.88, "B": 0.0963, "P": 2.00},
+             "U4": {"A": 5.67, "B": 0.352, "P": 2.00},
+             "U5": {"A": 0.00342, "B": 0.00262, "P": 0.02},
+             "C1": {"A": 0.14, "B": 0, "P": 0.02},
+             "C2": {"A": 13.5, "B": 0, "P": 2.00},
+             "C3": {"A": 80.0, "B": 0, "P": 2.00},
+             "C4": {"A": 120.0, "B": 0, "P": 2.00},
+             "C5": {"A": 0.05, "B": 0, "P": 0.04}}
     # Load Constants
     A = const[curve]["A"]
     B = const[curve]["B"]
     P = const[curve]["P"]
-    if tfixed == None:
+    if tfixed is None:
         # Evaluate in seconds from cycles
-        CTI = CTI/freq
+        CTI = CTI / freq
         # Evaluate M
         M = I / (CTR_dn * Ipu_dn)
         # Evaluate Trip Time
-        tpu_desired = TDdn * (A/(M**P-1)+B) + CTI
+        tpu_desired = TDdn * (A / (M ** P - 1) + B) + CTI
     else:
         tpu_desired = tfixed + CTI
     # Re-Evaluate M
     M = I / (CTR_up * Ipu_up)
     # Calculate TD setting
-    TD = tpu_desired / (A/(M**2-1)+B)
+    TD = tpu_desired / (A / (M ** 2 - 1) + B)
     # Scale and Round
-    TD = _np.floor(TD*10**scale)/10**scale
-    return(TD)
+    TD = _np.floor(TD * 10 ** scale) / 10 ** scale
+    return TD
+
 
 # Define TAP Calculator
-def protectiontap(S,CTR=1,VLN=None,VLL=None):
+def protectiontap(S, CTR=1, VLN=None, VLL=None):
     """
     Protection TAP Setting Calculator.
-    
+
     Evaluates the required TAP setting based on the rated power of
     a transformer (the object being protected) and the voltage
     (either primary or secondary) in conjunction with the CTR
     (current transformer ratio) for the side in question (primary/
     secondary).
-    
+
     Parameters
     ----------
     CTR:        float
                 The Current Transformer Ratio.
     S:          float
                 Rated apparent power magnitude (VA/VAR/W).
     VLN:        float, exclusive
                 Line-to-Neutral voltage in volts.
     VLL:        float, exclusive
                 Line-to-Line voltage in volts.
-    
+
     Returns
     -------
     TAP:        float
                 The TAP setting required to meet the specifications.
     """
     # Condition Voltage(s)
-    if VLL != None:
-        V = abs(_np.sqrt(3)*VLL)
-    elif VLN != None:
+    if VLL is not None:
+        V = abs(_np.sqrt(3) * VLL)
+    elif VLN is not None:
         V = abs(3 * VLN)
     else:
         raise ValueError("One or more voltages must be provided.")
     # Calculate TAP
-    TAP = abs(S) / (V*CTR)
-    return(TAP)
-
+    TAP = abs(S) / (V * CTR)
+    return TAP
 
 
 # Define Current Correction Calculator
-def correctedcurrents(Ipri,TAP,correction="Y",CTR=1):
+def correctedcurrents(Ipri, TAP, correction="Y", CTR=1):
     """
     Electrical Transformer Current Correction Function.
-    
+
     Function to evaluate the currents as corrected for microprocessor-
     based relay protection schemes.
-    
+
     Parameters
     ----------
     Ipri:       list of complex
                 Three-phase set (IA, IB, IC) of primary currents.
     TAP:        float
                 Relay's TAP setting.
     correction: string, optional
                 String defining correction factor, may be one of:
                 (Y, D+, D-, Z); Y denotes Y (Y0) connection, D+
                 denotes Dab (D1) connection, D- denotes Dac (D11)
                 connection, and Z (Z12) denotes zero-sequence
                 removal. default="Y"
     CTR:        float
                 Current Transformer Ratio, default=1
-    
+
     Returns
     -------
     Isec_corr:  list of complex
                 The corrected currents to perform operate/restraint
                 calculations with.
     """
     # Define Matrix Lookup
-    MAT = {   "Y"  : XFMY0,
-              "D+" : XFMD1,
-              "D-" : XFMD11,
-              "Z"  : XFM12}
+    MAT = {"Y": XFMY0,
+           "D+": XFMD1,
+           "D-": XFMD11,
+           "Z": XFM12}
     # Condition Inputs
     Ipri = _np.asarray(Ipri)
-    if isinstance(correction,list):
+    if isinstance(correction, list):
         mult = MAT[correction[0]]
         for i in correction[1:]:
             mult = mult.dot(MAT[i])
-    elif isinstance(correction,str):
+    elif isinstance(correction, str):
         mult = MAT[correction]
-    elif isinstance(correction,_np.ndarray):
+    elif isinstance(correction, _np.ndarray):
         mult = correction
     else:
         raise ValueError("Correction must be string or list of strings.")
     # Evaluate Corrected Current
-    Isec_corr = 1/TAP * mult.dot(Ipri/CTR)
-    return(Isec_corr)
-
+    Isec_corr = 1 / TAP * mult.dot(Ipri / CTR)
+    return Isec_corr
 
 
 # Define Iop/Irt Calculator
-def iopirt(IpriHV,IpriLV,TAPHV,TAPLV,corrHV="Y",corrLV="Y",CTRHV=1,CTRLV=1):
+def iopirt(IpriHV, IpriLV, TAPHV, TAPLV, corrHV="Y", corrLV="Y", CTRHV=1,
+           CTRLV=1):
     """
     Operate/Restraint Current Calculator.
-    
+
     Calculates the operating current (Iop) and the restraint
     current (Irt) as well as the slope.
-    
+
     Parameters
     ----------
     IpriHV:     list of complex
                 Three-phase set (IA, IB, IC) of primary currents
                 on the high-voltage side of power transformer.
     IpriLV      list of complex
                 Three-phase set (IA, IB, IC) of primary currents
@@ -1236,147 +1278,152 @@
                 removal. default="Y"
     CTRHV       float
                 Current Transformer Ratio for high-voltage side
                 of power transformer, default=1
     CTRLV       float
                 Current Transformer Ratio for low-voltage side
                 of power transformer, default=1
-    
+
     Returns
     -------
     Iop:        list of float
                 The operating currents for phases A, B, and C.
     Irt:        list of float
                 The restraint currents for phases A, B, and C.
     slope:      list of float
                 The calculated slopes for phases A, B, and C.
     """
     # Calculate Corrected Currents
-    IcorHV = correctedcurrents(IpriHV,TAPHV,corrHV,CTRHV)
-    IcorLV = correctedcurrents(IpriLV,TAPLV,corrLV,CTRLV)
+    IcorHV = correctedcurrents(IpriHV, TAPHV, corrHV, CTRHV)
+    IcorLV = correctedcurrents(IpriLV, TAPLV, corrLV, CTRLV)
     # Calculate Operate/Restraint Currents
-    Iop = _np.absolute( IcorHV + IcorLV )
+    Iop = _np.absolute(IcorHV + IcorLV)
     Irt = _np.absolute(IcorHV) + _np.absolute(IcorLV)
     # Calculate Slopes
-    slope = Iop/Irt
-    return(Iop,Irt,slope)
+    slope = Iop / Irt
+    return Iop, Irt, slope
+
 
 # Define Symmetrical/RMS Current Calculation
-def symrmsfaultcur(V,R,X,t=1/60,freq=60):
+def symrmsfaultcur(V, R, X, t=1 / 60, freq=60):
     """
     Symmetrical/RMS Current Calculator.
-    
+
     Function to evaluate the time-constant tau, the symmetrical fault current,
     and the RMS current for a faulted circuit.
-    
+
     Parameters
     ----------
     V:          float
                 Voltage magnitude at fault point,
                 not described as line-to-line or
                 line-to-neutral.
     R:          float
                 The fault resistance in ohms.
     X:          float
                 The fault impedance in ohms.
     t:          float, optional
                 The time in seconds.
     freq:       float, optional
                 The system frequency in Hz.
-    
+
     Returns
     -------
     tau:        float
                 The time-constant tau in seconds.
     Isym:       float
                 Symmetrical fault current in amps.
     Irms:       float
                 RMS fault current in amps.
     """
     # Calculate Z and tau
-    Z = _np.sqrt(R**2+X**2)
-    tau = X/(2*_np.pi*freq*R)
+    Z = _np.sqrt(R ** 2 + X ** 2)
+    tau = X / (2 * _np.pi * freq * R)
     # Calculate Symmetrical Fault Current
-    Isym = (V/_np.sqrt(3))/Z
+    Isym = (V / _np.sqrt(3)) / Z
     # Calculate RMS Fault Current
-    Irms = _np.sqrt(1+2*_np.exp(-2*t/tau))*Isym
-    return(tau,Isym,Irms)
+    Irms = _np.sqrt(1 + 2 * _np.exp(-2 * t / tau)) * Isym
+    return tau, Isym, Irms
+
 
 # Define Relay M Formula
-def faultratio(I,Ipickup,CTR=1):
+def faultratio(I, Ipickup, CTR=1):
     """
     Fault Multiple of Pickup (Ratio) Calculator.
-    
+
     Evaluates the CTR-scaled pickup measured to pickup current ratio.
-    
+
     M = meas / pickup
-    
+
     Parameters
     ----------
     I:          float
                 Measured Current in Amps
     Ipickup:    float
                 Fault Current Pickup Setting (in Amps)
     CTR:        float, optional
                 Current Transformer Ratio for relay,
                 default=1
-    
+
     Returns
     -------
     M:          float
                 The measured-to-pickup ratio
     """
-    M = I/(CTR * Ipickup)
-    return(M)
+    M = I / (CTR * Ipickup)
+    return M
+
 
 # Define Residual Compensation Factor Function
-def residcomp(z1,z0,linelength=1):
+def residcomp(z1, z0, linelength=1):
     """
     Residual Compensation Factor Function.
-    
+
     Evaluates the residual compensation factor based on the line's positive and
     zero sequence impedance characteristics.
-    
+
     Parameters
     ----------
     z1:         complex
                 The positive-sequence impedance
-                characteristic of the line, specified in 
+                characteristic of the line, specified in
                 ohms-per-unit where the total line length
                 (of same unit) is specified in
                 *linelength* argument.
     z0:         complex
                 The zero-sequence impedance characteristic
                 of the line, specified in ohms-per-unit
                 where the total line length (of same unit)
                 is specified in *linelength* argument.
     linelength: float, optional
                 The length (in same base unit as impedance
                 characteristics) of the line. default=1
-    
+
     Returns
     -------
     k0:         complex
                 The residual compensation factor.
     """
     # Evaluate Z1L and Z0L
-    Z1L = z1*linelength
-    Z0L = z0*linelength
+    Z1L = z1 * linelength
+    Z0L = z0 * linelength
     # Calculate Residual Compensation Factor (k0)
-    k0 = (Z0L - Z1L)/(3*Z1L)
-    return(k0)
+    k0 = (Z0L - Z1L) / (3 * Z1L)
+    return k0
+
 
 # Define Relay Measured Impedance Functon for Distance Elements
-def distmeasz(VLNmeas,If,Ip,Ipp,CTR=1,VTR=1,k0=None,z1=None,z0=None,linelength=1):
+def distmeasz(VLNmeas, If, Ip, Ipp, CTR=1, VTR=1, k0=None, z1=None, z0=None,
+              linelength=1):
     """
     Distance Element Measured Impedance Function.
-    
+
     Function to evaluate the Relay-Measured-Impedance as calculated from
     the measured voltage, current, and line parameters.
-    
+
     Parameters
     ----------
     VLNmeas:    complex
                 Measured Line-to-Neutral voltage for the
                 faulted phase in primary volts.
     If:         complex
                 Faulted phase current measured in primary
@@ -1391,135 +1438,138 @@
                 Current transformer ratio, default=1
     VTR:        float, optional
                 Voltage transformer ratio, default=1
     k0:         complex, optional
                 Residual Compensation Factor
     z1:         complex, optional
                 The positive-sequence impedance
-                characteristic of the line, specified in 
+                characteristic of the line, specified in
                 ohms-per-unit where the total line length
                 (of same unit) is specified in
                 *linelength* argument.
     z0:         complex, optional
                 The zero-sequence impedance characteristic
                 of the line, specified in ohms-per-unit
                 where the total line length (of same unit)
                 is specified in *linelength* argument.
     linelength: float, optional
                 The length (in same base unit as impedance
                 characteristics) of the line. default=1
-    
+
     Returns
     -------
     Zmeas:      complex
                 The "measured" impedance as calculated by the relay.
     """
     # Validate Residual Compensation Inputs
-    if k0 == z1 == z0 == None:
+    if k0 == z1 == z0 is None:
         raise ValueError("Residual compensation arguments must be set.")
-    if k0 == None and (z1==None or z0==None):
+    if k0 is None and (z1 is None or z0 is None):
         raise ValueError("Both *z1* and *z0* must be specified.")
     # Calculate Residual Compensation if Necessary
-    if k0 == None:
-        k0 = residcomp(z1,z0,linelength)
+    if k0 is None:
+        k0 = residcomp(z1, z0, linelength)
     # Convert Primary Units to Secondary
-    V = VLNmeas/VTR
-    Ir = (If + Ip + Ipp)/CTR
-    I = If/CTR
+    V = VLNmeas / VTR
+    Ir = (If + Ip + Ipp) / CTR
+    I = If / CTR
     # Calculate Measured Impedance
-    Zmeas = V / (I+k0*Ir)
-    return(Zmeas)
+    Zmeas = V / (I + k0 * Ir)
+    return Zmeas
+
 
 # Define Transformer Tap Mismatch Function
-def transmismatch(I1,I2,tap1,tap2):
+def transmismatch(I1, I2, tap1, tap2):
     """
     Electrical Transformer TAP Mismatch Function.
-    
+
     Function to evaluate the transformer ratio mismatch for protection.
-    
+
     Parameters
     ----------
     I1:         complex
                 Current (in amps) on transformer primary side.
     I2:         complex
                 Current (in amps) on transformer secondary.
     tap1:       float
                 Relay TAP setting on the primary side.
     tap2:       float
                 Relay TAP setting on the secondary side.
-    
+
     Returns
     -------
     mismatch:   float
                 Transformer CT mismatch value associated with
                 relay.
     """
     # Evaluate MR
-    MR = min( abs(I1/I2), abs(tap1/tap2) )
+    MR = min(abs(I1 / I2), abs(tap1 / tap2))
     # Calculate Mismatch
-    mismatch = (abs(I1/I2) - abs(tap1/tap2))*100/MR
-    return(mismatch)
+    mismatch = (abs(I1 / I2) - abs(tap1 / tap2)) * 100 / MR
+    return mismatch
+
 
 # Define High-Impedance Bus Protection Pickup Function
-def highzvpickup(I,RL,Rct,CTR=1,threephase=False,Ks=1.5,
-                 Vstd=400,Kd=0.5):
+def highzvpickup(I, RL, Rct, CTR=1, threephase=False, Ks=1.5,
+                 Vstd=400, Kd=0.5):
     """
     High Impedance Pickup Setting Function.
-    
+
     Evaluates the voltage pickup setting for a high
     impedance bus protection system.
-    
+
     Parameters
     ----------
     I:          float
                 Fault current on primary side (in amps)
     RL:         float
                 One-way line resistance in ohms
     Rct:        float
                 Current Transformer Resistance in ohms
     CTR:        float, optional
                 Current Transformer Ratio, default=1
     threephase: bool, optional
                 Control argument to set the function to
-                evaluate the result for a three-phase 
+                evaluate the result for a three-phase
                 fault or unbalanced fault. default=False
     Ks:         float, optional
                 Security Factor for secure voltage pickup
                 setting, default=1.5
     Vstd:       float, optional
                 C-Class Voltage rating (i.e. C-400),
                 default=400
     Kd:         float, optional
                 The dependability factor for dependable
                 voltage pickup setting, default=0.5
-    
+
     Returns
     -------
     Vsens:      float
                 The calculated sensetive voltage-pickup.
     Vdep:       float
                 The calculated dependable voltage-pickup.
     """
     # Condition Based on threephase Argument
     n = 2
     if threephase: n = 1
     # Evaluate Secure Voltage Pickup
-    Vsens = Ks*(n*RL+Rct)*I/CTR
+    Vsens = Ks * (n * RL + Rct) * I / CTR
     # Evaluate Dependible Voltage Pickup
-    Vdep = Kd*Vstd
-    return(Vsens,Vdep)
+    Vdep = Kd * Vstd
+    return Vsens, Vdep
+
 
 # Define Minimum Current Pickup for High-Impedance Bus Protection
-def highzmini(N,Ie,Irly=None,Vset=None,Rrly=2000,Imov=0,CTR=1):
+def highzmini(N, Ie, Irly=None, Vset=None, Rrly=2000, Imov=0, CTR=1):
     """
     Minimum Current for High Impedance Protection Calculator.
-    
+
     Evaluates the minimum pickup current required to cause
     high-impedance bus protection element pickup.
-    
+
     Parameters
     ----------
     N:          int
                 Number of Current Transformers included in scheme
     Ie:         float
                 The excitation current at the voltage setting
     Irly:       float, optional
@@ -1529,71 +1579,73 @@
     Rrly:       float, optional
                 The relay's internal resistance in ohms, default=2000
     Imov:       float, optional
                 The overvoltage protection current at the
                 voltage setting. default=0.0
     CTR:        float, optional
                 Current Transformer Ratio, default=1
-    
+
     Returns
     -------
     Imin:       float
                 Minimum current required to cause high-impedance
                 bus protection element pickup.
     """
     # Validate Inputs
-    if Irly == Vset == None:
+    if Irly == Vset is None:
         raise ValueError("Relay Current Required.")
     # Condition Inputs
     Ie = abs(Ie)
     Imov = abs(Imov)
-    if Irly == None:
+    if Irly is None:
         Vset = abs(Vset)
         Irly = Vset / Rrly
     else:
         Irly = abs(Irly)
     # Evaluate Minimum Current Pickup
-    Imin = (N*Ie+Irly+Imov)*CTR
-    return(Imin)
+    Imin = (N * Ie + Irly + Imov) * CTR
+    return (Imin)
+
 
 # Define Instantaneous Overcurrent Pickup Formula
-def instoc(Imin,CTR=1,Ki=0.5):
+def instoc(Imin, CTR=1, Ki=0.5):
     """
     Instantaneous OverCurrent Pickup Calculator.
-    
+
     Using a sensetivity factor and the CTR, evaluates the secondary-level pickup
     setting for an instantaneous overcurrent element.
-    
+
     Parameters
     ----------
     Imin:       float
                 The minimum fault current in primary amps.
     CTR:        float, optional
                 Current Transformer Ratio, default=1
     Ki:         Sensetivity factor, default=0.5
-    
+
     Returns
     -------
     Ipu:        float
                 The pickup setting for the instantaneous
                 overcurrent element as referred to the
                 secondary side.
     """
     # Evaluate Overcurrent Pickup Setting
-    Ipu = Ki * abs(Imin)/CTR
-    return(Ipu)
+    Ipu = Ki * abs(Imin) / CTR
+    return Ipu
+
 
 # Define Generator Loss of Field Element Function
-def genlossfield(Xd,Xpd,Zbase=1,CTR=1,VTR=1):
+def genlossfield(Xd, Xpd, Zbase=1, CTR=1, VTR=1):
     """
     Electric Generator Loss of Field Function.
-    
+
     Generates the Loss-of-Field Element settings for a generator using the Xd
     value and per-unit base information.
-    
+
     Parameters
     ----------
     Xd:         float
                 The Transient Reactance (Xd) term. May be
                 specified in ohms or Per-Unit ohms if
                 *Zbase* is set.
     Xpd:        float
@@ -1603,89 +1655,90 @@
     Zbase:      float, optional
                 Base impedance, used to convert per-unit
                 Xd and Xpd to secondary values. default=1
     CTR:        float, optional
                 Current Transformer Ratio, default=1
     VTR:        float, optional
                 Voltage Transformer Ratio, default=1
-    
+
     Returns
     -------
     ZoneOff:    float
                 Zone Offset in ohms.
     Z1dia:      float
                 Zone 1 diameter in ohms.
     Z2dia:      float
                 Zone 2 diameter in ohms.
     """
     # Condition Inputs
     Xd = abs(Xd)
     Xpd = abs(Xpd)
     Zbase = abs(Zbase)
     # Evaluate Xd_sec and Xpd_sec
-    Xd_sec = Xd*Zbase*(CTR/VTR)
-    Xpd_sec = Xd*Zbase*(CTR/VTR)
+    Xd_sec = Xd * Zbase * (CTR / VTR)
+    Xpd_sec = Xd * Zbase * (CTR / VTR)
     # Determine Zone Offset
-    ZoneOff = Xpd_sec/2
+    ZoneOff = Xpd_sec / 2
     # Evaluate Z1 Diameter and Z2 Diameter
-    Z1dia = Zbase*CTR/VTR
+    Z1dia = Zbase * CTR / VTR
     Z2dia = Xd_sec
     # Return
-    return(ZoneOff,Z1dia,Z2dia)
+    return ZoneOff, Z1dia, Z2dia
+
 
 # Define Thermal Time Limit Calculator
-def thermaltime(In,Ibase,tbase):
+def thermaltime(In, Ibase, tbase):
     r"""
     Thermal Time Limit Calculator.
-    
+
     Computes the maximum allowable time for a specified current `In` given
     parameters for a maximum current and time at some other level, (`Ibase`,
     `tbase`).
-    
+
     Uses the following formula:
-    
+
     .. math:: t_n=\frac{I_{base}^2*t_{base}}{I_n^2}
-    
+
     Parameters
     ----------
     In:         float
                 Current at which to calculate max time.
     Ibase:      float
                 Base current, at which maximum time
                 `tbase` is allowable.
     tbase:      float
                 Base time for which a maximum allowable
                 current `Ibase` is specified. Unitless.
-    
+
     Returns
     -------
     tn:         float
                 Time allowable for specified current,
                 `In`.
     """
     # Perform Calculation
-    tn = (Ibase**2*tbase)/(In**2)
-    return(tn)
-    
+    tn = (Ibase ** 2 * tbase) / (In ** 2)
+    return tn
+
 
 # Define Synch. Machine Fault Current Calculator
-def synmach_Isym(t,Eq,Xd,Xdp,Xdpp,Tdp,Tdpp):
+def synmach_Isym(t, Eq, Xd, Xdp, Xdpp, Tdp, Tdpp):
     r"""
     Synch. Machine Symmetrical Fault Current Calc.
-    
+
     Determines the Symmetrical Fault Current of a synchronous
     machine given the machine parameters, the internal voltage,
     and the time for which to calculate.
-    
+
     .. math:: I_a(t)=\sqrt{2}\left|E_q\right|\left[
        \frac{1}{X_d}+\left(\frac{1}{X'_d}-\frac{1}{X_d}
        \right)\cdot e^{\frac{-t}{T'_d}}+\left(\frac{1}
        {X"_d}-\frac{1}{X'_d}\right)\cdot e^{\frac{-t}{T"_d}}
        \right]
-    
+
     Parameters
     ----------
     t:          float
                 Time at which to calculate the fault current
     Eq:         float
                 The internal machine voltage in per-unit-volts
     Xd:         float
@@ -1698,74 +1751,80 @@
                 per-unit-ohms
     Tdp:        float
                 The T'd (d-axis transient) time constant of the
                 machine in seconds
     Tdpp:       float
                 The T"d (d-axis subtransient) time constant of
                 the machine in seconds
-    
+
     Returns
     -------
     Ia:         float
                 Peak symmetrical fault current in per-unit-amps
     """
     # Calculate Time-Constant Term
-    t_c = 1/Xd+(1/Xdp-1/Xd)*_np.exp(-t/Tdp)+(1/Xdpp-1/Xdp)*_np.exp(-t/Tdpp)
+    t_c = (
+        1 / Xd + 
+        (1 / Xdp - 1 / Xd) * _np.exp(-t / Tdp) + 
+        (1 / Xdpp - 1 / Xdp) * _np.exp(-t / Tdpp)
+    )
     # Calculate Fault Current
-    Ia = _np.sqrt(2)*abs(Eq)*t_c
-    return(Ia)
+    Ia = _np.sqrt(2) * abs(Eq) * t_c
+    return Ia
+
 
 # Define Synch. Machine Asymmetrical Current Calculator
-def synmach_Iasym(t,Eq,Xdpp,Xqpp,Ta):
+def synmach_Iasym(t, Eq, Xdpp, Xqpp, Ta):
     r"""
     Synch. Machine Asymmetrical Fault Current Calc.
-    
+
     Determines the asymmetrical fault current of a synchronous
     machine given the machine parameters, the internal voltage,
     and the time for which to calculate.
-    
+
     .. math:: I_{asym}=\sqrt{2}\left|E_q\right|\frac{1}{2}
        \left(\frac{1}{X"_d}+\frac{1}{X"_q}\right)e^{\frac{-t}
        {T_a}}
-    
+
     Parameters
     ----------
     t:          float
                 Time at which to calculate the fault current
     Eq:         float
                 The internal machine voltage in per-unit-volts
     Xdpp:       float
                 The X"d (d-axis subtransient) reactance in
                 per-unit-ohms
     Xqpp:       float
                 The X"q (q-axis subtransient) reactance in
                 per-unit-ohms
     Ta:         float
                 Armature short-circuit (DC) time constant in seconds
-    
+
     Returns
     -------
     Iasym:      float
                 Peak asymmetrical fault current in per-unit-amps
     """
     # Calculate Time Constant Term
-    t_c = 1/Xdpp + 1/Xqpp
+    t_c = 1 / Xdpp + 1 / Xqpp
     # Calculate Asymmetrical Current
-    Iasym = _np.sqrt(2)*abs(Eq)*1/2*t_c*_np.exp(-t/Ta)
-    return(Iasym)
+    Iasym = _np.sqrt(2) * abs(Eq) * 1 / 2 * t_c * _np.exp(-t / Ta)
+    return Iasym
+
 
 # Define Induction Machine Eigenvalue Calculator
-def indmacheigenvalues(Lr,Ls,Lm,Rr,Rs,wrf=0,freq=60):
+def indmacheigenvalues(Lr, Ls, Lm, Rr, Rs, wrf=0, freq=60):
     """
     Induction Machine Eigenvalue Calculator.
-    
+
     Calculates the pertinent eigenvalues for an unloaded
     induction machine given a specific set of machine
     parameters.
-    
+
     Parameters
     ----------
     Lr:         float
                 Inductance of the Rotor (in Henrys).
     Ls:         float
                 Inductance of the Stator (in Henrys).
     Lm:         float
@@ -1777,50 +1836,53 @@
                 Resistance of the Stator (in Ohms).
     wrf:        float, optional
                 Frequency (in radians/sec) of the rotor slip.
                 default=0
     freq:       float, optional
                 Base frequency of the system (in Hertz).
                 default=60
-    
+
     Returns
     -------
     lam1:       complex
                 The First Eigenvalue
     lam2:       complex
                 The Second Eigenvalue
     """
     # Calculate Required Values
-    omega_e_base = 2*_np.pi*freq
+    omega_e_base = 2 * _np.pi * freq
     omega_rf = wrf
-    torque_s = Ls/(omega_e_base*Rs)
-    torque_r = Lr/(omega_e_base*Rr)
+    torque_s = Ls / (omega_e_base * Rs)
+    torque_r = Lr / (omega_e_base * Rr)
     alpha = torque_r / torque_s
-    phi = 1 - Lm**2/(Ls*Lr)
+    phi = 1 - Lm ** 2 / (Ls * Lr)
     omega_r = omega_e_base
     # Calculate k1
-    k1 = -1/(2*phi*torque_r)*(1+alpha)
-    k1 += 1j*(omega_r/2-omega_rf)
+    k1 = -1 / (2 * phi * torque_r) * (1 + alpha)
+    k1 += 1j * (omega_r / 2 - omega_rf)
     # Calculate k2
-    k2 = 1/(2*phi*torque_r)
-    k2 *= _np.sqrt((1+alpha)**2-4*phi*alpha-(omega_r*phi*torque_r)**2
-                 +2j*(alpha-1)*omega_r*phi*torque_r)
+    k2 = 1 / (2 * phi * torque_r)
+    k2 *= _np.sqrt(
+        (1 + alpha) ** 2 - 4 * phi * alpha - (omega_r * phi * torque_r) ** 2 +
+        2j * (alpha - 1) * omega_r * phi * torque_r
+    )
     # Evaluate Eigenvalues and Return
-    lam1 = k1+k2
-    lam2 = k1-k2
-    return(lam1,lam2)
+    lam1 = k1 + k2
+    lam2 = k1 - k2
+    return lam1, lam2
+
 
 # Define IM 3-Phase SC Current Calculator
-def indmachphs3sc(t,Is0,Lr,Ls,Lm,Rr,Rs,wrf=0,freq=60,real=True):
+def indmachphs3sc(t, Is0, Lr, Ls, Lm, Rr, Rs, wrf=0, freq=60, real=True):
     """
     Induction Machine 3-Phase SC Calculator.
-    
+
     Determines the short-circuit current at a specified time for a three-phase
     fault on an unloaded induction machine.
-    
+
     Parameters
     ----------
     t:          array_like
                 The time at which to find the
                 current, may be int, float, or
                 numpy array.
     Is0:        complex
@@ -1842,45 +1904,46 @@
                 default=0
     freq:       float, optional
                 Base frequency of the system (in Hertz).
                 default=60
     real:       bool, optional
                 Control argument to force returned value
                 to be real part only. default=True
-    
+
     Returns
     -------
     ias:        array_like
                 Fault Current
     """
     # Calculate Required Values
-    omega_r = 2*_np.pi*freq
-    torque_s = Ls/(omega_r*Rs)
-    phi = 1 - Lm**2/(Ls*Lr)
+    omega_r = 2 * _np.pi * freq
+    torque_s = Ls / (omega_r * Rs)
+    phi = 1 - Lm ** 2 / (Ls * Lr)
     # Calculate Eigenvalues
-    lam1, lam2 = indmacheigenvalues(Lr,Ls,Lm,Rr,Rs,wrf,freq)
+    lam1, lam2 = indmacheigenvalues(Lr, Ls, Lm, Rr, Rs, wrf, freq)
     # Calculate pIs0
-    pIs0 = -(1/(phi*torque_s)+1j*(1-phi)/phi*omega_r)*Is0
+    pIs0 = -(1 / (phi * torque_s) + 1j * (1 - phi) / phi * omega_r) * Is0
     # Calculate Constants
-    C1 = (lam2*Is0-pIs0)/(lam2-lam1)
-    C2 = (pIs0-lam1*Is0)/(lam2-lam1)
+    C1 = (lam2 * Is0 - pIs0) / (lam2 - lam1)
+    C2 = (pIs0 - lam1 * Is0) / (lam2 - lam1)
     # Calculate ias and Return
-    ias = C1*_np.exp(lam1*t)+C2*_np.exp(lam2*t)
+    ias = C1 * _np.exp(lam1 * t) + C2 * _np.exp(lam2 * t)
     if real:
         ias = _np.real(ias)
-    return(ias)
+    return ias
+
 
 # Define IM Torque Calculation
-def indmachphs3torq(t,Is0,Lr,Ls,Lm,Rr,Rs,wrf=0,freq=60):
+def indmachphs3torq(t, Is0, Lr, Ls, Lm, Rr, Rs, wrf=0, freq=60):
     """
     Induction Machine 3-Phase Torque Calculator.
-    
+
     Determines the torque exerted during a three-phase fault on an induction
     machine.
-    
+
     Parameters
     ----------
     t:          array_like
                 The time at which to find the
                 current, may be int, float, or
                 numpy array.
     Is0:        complex
@@ -1901,110 +1964,111 @@
                 Number of electrical poles.
     wrf:        float, optional
                 Frequency (in radians/sec) of the rotor slip.
                 default=0
     freq:       float, optional
                 Base frequency of the system (in Hertz).
                 default=60
-    
+
     Returns
     -------
     Tem:        array_like
                 Induction machine torque in N*m
     """
     # Calculate Required Values
-    omega_r = 2*_np.pi*freq
-    torque_s = Ls/(omega_r*Rs)
-    phi = 1 - Lm**2/(Ls*Lr)
+    omega_r = 2 * _np.pi * freq
+    torque_s = Ls / (omega_r * Rs)
+    phi = 1 - Lm ** 2 / (Ls * Lr)
     # Calculate Eigenvalues
-    lam1, lam2 = indmacheigenvalues(Lr,Ls,Lm,Rr,Rs,wrf,freq)
+    lam1, lam2 = indmacheigenvalues(Lr, Ls, Lm, Rr, Rs, wrf, freq)
     # Calculate pIs0
-    pIs0 = -(1/(phi*torque_s)+1j*(1-phi)/phi*omega_r)*Is0
+    pIs0 = -(1 / (phi * torque_s) + 1j * (1 - phi) / phi * omega_r) * Is0
     # Calculate Constants
-    C1 = (lam2*Is0-pIs0)/(lam2-lam1)
-    C2 = (pIs0-lam1*Is0)/(lam2-lam1)
+    C1 = (lam2 * Is0 - pIs0) / (lam2 - lam1)
+    C2 = (pIs0 - lam1 * Is0) / (lam2 - lam1)
     # Calculate ias and Return
-    idqs = C1*_np.exp(lam1*t)+C2*_np.exp(lam2*t)
-    idqr = C2*_np.exp(lam1*t)+C1*_np.exp(lam2*t)
+    idqs = C1 * _np.exp(lam1 * t) + C2 * _np.exp(lam2 * t)
+    idqr = C2 * _np.exp(lam1 * t) + C1 * _np.exp(lam2 * t)
     # Calculate Lambda
-    lamdqr = Lm*idqs+Lr*idqr
+    lamdqr = Lm * idqs + Lr * idqr
     # Calculate Torque
-    Tem = Lm/Lr * (lamdqr.real*idqs.imag - lamdqr.imag*idqs.real)
-    return(Tem)
+    Tem = Lm / Lr * (lamdqr.real * idqs.imag - lamdqr.imag * idqs.real)
+    return Tem
+
 
 # Define Complete Sync. Mach. Fault Current Function
-def synmach_ifault(t,Ea,alpha,Xd,Xdp,Xdpp,Xqpp,Tdp,Tdpp,Ta,freq=60):
+def synmach_ifault(t, Ea, alpha, Xd, Xdp, Xdpp, Xqpp, Tdp, Tdpp, Ta, freq=60):
     # noqa: D401   "Synchronous" is intentional descriptor
     """
     Synchronous Machine Fault Current Calculator.
-    
+
     Given machine parameters, fault inception angle, and time at
     which to calculate fault current, this function will identify
     the complete (symmetrical, asymmetrical, and double frequency)
     fault current.
-    
+
     .. image:: /static/synmach_ifault_formula.png
-    
+
     Parameters
     ----------
     t:          float
                 Time at which to calculate the fault current
     Eq:         float
                 The internal machine voltage in per-unit-volts
     alpha:      float
                 Fault inception angle (in degrees)
     Xd:         float
                 The Xd (d-axis) reactance in per-unit-ohms
     Xdp:        float
                 The X"d (d-axis transient) reactance in
                 per-unit-ohms
     Xdpp:       float
-                The X"d (d-axis subtransient) reactance in
+                The X"d (d-axis sub-transient) reactance in
                 per-unit-ohms
     Xqpp:       float
-                The X"q (q-axis subtransient) reactance in
+                The X"q (q-axis sub-transient) reactance in
                 per-unit-ohms
     Tdp:        float
                 The T'd (d-axis transient) time constant of the
                 machine in seconds
     Tdpp:       float
-                The T"d (d-axis subtransient) time constant of
+                The T"d (d-axis sub-transient) time constant of
                 the machine in seconds
     Ta:         float
                 Armature short-circuit (DC) time constant in seconds
     freq:       float, optional
                 System (electrical) frequency (in degrees),
                 default=60
-    
+
     Returns
     -------
     ias:        float
                 Synchronous machine fault current (symmetrical,
                 asymmetrical, and double frequency component) in
                 amps
     """
     # Calculate we Component
-    we = 2*_np.pi*freq
+    we = 2 * _np.pi * freq
     # Condition Inputs
     Ea = abs(Ea)
     alpha = _np.radians(alpha)
     # Define Constant Term
-    const = _np.sqrt(2)*Ea
+    const = _np.sqrt(2) * Ea
     if Xqpp != 0:
-        val = 1/Xqpp
+        val = 1 / Xqpp
     else:
         val = 0
-    asym = 1/2*(1/Xdpp+val)*_np.exp(t/Ta)
+    asym = 1 / 2 * (1 / Xdpp + val) * _np.exp(t / Ta)
     # Define Symmetrical Portion
-    isym = const*(1/Xd+(1/Xdp-1/Xd)*_np.exp(-t/Tdp)
-               +(1/Xdpp-1/Xdp)*_np.exp(-t/Tdpp))*_np.sin(we*t+alpha)
+    isym = (
+        const * (1 / Xd + (1 / Xdp - 1 / Xd) * _np.exp(-t / Tdp) +
+        (1 / Xdpp - 1 / Xdp) * _np.exp(-t / Tdpp)) * _np.sin(we * t + alpha)
+    )
     # Define Asymmetrical Portion
-    iasym = const*asym*_np.sin(alpha)
+    iasym = const * asym * _np.sin(alpha)
     # Define Double Frequency Term
-    idbl = const*1/2*asym*_np.sin(2*we*t+alpha)
-    # Compose Complet Current Value
+    idbl = const * 1 / 2 * asym * _np.sin(2 * we * t + alpha)
+    # Compose Complete Current Value
     ias = isym - iasym - idbl
-    return(ias)
-    
-    
+    return ias
 
-# END OF FILE
+# END
```

### Comparing `electricpy-0.2.2/electricpy/geometry/__init__.py` & `electricpy-0.3.0/electricpy/geometry/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,28 +1,28 @@
 ################################################################################
 """
 `electricpy.geometry`  Geometry Sub Module.
 
 >>> import electricpy.geometry as geometry
 
-This Package help to handle coordinate geometry calculatios which are required 
-for plotting various graphs in electrical engineering. 
+This Package help to handle coordinate geometry calculations which are required
+for plotting various graphs in electrical engineering.
 
 Built to support operations similar to Numpy and Scipy, this package is designed
 to aid in scientific calculations.
 """
 ################################################################################
 import cmath
 from typing import Tuple, Union
 from typing import Tuple
 
 
 class Point:
     """A point in 2D space.
-    
+
     Parameters
     ----------
     x : float
         The x coordinate of the point
     y : float
         The y coordinate of the point
     """
@@ -61,15 +61,15 @@
         return f"({self.x}, {self.y})"
 
 
 class Line:
     """A line in 2D space in the form .
 
     math:: ax + by + c = 0
-    
+
     Parameters
     ----------
     a : float
         The a coefficient of the line
     b : float
         The b coefficient of the line
     c : float
@@ -185,14 +185,24 @@
         """Return the image of a point with respect to line."""
         return point_image(p, self)
 
     def intersection(self, l1: object) -> Union[Point, None]:
         """Return the intersection of two lines."""
         return line_intersection(self, l1)
 
+def angle_btw_lines(l1: Line, l2: Line) -> float:
+    """Return angle (in radians) between two lines l1 and l2."""
+    a1, b1 = l1.a, l1.b
+    a2, b2 = l2.a, l2.b
+
+    if a1*a2 + b1*b2 == 0:
+        return cmath.pi/2
+
+    ans = abs((b1*a2 - a1*b2)/(a1*a2 + b1*b2))
+    return cmath.atan(ans)
 
 def line_intersection(l1: Line, l2: Line) -> Point:
     """Calculate the intersection point of two lines."""
     a1, b1, c1 = l1.a, l1.b, -l1.c
     a2, b2, c2 = l2.a, l2.b, -l2.c
 
     try:
```

### Comparing `electricpy-0.2.2/electricpy/geometry/circle.py` & `electricpy-0.3.0/electricpy/geometry/circle.py`

 * *Files identical despite different names*

### Comparing `electricpy-0.2.2/electricpy/geometry/triangle.py` & `electricpy-0.3.0/electricpy/geometry/triangle.py`

 * *Files identical despite different names*

### Comparing `electricpy-0.2.2/electricpy/latex.py` & `electricpy-0.3.0/electricpy/latex.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,26 +1,25 @@
 ################################################################################
 """
-`electricpy` Package - `latex` Module.
+LaTeX Support Module to help Generate LaTeX formatted Math Symbols and Formulas.
 
 >>> from electricpy import latex
 
 This module is specifically designed to help create strings that represent LaTeX
 formatted formulas, functions, and more for easy printing in tools such as
 Jupyter Notebooks.
 
 Built to support operations similar to Numpy and Scipy, this package is designed
 to aid in scientific calculations.
 """
 ################################################################################
 
-# Import Required Packages
-import numpy as _np
 import cmath as _c
 
+import numpy as _np
 
 
 # Define Complex LaTeX Generator
 def clatex(val, round=3, polar=True, predollar=True, postdollar=True,
            double=False):
     """
     Complex Value Latex Generator.
@@ -60,34 +59,34 @@
     # Define Interpretation Functions
     def polarstring(val, round):
         mag, ang_r = _c.polar(val)  # Convert to polar form
         ang = _np.degrees(ang_r)  # Convert to degrees
         mag = _np.around(mag, round)  # Round
         ang = _np.around(ang, round)  # Round
         latex = str(mag) + '∠' + str(ang) + '°'
-        return (latex)
+        return latex
 
     def rectstring(val, round):
         real = _np.around(val.real, round)  # Round
         imag = _np.around(val.imag, round)  # Round
         if imag > 0:
             latex = str(real) + "+j" + str(imag)
         else:
             latex = str(real) + "-j" + str(abs(imag))
-        return (latex)
+        return latex
 
     # Interpret as numpy array if simple list
     if isinstance(val, list):
         val = _np.asarray(val)  # Ensure that input is array
     # Find length of the input array
     if isinstance(val, _np.ndarray):
         shp = val.shape
         try:
             row, col = shp  # Interpret Shape of Object
-        except:
+        except ValueError:
             row = shp[0]
             col = 1
         _ = val.size
         # Open Matrix
         latex = r'\begin{bmatrix}'
         # Iteratively Process Each Item in Array
         for ri in range(row):
@@ -199,22 +198,22 @@
                 xpnt = length - i - 1
                 if xpnt == 1:
                     strg += var
                 elif xpnt == 0:
                     pass  # Don't Do Anything
                 else:
                     strg += var + r'^{' + str(xpnt) + r'}'
-        return (strg)
+        return strg
 
     # Generate Total TF String
     latex = r'\frac{' + genstring(num) + r'}{'
     latex += genstring(den) + r'}'
     # Add Dollar Sign pre-post
     if double:
         dollar = r'$$'
     else:
         dollar = r'$'
     if predollar:
         latex = dollar + latex
     if postdollar:
         latex = latex + dollar
-    return (latex)
+    return latex
```

### Comparing `electricpy-0.2.2/electricpy/math.py` & `electricpy-0.3.0/electricpy/math.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 ################################################################################
 """
-`electricpy` Package - `math` Module.
+Common Mathematic Functions for Electrical Engineering.
 
 >>> from electricpy import math as epmath
 
 Focussed on simplifying common mathematic formulas for electrical engineering,
 this module exposes a few common functions like convolution, step-functions,
 etc.
 
 Built to support operations similar to Numpy and Scipy, this package is designed
 to aid in scientific calculations.
 """
 ################################################################################
 
-# Import Required Packages
 import numpy as _np
 import scipy.signal as _sig
 from scipy.integrate import quad as integrate
 
+
 # Define convolution function
 def convolve(tuple):
     """
     Filter Convolution Function.
 
     Given a tuple of terms, convolves all terms in tuple to
     return one tuple as a numpy array.
@@ -54,23 +54,24 @@
     :math:`x \geq 0`.
 
     Examples
     --------
     >>> import numpy as np
     >>> from electricpy.math import step
     >>> t = np.array([-10, -8, -5, -3, 0, 1, 2, 5, 7, 15])
-    >>> x = step(t)
-    array([0, 0, 0, 0, 1, 1, 1, 1, 1, 1])
+    >>> step(t)
+    array([0., 0., 0., 0., 1., 1., 1., 1., 1., 1.])
 
     Parameters
     ----------
     t:  arraylike
         Time samples for which the step response should be generated.
     """
-    return (_np.heaviside(t, 1))
+    return _np.heaviside(t, 1)
+
 
 # Arbitrary Waveform RMS Calculating Function
 def funcrms(func, T):
     """
     Root-Mean-Square (RMS) Evaluator for Callable Functions.
 
     Integral-based RMS calculator, evaluates the RMS value
@@ -88,14 +89,15 @@
     -------
     RMS:    The RMS value of the function (f) over the interval ( 0, T )
     """
     fn = lambda x: func(x) ** 2
     integral, _ = integrate(fn, 0, T)
     return _np.sqrt(1 / T * integral)
 
+
 # Define Gaussian Function
 def gaussian(x, mu=0, sigma=1):
     """
     Gaussian Function.
 
     This function is designed to generate the gaussian
     distribution curve with configuration mu and sigma.
@@ -112,14 +114,15 @@
     Returns
     -------
     Computed gaussian (numpy.ndarray) of the input x
     """
     return (1 / (sigma * _np.sqrt(2 * _np.pi)) *
             _np.exp(-(x - mu) ** 2 / (2 * sigma ** 2)))
 
+
 # Define Gaussian Distribution Function
 def gausdist(x, mu=0, sigma=1):
     """
     Gaussian Distribution Function.
 
     This function is designed to calculate the generic
     distribution of a gaussian function with controls
@@ -138,32 +141,34 @@
     -------
     F:      numpy.ndarray
             Computed distribution of the gausian function at the
             points specified by (array) x
     """
     # Define Integrand
     def integrand(sq):
-        return (_np.exp(-sq ** 2 / 2))
+        return _np.exp(-sq ** 2 / 2)
+
     try:
         lx = len(x)  # Find length of Input
     except:
         lx = 1  # Length 1
         x = [x]  # Pack into list
     F = _np.zeros(lx, dtype=_np.float64)
     for i in range(lx):
         x_tmp = x[i]
         # Evaluate X (altered by mu and sigma)
         X = (x_tmp - mu) / sigma
         integral = integrate(integrand, _np.NINF, X)  # Integrate
         result = 1 / _np.sqrt(2 * _np.pi) * integral[0]  # Evaluate Result
         F[i] = result
     # Return only the 0-th value if there's only 1 value available
-    if (len(F) == 1):
+    if len(F) == 1:
         F = F[0]
-    return (F)
+    return F
+
 
 # Define Probability Density Function
 def probdensity(func, x, x0=0, scale=True):
     """
     Probability Density Function.
 
     This function uses an integral to compute the probability
@@ -195,23 +200,24 @@
     except:
         lx = 1  # Length 1
         x = [x]  # Pack into list
     # Recursively Find Probability Density
     for i in range(lx):
         sumx = _np.append(sumx, integrate(func, x0, x[i])[0])
     # Return only the 0-th value if there's only 1 value available
-    if (len(sumx) == 1):
+    if len(sumx) == 1:
         sumx = sumx[0]
     else:
-        if (scale == True):
+        if scale:
             mx = sumx.max()
             sumx /= mx
-        elif (scale != False):
+        elif scale != False:
             sumx /= scale
-    return (sumx)
+    return sumx
+
 
 # Define Real FFT Evaluation Function
 def rfft(arr, dt=0.01, absolute=True, resample=True):
     """
     RFFT Function.
 
     This function is designed to evaluat the real FFT
@@ -238,21 +244,21 @@
     FFT Array
     """
     # Calculate with Absolute Values
     if absolute:
         fourier = abs(_np.fft.rfft(arr))
     else:
         fourier = _np.fft.rfft(arr)
-    if resample == True:
+    if resample:
         # Evaluate the Downsampling Ratio
         dn = int(dt * len(arr))
         # Downsample to remove unnecessary points
         fixedfft = filter.dnsample(fourier, dn)
         return (fixedfft)
-    elif resample == False:
+    elif not resample:
         return (fourier)
     else:
         # Condition Resample Value
         resample = int(resample)
         # Downsample to remove unnecessary points
         fixedfft = filter.dnsample(fourier, resample)
-        return (fixedfft)
+        return fixedfft
```

### Comparing `electricpy-0.2.2/electricpy/passive.py` & `electricpy-0.3.0/electricpy/passive.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,15 +1,18 @@
 ################################################################################
 """
-`electricpy.capacitor` Package - Capacitor Specific Methods.
+Functions and Formulas Related to Passive Electrical Components (R/L/C).
 
 Filled with methods related capacitors.
 """
 ################################################################################
+
 import numpy as _np
+
+
 def vcapdischarge(t, Vs, R, C):
     r"""
     Discharging Capacitor Function.
 
     Function to calculate the voltage of a
     capacitor that is discharging given the time.
 
@@ -28,20 +31,21 @@
                 Capacitive value (in Farads).
 
     Returns
     -------
     Vc:         float
                 The calculated voltage of the capacitor.
     """
-    if t<0:
+    if t < 0:
         raise ValueError("Time must be greater than or equal to zero.")
-    if R*C == 0:
+    if R * C == 0:
         raise ValueError("Resistance and Capacitance must be non-zero.")
     Vc = Vs * (_np.exp(-t / (R * C)))
-    return (Vc)
+    return Vc
+
 
 def vcapcharge(t, Vs, R, C):
     r"""
     Charging Capacitor Voltage.
 
     Function to calculate the voltage of a
     capacitor that is charging given the time.
@@ -61,20 +65,21 @@
                 Capacitive value (in Farads).
 
     Returns
     -------
     Vc:         float
                 The calculated voltage of the capacitor.
     """
-    if t<0:
+    if t < 0:
         raise ValueError("Time must be greater than or equal to zero.")
-    if R*C == 0:
+    if R * C == 0:
         raise ValueError("Resistance and Capacitance must be non-zero.")
     Vc = Vs * (1 - _np.exp(-t / (R * C)))
-    return (Vc)
+    return Vc
+
 
 def captransfer(t, Vs, R, Cs, Cd):
     """
     Capacitor Energy Transfer Function.
 
     Calculate the voltage across a joining
     resistor (R) that connects Cs and Cd, the
@@ -98,23 +103,24 @@
     Returns
     -------
     rvolt:      float
                 Voltage across the resistor at time t.
     vfinal:     float
                 Final voltage that both capacitors settle to.
     """
-    if t<0:
+    if t < 0:
         raise ValueError("Time must be greater than zero.")
     try:
         tau = (R * Cs * Cd) / (Cs + Cd)
         rvolt = Vs * _np.exp(-t / tau)
     except ZeroDivisionError:
         raise ZeroDivisionError("Sum of Source and Destination Capacitance must be non-zero.")
     vfinal = Vs * Cs / (Cs + Cd)
-    return (rvolt, vfinal)
+    return rvolt, vfinal
+
 
 # Define Capacitive Back-to-Back Switching Formula
 def capbacktoback(C1, C2, Lm, VLN=None, VLL=None):
     """
     Back to Back Capacitor Transient Current Calculator.
 
     Function to calculate the maximum current and the
@@ -143,15 +149,16 @@
     ifreq:      float
                 Transient current frequency
     """
     # Evaluate Max Current
     imax = _np.sqrt(2 / 3) * VLL * _np.sqrt((C1 * C2) / ((C1 + C2) * Lm))
     # Evaluate Inrush Current Frequency
     ifreq = 1 / (2 * _np.pi * _np.sqrt(Lm * (C1 * C2) / (C1 + C2)))
-    return (imax, ifreq)
+    return imax, ifreq
+
 
 # Define Apparent Power to Farad Conversion
 def farads(VAR, V, freq=60):
     r"""
     Capacitance from Apparent Power Formula.
 
     Function to calculate the required capacitance
@@ -172,15 +179,15 @@
                 The System frequency
 
     Returns
     -------
     C:          float
                 The evaluated capacitance (in Farads).
     """
-    return (VAR / (2 * _np.pi * freq * V ** 2))
+    return VAR / (2 * _np.pi * freq * V ** 2)
 
 
 # Define Capacitor Energy Calculation
 def capenergy(C, V):
     r"""
     Capacitor Energy Formula.
 
@@ -198,15 +205,15 @@
 
     Returns
     -------
     energy:     float
                 Energy stored in capacitor (Joules).
     """
     energy = 1 / 2 * C * V ** 2
-    return (energy)
+    return energy
 
 
 # Define Capacitor Voltage Discharge Function
 def loadedvcapdischarge(t, vo, C, P):
     # noqa: D401    "Loaded" is a valid word for this docstring
     r"""
     Loaded Capacitor Discharge Formula.
@@ -230,15 +237,15 @@
 
     Returns
     -------
     Vt:         float
                 Voltage of capacitor at time t.
     """
     Vt = _np.sqrt(vo ** 2 - 2 * P * t / C)
-    return (Vt)
+    return Vt
 
 
 # Define Capacitor Discharge Function
 def timedischarge(Vinit, Vmin, C, P, dt=1e-3, RMS=True, Eremain=False):
     r"""
     Capacitor Discharge Time Formula.
 
@@ -269,23 +276,23 @@
     """
     t = 0  # start at time t=0
     if RMS:
         vo = Vinit * _np.sqrt(2)  # convert RMS to peak
     else:
         vo = Vinit
     vc = loadedvcapdischarge(t, vo, C, P)  # set initial cap voltage
-    while (vc >= Vmin):
+    while vc >= Vmin:
         t = t + dt  # increment the time
         vcp = vc  # save previous voltage
         vc = loadedvcapdischarge(t, vo, C, P)  # calc. new voltage
-    if (Eremain):
+    if Eremain:
         E = capenergy(C, vcp)  # calc. energy
-        return (t - dt, E)
+        return t - dt, E
     else:
-        return (t - dt)
+        return t - dt
 
 
 # Define Rectifier Capacitor Calculator
 def rectifiercap(Iload, fswitch, dVout):
     r"""
     Rectifier Capacitor Formula.
 
@@ -306,15 +313,17 @@
 
     Returns
     -------
     C:          float
                 Required capacitance (in Farads) to meet arguments.
     """
     C = Iload / (fswitch * dVout)
-    return (C)
+    return C
+
+
 # Define Inductor Energy Formula
 def inductorenergy(L, I):
     r"""
     Energy Stored in Inductor Formula.
 
     Function to calculate the energy stored in an inductor
     given the inductance (in Henries) and the current.
@@ -329,15 +338,16 @@
                 Current traveling through inductor.
 
     Returns
     -------
     E:          float
                 The energy stored in the inductor (in Joules).
     """
-    return (1 / 2 * L * I ** 2)
+    return 1 / 2 * L * I ** 2
+
 
 def inductorcharge(t, Vs, R, L):
     r"""
     Charging Inductor Formula.
 
     Calculates the Voltage and Current of an inductor
     that is charging/storing energy.
@@ -362,15 +372,16 @@
     Vl:         float
                 Voltage across inductor at time t.
     Il:         float
                 Current through inductor at time t.
     """
     Vl = Vs * _np.exp(-R * t / L)
     Il = Vs / R * (1 - _np.exp(-R * t / L))
-    return (Vl, Il)
+    return Vl, Il
+
 
 # Define Inductor Discharge Function
 def inductordischarge(t, Io, R, L):
     r"""
     Discharging Inductor Formula.
 
     Calculates the Voltage and Current of an inductor
@@ -398,96 +409,106 @@
     Il:         float
                 Current through inductor at time t.
     """
     Il = Io * _np.exp(-R * t / L)
     Vl = Io * R * (1 - _np.exp(-R * t / L))
     return (Vl, Il)
 
-def air_core_inductor(coil_diameter: float, coil_length: float, turns: int):
+
+def air_core_inductance(d: float, coil_l: float, n: int):
     r"""
     Compute Inductance of Air Core Inductor.
 
     Air core inductors that consist of a coil of conducting wire with no core.
     They are used in all sorts of electronic devices like radios and computers.
 
+    .. math:: \frac{d^2 \cdot n^2}{457418\cdot d + 1016127\cdot l}
+
     Parameters
-    ---------- 
-    coil_diameter: float in meters
-    coil_length: float in meters
-    turns: int inductor turns
-
-    Returns 
-    ------- 
-    L: float Inductance of air core inductor in (mH)
-    """
-    k1 = (1000*coil_diameter*coil_diameter) * (turns*turns)
-    k2 = (457418*coil_diameter) + (1016127*coil_length)
-    return  k1/k2
+    ----------
+    d:      float
+            Coil diameter, measured in meters
+    coil_l: float
+            Coil length, measured in meters
+    n:      int
+            Number of inductor turns
+
+    Returns
+    -------
+    float   Inductance of air core inductor in Henry's (H)
+    """
+    k1 = (1000 * d ** 2) * n ** 2
+    k2 = (457418 * d) + (1016127 * coil_l)
+    return k1 / k2
+
 
 def inductive_voltdiv(Vin=None, Vout=None, L1=None, L2=None, find=''):
     r"""
     Inductive voltage divider.
 
-    Inductive voltage divider Inductive voltage dividers are made out of two inductors. 
-    One of the inductors is connected from the input to the output and the other one is connected from the output to ground. 
-    You can also use other components like resistors and inductors.
+    Inductive voltage divider Inductive voltage dividers are made out of two
+    inductors. One of the inductors is connected from the input to the output
+    and the other one is connected from the output to ground. You can also use
+    other components like resistors and inductors.
 
     .. math:: V_{out} = \frac{V_{in}*L1}{L1+L2}
 
     .. image:: /static/inductive-voltage-divider-circuit.png
 
     Parameters
     ----------
-    Vin:    float, optional 
+    Vin:    float, optional
             The input voltage for the system, default=None
 
     Vout:   float, optional
             The output voltage for the system, default=None
 
     L1:     float,optional
             Value of the inductor above the output voltage, default=None
 
     L2:     float,optional
             Value of the inductor below the output voltage, default=None
 
     find:   str, optional
             Control argument to specify which value
             should be returned.
-    
+
     Returns
     -------
-    Vin:    float, optional 
+    Vin:    float, optional
             The input voltage for the system, default=None
 
     Vout:   float, optional
             The output voltage for the system, default=None
 
     L1:     float,optional
             Value of the inductor above the output voltage, default=None
 
     L2:     float,optional
             Value of the inductor below the output voltage
     """
-    if Vin!=None and L1!=None and L2!=None:
-        Vout = (Vin*L1)/(L1+L2)
-    elif Vout!=None and L1!=None and L2!=None:
-        Vin = (Vout)*(L1+L2)/(L1)
-    elif Vin!=None and Vout!=None and L2!=None:
-        L1 = L2*(Vin -Vout)/(Vout)
-    elif Vin!=None and Vout!=None and L1!=None:
-        L2 = L1*(Vout)/(Vin - Vout)
+    if Vin is not None and L1 is not None and L2 is not None:
+        Vout = (Vin * L1) / (L1 + L2)
+    elif Vout is not None and L1 is not None and L2 is not None:
+        Vin = (Vout) * (L1 + L2) / (L1)
+    elif Vin is not None and Vout is not None and L2 is not None:
+        L1 = L2 * (Vin - Vout) / (Vout)
+    elif Vin is not None and Vout is not None and L1 is not None:
+        L2 = L1 * Vout / (Vin - Vout)
     else:
         raise ValueError("ERROR: Invalid Parameters or too few" +
-                        " parameters given to calculate.")
+                         " parameters given to calculate.")
 
     find = find.lower()
-    
+
     if find == 'vin':
         return Vin
     elif find == 'vout':
         return Vout
     elif find == 'l1':
         return L1
     elif find == 'l2':
         return L2
     else:
-        return (Vin, Vout, L1, L2)
+        return Vin, Vout, L1, L2
+
+# END
```

### Comparing `electricpy-0.2.2/electricpy/sim.py` & `electricpy-0.3.0/electricpy/sim.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,61 +1,67 @@
 ################################################################################
 """
-`electricpy.sim`  -  Simulation Module.
+Simulation Module for Filter and System Simulation for Electrical Engineering.
 
 >>> from electricpy import sim
 """
 ################################################################################
 
+from warnings import warn as _warn
+
+import matplotlib.pyplot as _plt
 # Import Required External Dependencies
 import numpy as _np
-import matplotlib.pyplot as _plt
-from numdifftools import Jacobian as jacobian
-from scipy.optimize import newton
 import scipy.signal as _sig
-from warnings import warn as _warn
+from scipy.optimize import newton
+try:
+    from numdifftools import Jacobian as jacobian
+    __NUMDIFFTOOL_SUPPORT__ = True
+except ImportError:
+    __NUMDIFFTOOL_SUPPORT__ = False
 
 # Import Local Dependencies
 from electricpy.bode import _sys_condition
 
+
 # Define Digital Filter Simulator Function
-def digifiltersim(fin,filter,freqs,NN=1000,dt=0.01,title="",
-               legend=True,xlim=False,xmxscale=None,figsize=None):
+def digifiltersim(fin, filter, freqs, NN=1000, dt=0.01, title="",
+                  legend=True, xlim=False, xmxscale=None, figsize=None):
     r"""
     Digital Filter Simulator.
-    
+
     Given an input function and filter parameters (specified in
     the z-domain) this function will plot the input function over
     NN time-steps of an unspecified size (the step-size must be
     specified outside the scope of this function). This function
     will also plot the resultant (output) function over the NN
     time-steps after having been filtered by that filter which
     is specified.
-    
+
     The applied filter should be of the form:
-    
+
     .. math:: \frac{b_0+b_1z^{-1}+b_2z^{-2}}{1-a_1z^{-1}-a_2z^{-2}}
-    
+
     Where each row corresponds to a 1- or 2-pole filter.
-    
+
     Parameters
     ----------
     fin:        function
                 The input function, must be callable with specified
                 step-size.
     filter:     array_like
                 The filter parameter set as shown here:
-                
+
                 .. code-block:: python
-                   
+
                    [[ a11, a12, b10, b11, b12],
                    [ a21, a22, b20, b21, b22],
                    [           ...          ],
                    [ an1, an2, bn0, bn1, bn2]]
-                
+
     freqs:      list of float
                 The set of frequencies to plot the input and output for.
     NN:         int, optional
                 The number of time-steps to be plotted; default=1000
     dt:         float, optional
                 The time-step size; default=0.01
     title:      str, optional
@@ -69,82 +75,87 @@
                 frequency being plotted.
     legend:     str, optional
                 An argument to control whether the legend is shown,
                 default=True.
     figsize:    tuple, optional
                 The figure dimensions for each subplot, default=None
     """
-    if(figsize!=None): _plt.figure(figsize=figsize)
+    if (figsize != None): _plt.figure(figsize=figsize)
     flen = len(freqs)
     for i in range(flen):
         # Gather frequency
         freq = freqs[i]
-        
+
         # Start with arrays set to zero
         x = _np.zeros(NN)
         y = _np.zeros(NN)
-        
+
         # ----- The input  -----
         for k in range(NN):
-            x[k] = fin(k*dt,freq)
-        
+            x[k] = fin(k * dt, freq)
+
         # Identify how many rows were provided
         sz = filter.size
-        if(sz < 5):
-            raise ValueError("ERROR: Too few filter arguments provided. "+
+        if (sz < 5):
+            raise ValueError("ERROR: Too few filter arguments provided. " +
                              "Refer to documentation for proper format.")
-        elif(sz == 5):
+        elif (sz == 5):
             rows = 1
         else:
             rows, cols = filter.shape
         # Operate with each individual filter set
-        x_tmp = _np.copy( x )
+        x_tmp = _np.copy(x)
         nsteps = NN - 4
         for row_n in range(rows):
-            row = filter[row_n] # Capture individual row
+            row = filter[row_n]  # Capture individual row
             A1 = row[0]
             A2 = row[1]
             B0 = row[2]
             B1 = row[3]
             B2 = row[4]
             T = 3
             for _ in range(nsteps):
                 T = T + 1
                 # Apply Filtering Specified by Individual Row
-                y[T] = (A1*y[T-1] + A2*y[T-2] +
-                        B0*x_tmp[T] + B1*x_tmp[T-1] +  B2*x_tmp[T-2])
+                y[T] = (A1 * y[T - 1] + A2 * y[T - 2] +
+                        B0 * x_tmp[T] + B1 * x_tmp[T - 1] + B2 * x_tmp[T - 2])
             # Copy New output into temporary input
-            x_tmp = _np.copy( y )
+            x_tmp = _np.copy(y)
         # Copy finalized output into *ytime* for plotting
-        ytime = _np.copy( x_tmp )
+        ytime = _np.copy(x_tmp)
         # Plot Filtered Output
-        if(flen%2==0): _plt.subplot(flen,2,i+1)
-        else: _plt.subplot(flen,1,i+1)
-        _plt.plot(x,'k--',label="Input")
-        _plt.plot(ytime,'k',label="Output")
+        if (flen % 2 == 0):
+            _plt.subplot(flen, 2, i + 1)
+        else:
+            _plt.subplot(flen, 1, i + 1)
+        _plt.plot(x, 'k--', label="Input")
+        _plt.plot(ytime, 'k', label="Output")
         _plt.title(title)
         _plt.grid(which='both')
-        if legend: _plt.legend(title="Frequency = "+str(freq)+"Hz")
-        if xlim!=False: _plt.xlim(xlim)
-        elif xmxscale!=None: _plt.xlim((0,xmxscale/(freq*dt)))
-        
+        if legend: _plt.legend(title="Frequency = " + str(freq) + "Hz")
+        if xlim != False:
+            _plt.xlim(xlim)
+        elif xmxscale != None:
+            _plt.xlim((0, xmxscale / (freq * dt)))
+
     _plt.tight_layout()
-    _plt.show()
+    return _plt
+
 
 # Define Step Response Simulator Function
-def step_response(system,npts=1000,dt=0.01,combine=True,xlim=False,
-                  title="Step Response",errtitle="Step Response Error",
-                  resplabel="Step Response",funclabel="Step Function",
-                  errlabel="Error",filename=None):
+def step_response(system, npts=1000, dt=0.01, combine=True, xlim=False,
+                  title="Step Response", errtitle="Step Response Error",
+                  resplabel="Step Response", funclabel="Step Function",
+                  errlabel="Error", filename=None):
     """
     Step Function Response Plotter Function.
-    
+
     Given a transfer function, plots the response against step input
     and plots the error for the function.
-    
+
     Parameters
     ----------
     system:     array_like
                 The Transfer Function; can be provided as the following:
                 * 1 (instance of lti)
                 * 2 (num, den)
                 * 3 (zeros, poles, gain)
@@ -165,70 +176,71 @@
                 Limit in x-axis for graph plot. Accepts tuple of: (xmin, xmax).
                 default=False.
     filename:   bool, optional
                 Control argument to specify whether the plotted
                 figures should be saved. default=False
     """
     # Define Time Axis
-    TT = _np.arange(0,npts*dt,dt)
-    
+    TT = _np.arange(0, npts * dt, dt)
+
     # Condition system input to ensure proper execution
-    system = _sys_condition(system,combine)    
-    
+    system = _sys_condition(system, combine)
+
     # Allocate space for all outputs
     step = _np.zeros(npts)
     errS = _np.zeros(npts)
-    
+
     # Generate Inputs
     for i in range(npts):
         step[i] = 1.0
-    
+
     # Simulate Response for each input (step, ramp, parabola)
     # All 'x' values are variables that are considered don't-care
-    x, y1, x = _sig.lsim((system),step,TT)
-    
+    x, y1, x = _sig.lsim((system), step, TT)
+
     # Calculate error over all points
     for k in range(npts):
         errS[k] = step[k] - y1[k]
-    
+
     # Plot Step Response
     _plt.figure()
     _plt.subplot(121)
     _plt.title(title)
-    _plt.plot(TT,y1,'k--', label=resplabel)
-    _plt.plot(TT,step,'k', label=funclabel)
+    _plt.plot(TT, y1, 'k--', label=resplabel)
+    _plt.plot(TT, step, 'k', label=funclabel)
     _plt.grid()
     _plt.legend()
     _plt.xlabel("Time (seconds)")
     if xlim != False:
         _plt.xlim(xlim)
     _plt.subplot(122)
     _plt.title(errtitle)
-    _plt.plot(TT,errS,'k', label=errlabel)
+    _plt.plot(TT, errS, 'k', label=errlabel)
     _plt.grid()
     _plt.legend()
     _plt.xlabel("Time (seconds)")
     if xlim != False:
         _plt.xlim(xlim)
     _plt.subplots_adjust(wspace=0.3)
-    if filename!=None:
+    if filename != None:
         _plt.savefig(filename)
-    _plt.show()
+    return _plt
+
 
 # Define Ramp Response Simulator Function
-def ramp_response(system,npts=1000,dt=0.01,combine=True,xlim=False,
-                  title="Ramp Response",errtitle="Ramp Response Error",
-                  resplabel="Ramp Response",funclabel="Ramp Function",
-                  errlabel="Error",filename=None):
+def ramp_response(system, npts=1000, dt=0.01, combine=True, xlim=False,
+                  title="Ramp Response", errtitle="Ramp Response Error",
+                  resplabel="Ramp Response", funclabel="Ramp Function",
+                  errlabel="Error", filename=None):
     """
     Ramp Function Response Plotter Function.
-    
+
     Given a transfer function, plots the response against step input
     and plots the error for the function.
-    
+
     Parameters
     ----------
     system:     array_like
                 The Transfer Function; can be provided as the following:
                 * 1 (instance of lti)
                 * 2 (num, den)
                 * 3 (zeros, poles, gain)
@@ -245,74 +257,74 @@
     title:      str, optional
                 Additional string to be added to plot titles;
                 default=""
     xlim:       list, optional
                 Limit in x-axis for graph plot. Accepts tuple of: (xmin, xmax).
                 default=False.
     filename:   str, optional
-                File directory/name with which the plotted figures 
+                File directory/name with which the plotted figures
                 should be saved. default=None
     """
     # Define Time Axis
-    TT = _np.arange(0,npts*dt,dt)
-    
+    TT = _np.arange(0, npts * dt, dt)
+
     # Condition system input to ensure proper execution
-    system = _sys_condition(system,combine)
-    
+    system = _sys_condition(system, combine)
+
     # Allocate space for all outputs
     ramp = _np.zeros(npts)
     errR = _np.zeros(npts)
-    
+
     # Generate Inputs
     for i in range(npts):
-        ramp[i] = (dt*i)
-    
+        ramp[i] = (dt * i)
+
     # Simulate Response for each input (step, ramp, parabola)
     # All 'x' values are variables that are considered don't-care
-    x, y2, x = _sig.lsim((system),ramp,TT)
-    
+    x, y2, x = _sig.lsim((system), ramp, TT)
+
     # Calculate error over all points
     for k in range(npts):
         errR[k] = ramp[k] - y2[k]
-    
+
     # Plot Ramp Response
     _plt.figure()
     _plt.subplot(121)
     _plt.title(title)
-    _plt.plot(TT,y2,'k--', label=resplabel)
-    _plt.plot(TT,ramp,'k', label=funclabel)
+    _plt.plot(TT, y2, 'k--', label=resplabel)
+    _plt.plot(TT, ramp, 'k', label=funclabel)
     _plt.grid()
     _plt.legend()
     _plt.xlabel("Time (seconds)")
     if xlim != False:
         _plt.xlim(xlim)
     _plt.subplot(122)
     _plt.title(errtitle)
-    _plt.plot(TT,errR,'k', label=errlabel)
+    _plt.plot(TT, errR, 'k', label=errlabel)
     _plt.grid()
     _plt.legend()
     _plt.xlabel("Time (seconds)")
     if xlim != False:
         _plt.xlim(xlim)
     _plt.subplots_adjust(wspace=0.3)
-    if filename!=None:
+    if filename != None:
         _plt.savefig(filename)
-    _plt.show()
-    
+    return _plt
+
 # Define Parabolic Response Simulator Function
-def parabolic_response(system,npts=1000,dt=0.01,combine=True,xlim=False,
-                  title="Parabolic Response",errtitle="Parabolic Response Error",
-                  resplabel="Parabolic Response",funclabel="Parabolic Function",
-                  errlabel="Error",filename=None):
+def parabolic_response(system, npts=1000, dt=0.01, combine=True, xlim=False,
+                       title="Parabolic Response", errtitle="Parabolic Response Error",
+                       resplabel="Parabolic Response", funclabel="Parabolic Function",
+                       errlabel="Error", filename=None):
     """
     Parabolic Function Response Plotter Function.
-    
+
     Given a transfer function, plots the response against step input
     and plots the error for the function.
-    
+
     Parameters
     ----------
     system:     array_like
                 The Transfer Function; can be provided as the following:
                 * 1 (instance of lti)
                 * 2 (num, den)
                 * 3 (zeros, poles, gain)
@@ -333,63 +345,64 @@
                 Limit in x-axis for graph plot. Accepts tuple of: (xmin, xmax).
                 default=False.
     filename:   bool, optional
                 Control argument to specify whether the plotted
                 figures should be saved. default=False
     """
     # Define Time Axis
-    TT = _np.arange(0,npts*dt,dt)
-    
+    TT = _np.arange(0, npts * dt, dt)
+
     # Condition system input to ensure proper execution
-    system = _sys_condition(system,combine)
-    
+    system = _sys_condition(system, combine)
+
     # Allocate space for all outputs
     parabola = _np.zeros(npts)
     errP = _np.zeros(npts)
-    
+
     # Generate Inputs
     for i in range(npts):
-        parabola[i] = (dt*i)**(2)
-    
+        parabola[i] = (dt * i) ** (2)
+
     # Simulate Response for each input (step, ramp, parabola)
     # All 'x' values are variables that are considered don't-care
-    x, y3, x = _sig.lsim((system),parabola,TT)
-    
+    x, y3, x = _sig.lsim((system), parabola, TT)
+
     # Calculate error over all points
     for k in range(npts):
         errP[k] = parabola[k] - y3[k]
-    
+
     # Plot Parabolic Response
     _plt.figure()
     _plt.subplot(121)
     _plt.title(title)
-    _plt.plot(TT,y3,'k--', label=resplabel)
-    _plt.plot(TT,parabola,'k', label=funclabel)
+    _plt.plot(TT, y3, 'k--', label=resplabel)
+    _plt.plot(TT, parabola, 'k', label=funclabel)
     _plt.grid()
     _plt.legend()
     _plt.xlabel("Time (seconds)")
     if xlim != False:
         _plt.xlim(xlim)
     _plt.subplot(122)
     _plt.title(errtitle)
-    _plt.plot(TT,errP,'k', label=errlabel)
+    _plt.plot(TT, errP, 'k', label=errlabel)
     _plt.grid()
     _plt.legend()
     _plt.xlabel("Time (seconds)")
     if xlim != False:
         _plt.xlim(xlim)
     _plt.subplots_adjust(wspace=0.3)
-    if filename!=None:
+    if filename != None:
         _plt.savefig(filename)
-    _plt.show()
+    return _plt
+
 
 # Define State Space Simulator
-def statespace(A,B,x=None,func=None,C=None,D=None,simpts=9999,NN=10000,dt=0.01,
-               xlim=False,ylim=False,title="",ret=False,plotstate=True,
-               plotforcing=None,plotresult=None,filename=None):
+def statespace(A, B, x=None, func=None, C=None, D=None, simpts=9999, NN=10000, dt=0.01,
+               xlim=False, ylim=False, title="", ret=False, plotstate=True,
+               plotforcing=None, plotresult=None, filename=None):
     """
     State-Space Simulation Plotter.
 
     Parameters
     ----------
     A:          array_like
                 Matrix A of State-Space Formulation
@@ -424,293 +437,294 @@
                 Control value to enable/disable all plotting capabilities.
     plotforcing:bool, optional
                 Control value to enable plotting of the forcing function(s)
     plotresult: bool, optional
                 Control value to enable plotting of the final (combined) result.
 
     **Figures**
-    
+
     Forcing Functions:      The plot of forcing functions, only provided if plotforcing is true.
     State Variables:        The plot of state variables, always provided if plot is true.
     Combined Output:        The plot of the combined terms in the output, provided if C and D are not False.
 
     """
     # Define Initial Condition for Solution
     solution = 3
-    #0=zero-input    ( No Forcing Function )
-    #1=zero-state    ( No Initial Conditions )
-    #2=total         ( Both Initial Conditions and Forcing Function )
-    #3=total, output ( Both ICs and FFs, also plot combined output )
-    
+
+    # 0=zero-input    ( No Forcing Function )
+    # 1=zero-state    ( No Initial Conditions )
+    # 2=total         ( Both Initial Conditions and Forcing Function )
+    # 3=total, output ( Both ICs and FFs, also plot combined output )
+
     # Tuple to Matrix Converter
-    def tuple_to_matrix(x,yx):
-        n = yx(x) # Evaluate function at specified point
-        n = _np.asmatrix(n) # Convert tuple output to matrix
-        n = n.T # Transpose matrix
-        return(n)
+    def tuple_to_matrix(x, yx):
+        n = yx(x)  # Evaluate function at specified point
+        n = _np.asmatrix(n)  # Convert tuple output to matrix
+        n = n.T  # Transpose matrix
+        return (n)
 
     # Numpy Array to Matrix Converter
-    def nparr_to_matrix(x,yx):
-        n = yx(x) # Evaluate function at specified point
-        n = _np.asmatrix(n) # Convert _np.arr output to matrix
-        if n.shape[1] != 1: # If there is more than 1 column
-            n = _np.matrix.reshape(n,(n.size,1)) # Reshape
-        return(n)
-    
+    def nparr_to_matrix(x, yx):
+        n = yx(x)  # Evaluate function at specified point
+        n = _np.asmatrix(n)  # Convert _np.arr output to matrix
+        if n.shape[1] != 1:  # If there is more than 1 column
+            n = _np.matrix.reshape(n, (n.size, 1))  # Reshape
+        return (n)
+
     # Define Function Concatinator Class
     class c_func_concat:
-        def __init__(self,funcs): # Initialize class with tupple of functions
-            self.nfuncs = len(funcs) # Determine how many functions are in tuple
-            self.func_reg = {} # Create empty keyed list of function handles
-            for key in range(self.nfuncs): # Iterate adding to key
-                self.func_reg[key] = funcs[key] # Fill keyed list with functions
+        def __init__(self, funcs):  # Initialize class with tupple of functions
+            self.nfuncs = len(funcs)  # Determine how many functions are in tuple
+            self.func_reg = {}  # Create empty keyed list of function handles
+            for key in range(self.nfuncs):  # Iterate adding to key
+                self.func_reg[key] = funcs[key]  # Fill keyed list with functions
 
-        def func_c(self,x): # Concatenated Function
-            rets = _np.array([]) # Create blank numpy array to store function outputs
+        def func_c(self, x):  # Concatenated Function
+            rets = _np.array([])  # Create blank numpy array to store function outputs
             for i in range(self.nfuncs):
-                y = self.func_reg[i](x) # Calculate each function at value x
-                rets = _np.append(rets, y) # Add value to return array
-            rets = _np.asmatrix(rets).T # Convert array to matrix, then transpose
-            return(rets)
-    
+                y = self.func_reg[i](x)  # Calculate each function at value x
+                rets = _np.append(rets, y)  # Add value to return array
+            rets = _np.asmatrix(rets).T  # Convert array to matrix, then transpose
+            return (rets)
+
     # Condition Inputs
     A = _np.asmatrix(A)
     B = _np.asmatrix(B)
-    
+
     # Define Tuple of Types For Testing
-    typetest = (_np.matrixlib.defmatrix.matrix,_np.ndarray,tuple,list)
-    
+    typetest = (_np.matrixlib.defmatrix.matrix, _np.ndarray, tuple, list)
+
     # Test for NN and simpts
-    if (simpts >= NN):
-        _warn("WARNING: NN must be greater than simpts; NN="+str(NN)+
-             "simpts="+str(simpts)," Autocorrecting simpts to be NN-1.")
-        simpts = NN-1
+    if simpts >= NN:
+        _warn("WARNING: NN must be greater than simpts; NN=" + str(NN) +
+              "simpts=" + str(simpts), " Autocorrecting simpts to be NN-1.")
+        simpts = NN - 1
 
     # Test for C and D matricies
-    if isinstance(C,typetest) and isinstance(D,typetest):
-        solution = 3 # Set to solve and plot complete output
-    elif isinstance(C,typetest) and not isinstance(D,typetest):
-        if (D==None):
+    if isinstance(C, typetest) and isinstance(D, typetest):
+        solution = 3  # Set to solve and plot complete output
+    elif isinstance(C, typetest) and not isinstance(D, typetest):
+        if D is None:
             _warn("WARNING: D matrix not provided; D now assumed to be 0.")
             D = _np.matrix('0')
-            solution = 3 # Set to solve and plot complete output
+            solution = 3  # Set to solve and plot complete output
     else:
         C = _np.matrix('0')
         D = _np.matrix('0')
         solution = 2
-    
+
     # Condition C/D Matrices
     C = _np.asmatrix(C)
     D = _np.asmatrix(D)
 
-
     # Create values for input testing
-    if isinstance(func,function): # if f is a function, test as one
-        mF = func(1) # f should return: int, float, tuple, _np.arr, _np.matrix
-    elif isinstance(func,(tuple,list)): # if f is tupple of arguments
-        if isinstance(func[0], function): #if first argument is a function
-            c_funcs = c_func_concat(func) # concatinate functions into one
-            mF = "MultiFunctions" # label as multiple concatenated functions
+    if callable(func):  # if f is a function, test as one
+        mF = func(1)  # f should return: int, float, tuple, _np.arr, _np.matrix
+    elif isinstance(func, (tuple, list)):  # if f is tupple of arguments
+        if callable(func[0]):  # if first argument is a function
+            c_funcs = c_func_concat(func)  # concatinate functions into one
+            mF = "MultiFunctions"  # label as multiple concatenated functions
         else:
-            mF = "NA" # Can't handle function type
+            mF = "NA"  # Can't handle function type
     else:
-        mF = "NA" # Can't handle function type
+        mF = "NA"  # Can't handle function type
 
     # Test for x input
-    if not isinstance(x,typetest):
-        if x==None: # No specified initial conditions
+    if not isinstance(x, typetest):
+        if x is None:  # No specified initial conditions
             rA = A.shape[0]
             x = _np.asmatrix(_np.zeros(rA)).T
     # Condition x
     x = _np.asmatrix(x)
 
     # Gather dimensions of inputs
     rA, cA = A.shape
     rB, cB = B.shape
     rx, cx = x.shape
     rC, cC = C.shape
     rD, cD = D.shape
-    rF, cF = 1, 1 # Defualt for a function returning one value
+    rF, cF = 1, 1  # Defualt for a function returning one value
 
-    if isinstance(mF,tuple): # If function returns tuple
-        fn = lambda x: tuple_to_matrix(x, func) # Use conversion function
-        rF, cF = fn(1).shape # Prepare for further testing
-    elif isinstance(mF,_np.ndarray): # If function returns numpy array
-        fn = lambda x: nparr_to_matrix(x, func) # Use conversion function
-        rF, cF = fn(1).shape # Prepare for further testing
-    elif isinstance(mF,(int,float,_np.float64)): # If function returns int or float or numpy float
-        fn = func # Pass function handle
-    elif isinstance(mF,_np.matrixlib.defmatrix.matrix): # If function returns matrix
-        fn = func # Pass function handle
-        rF, cF = fn(1).shape # Prepare for further testing
-    elif (mF=="MultiFunctions"): # There are multiple functions in one argument
-        fn = c_funcs.func_c # Gather function handle from function concatenation class
-        rF, cF = fn(1).shape # Prepare for further testing
-    elif (mF=="NA"): # Function doesn't meet requirements
-        raise ValueError("Forcing function does not meet requirements."+
-                        "\nFunction doesn't return data type: int, float, numpy.ndarray"+
-                        "\n or numpy.matrixlib.defmatrix.matrix. Nor does function "+
-                        "\ncontain tuple of function handles. Please review function.")
+    if isinstance(mF, tuple):  # If function returns tuple
+        fn = lambda x: tuple_to_matrix(x, func)  # Use conversion function
+        rF, cF = fn(1).shape  # Prepare for further testing
+    elif isinstance(mF, _np.ndarray):  # If function returns numpy array
+        fn = lambda x: nparr_to_matrix(x, func)  # Use conversion function
+        rF, cF = fn(1).shape  # Prepare for further testing
+    elif isinstance(mF, (int, float, _np.float64)):  # If function returns int or float or numpy float
+        fn = func  # Pass function handle
+    elif isinstance(mF, _np.matrixlib.defmatrix.matrix):  # If function returns matrix
+        fn = func  # Pass function handle
+        rF, cF = fn(1).shape  # Prepare for further testing
+    elif (mF == "MultiFunctions"):  # There are multiple functions in one argument
+        fn = c_funcs.func_c  # Gather function handle from function concatenation class
+        rF, cF = fn(1).shape  # Prepare for further testing
+    elif (mF == "NA"):  # Function doesn't meet requirements
+        raise ValueError("Forcing function does not meet requirements." +
+                         "\nFunction doesn't return data type: int, float, numpy.ndarray" +
+                         "\n or numpy.matrixlib.defmatrix.matrix. Nor does function " +
+                         "\ncontain tuple of function handles. Please review function.")
 
     # Test for size correlation between matricies
-    if (cA != rA): # A isn't nxn matrix
+    if (cA != rA):  # A isn't nxn matrix
         raise ValueError("Matrix 'A' is not NxN matrix.")
-    elif (rA != rB): # A and B matricies don't have same number of rows
-        if (B.size % rA) == 0: # Elements in B divisible by rows in A
+    elif (rA != rB):  # A and B matricies don't have same number of rows
+        if (B.size % rA) == 0:  # Elements in B divisible by rows in A
             _warn("WARNING: Reshaping 'B' matrix to match 'A' matrix.")
-            B = _np.matrix.reshape(B,(rA,int(B.size/rA))) # Reshape Matrix
+            B = _np.matrix.reshape(B, (rA, int(B.size / rA)))  # Reshape Matrix
         else:
             raise ValueError("'A' matrix dimensions don't match 'B' matrix dimensions.")
-    elif (rA != rx): # A and x matricies don't have same number of rows
-        if (x.size % rA) == 0: # Elements in x divisible by rows in A
+    elif (rA != rx):  # A and x matricies don't have same number of rows
+        if (x.size % rA) == 0:  # Elements in x divisible by rows in A
             _warn("WARNING: Reshaping 'x' matrix to match 'A' matrix.")
-            x = _np.matrix.reshape(x,(rA,1)) # Reshape Matrix
+            x = _np.matrix.reshape(x, (rA, 1))  # Reshape Matrix
         else:
             raise ValueError("'A' matrix dimensions don't match 'B' matrix dimensions.")
-    elif (cB != rF) or (cF != 1): # Forcing Function matrix doesn't match B matrix
+    elif (cB != rF) or (cF != 1):  # Forcing Function matrix doesn't match B matrix
         raise ValueError("'B' matrix dimensions don't match forcing function dimensions.")
-    elif (solution==3) and (cC != cA) or (rC != 1): # Number of elements in C don't meet requirements
+    elif (solution == 3) and (cC != cA) or (rC != 1):  # Number of elements in C don't meet requirements
         raise ValueError("'C' matrix dimensions don't match state-space variable dimensions.")
-    elif (solution==3) and ((cD != rF) or (rD != 1)): # Number of elements in D don't meet requirements
-        if (cD == rD) and (cD == 1) and (D[0] == 0): # D matrix is set to [0]
-            D = _np.asmatrix(_np.zeros(rF)) # Re-create D to meet requirements
+    elif (solution == 3) and ((cD != rF) or (rD != 1)):  # Number of elements in D don't meet requirements
+        if (cD == rD) and (cD == 1) and (D[0] == 0):  # D matrix is set to [0]
+            D = _np.asmatrix(_np.zeros(rF))  # Re-create D to meet requirements
             _warn("WARNING: Autogenerating 'D' matrix of zeros to match forcing functions.")
         else:
             raise ValueError("'D' matrix dimensions don't match forcing function dimensions.")
 
     # Test for forcing function
-    if (func==None) and (solution!=0):
-        solution = 0 # Change to Zero-Input calculation
+    if (func is None) and (solution != 0):
+        solution = 0  # Change to Zero-Input calculation
 
     # Start by defining Constants
     T = 0
-    TT = _np.arange(0,(dt*(NN)),dt)
+    TT = _np.arange(0, (dt * (NN)), dt)
     yout = 0
 
     # Define list of strings for plot output
-    soltype = ["(Zero-Input)","(Zero-State)","(Complete Simulation)","(Complete Sim., Combined Output)"]
+    soltype = ["(Zero-Input)", "(Zero-State)", "(Complete Simulation)", "(Complete Sim., Combined Output)"]
 
     # Create a dictionary of state-space variables
     xtim = {}
-    xtim_len = rA # Number of Rows in A matrix
+    xtim_len = rA  # Number of Rows in A matrix
     for n in range(xtim_len):
-        key = n #Each key should be the iterative variable
-        xtim_init = _np.zeros(NN) #Define the initial array
-        xtim[key] = xtim_init #Create each xtim
+        key = n  # Each key should be the iterative variable
+        xtim_init = _np.zeros(NN)  # Define the initial array
+        xtim[key] = xtim_init  # Create each xtim
 
     # Create a dictionary of function outputs
     if (not isinstance(mF, int)) and (not isinstance(mF, float)):
         fn_arr = {}
         for n in range(rF):
-            key = n #Each key should be the iterative variable
-            fn_init = _np.zeros(NN) #Define the initial array
-            fn_arr[key] = fn_init #Create each fn_arr
+            key = n  # Each key should be the iterative variable
+            fn_init = _np.zeros(NN)  # Define the initial array
+            fn_arr[key] = fn_init  # Create each fn_arr
             fnc = rF
     else:
-        fn_arr = _np.zeros(NN) #Create the fn_arr
+        fn_arr = _np.zeros(NN)  # Create the fn_arr
         fnc = 1
 
     # When asked to find zero-state, set all ICs to zero
     if solution == 1:
         for n in range(xtim_len):
-            x[n] = 0 #Set each value to zero
+            x[n] = 0  # Set each value to zero
 
     # Finite-Difference Simulation
-    for i in range(0,simpts):
+    for i in range(0, simpts):
         for n in range(xtim_len):
-            xtim[n][i] = x[n] #xtim[state-variable][domain] = x[state-variable]
+            xtim[n][i] = x[n]  # xtim[state-variable][domain] = x[state-variable]
         # Create Forcing Function output
 
-        if fnc > 1: # More than one forcing function
+        if fnc > 1:  # More than one forcing function
             for n in range(fnc):
                 fn_arr[n][i] = _np.asarray(fn(T))[n][0]
-        else: # only one forcing function
+        else:  # only one forcing function
             fn_arr[i] = fn(T)
 
-        if solution == 0: #Zero-input, no added function input
-            x = x + dt*A*x
-        else: #Zero-state or Total, add function input
-            x = x + dt*A*x + dt*B*fn(T)
-            if solution==3:
-                yout = yout + dt*D*fn(T)
+        if solution == 0:  # Zero-input, no added function input
+            x = x + dt * A * x
+        else:  # Zero-state or Total, add function input
+            x = x + dt * A * x + dt * B * fn(T)
+            if solution == 3:
+                yout = yout + dt * D * fn(T)
 
-        T = T+dt #Add discrete increment to T
+        T = T + dt  # Add discrete increment to T
 
     # Plot Forcing Functions
     if (plotforcing):
         fffig = _plt.figure("Forcing Functions")
         if fnc > 1:
             for x in range(fnc):
-                _plt.plot(TT,fn_arr[x],label="f"+str(x+1))
+                _plt.plot(TT, fn_arr[x], label="f" + str(x + 1))
         else:
-            _plt.plot(TT,fn_arr,label="f1")
-        if xlim!=False:
+            _plt.plot(TT, fn_arr, label="f1")
+        if xlim != False:
             _plt.xlim(xlim)
-        if ylim!=False:
+        if ylim != False:
             _plt.ylim(ylim)
-        _plt.title("Forcing Functions "+title)
+        _plt.title("Forcing Functions " + title)
         _plt.xlabel("Time (seconds)")
         _plt.legend(title="Forcing Functions")
         _plt.grid()
-        if filename!=None:
+        if filename != None:
             _plt.savefig('Simulation Forcing Functions.png')
         if plotstate:
             _plt.show()
 
     # Plot each state-variable over time
     stvfig = _plt.figure("State Variables")
     for x in range(xtim_len):
-        _plt.plot(TT,xtim[x],label="x"+str(x+1))
-    if xlim!=False:
-            _plt.xlim(xlim)
-    if ylim!=False:
+        _plt.plot(TT, xtim[x], label="x" + str(x + 1))
+    if xlim != False:
+        _plt.xlim(xlim)
+    if ylim != False:
         _plt.ylim(ylim)
-    _plt.title("Simulated Output Terms "+soltype[solution]+title)
+    _plt.title("Simulated Output Terms " + soltype[solution] + title)
     _plt.xlabel("Time (seconds)")
     _plt.legend(title="State Variable")
     _plt.grid()
-    if filename!=None:
+    if filename != None:
         _plt.savefig('Simulation Terms.png')
     if plotstate:
         _plt.show()
 
     # Plot combined output
-    if (plotresult and solution==3):
+    if (plotresult and solution == 3):
         cofig = _plt.figure("Combined Output")
-        C = _np.asarray(C) # convert back to array for operation
+        C = _np.asarray(C)  # convert back to array for operation
         for i in range(cC):
-            yout = yout + xtim[i]*C[0][i] # Sum all st-space var mult. by their coeff
-        yout = _np.asarray(yout) # convert output to array for plotting purposes
-        _plt.plot(TT,yout[0])
-        if xlim!=False:
+            yout = yout + xtim[i] * C[0][i]  # Sum all st-space var mult. by their coeff
+        yout = _np.asarray(yout)  # convert output to array for plotting purposes
+        _plt.plot(TT, yout[0])
+        if xlim != False:
             _plt.xlim(xlim)
-        if ylim!=False:
+        if ylim != False:
             _plt.ylim(ylim)
-        _plt.title("Combined Output "+title)
+        _plt.title("Combined Output " + title)
         _plt.xlabel("Time (seconds)")
         _plt.grid()
-        if filename!=None:
+        if filename != None:
             _plt.savefig('Simulation Combined Output.png')
         if plotresult:
             _plt.show()
 
     # Return Variables if asked to
     if ret:
-        return(TT, xtim)
+        return (TT, xtim)
+
 
 # Define Newton-Raphson Calculator
 def NewtonRaphson(F, J, X0, eps=1e-4, mxiter=100, lsq_eps=0.25):
     """
     Newton Raphson Calculator.
-    
+
     Solve nonlinear system F=0 by Newton's method.
     J is the Jacobian of F. Both F and J must be functions of x.
     At input, x holds the start value. The iteration continues
     until ||F|| < eps.
-    
+
     Parameters
     ----------
     F:          array_like
                 The Non-Linear System; a function handle/instance.
                 The input function must accept only one (1) argument as an
                 array or int/float representing the variables required.
     J:          array_like
@@ -723,78 +737,81 @@
                 Epsilon - The error value, default=0.0001
     mxiter:     int, optional
                 Maximum Iterations - The highest number of iterations allowed,
                 default=100
     lsq_eps:    float, optional
                 Least Squares Method (Failover) Epsilon - the error value.
                 default=0.25
-    
+
     Returns
     -------
     X0:                 array_like
                         The computed result
     iteration_counter:  int
                         The number of iterations completed before returning
                         either due to solution being found, or max iterations
                         being surpassed.
-    
+
     Examples
     --------
+    >>> # doctest: +SKIP
     >>> import numpy as np
     >>> from electricpy import sim # Import Simulation Submodule
     >>> def F(x):
-        matr = np.array([[x[1]*10*np.sin(x[0])+2],
-            [x[1]*(-10)*np.cos(x[0])+x[1]**2*10+1]])
-        return(matr)
+    ...     matr = np.array([[x[1]*10*np.sin(x[0])+2],
+    ...         [x[1]*(-10)*np.cos(x[0])+x[1]**2*10+1]])
+    ...     return(matr)
     >>> def J(x):
-        matr = np.array([[10*x[1]*np.cos(x[0]), 10*np.sin(x[0])],
-            [10*x[1]*np.sin(x[0]), -10*np.cos(x[0])+20*x[1]]])
-        return(matr)
-    # Now compute Newton-Raphson
+    ...     matr = np.array([[10*x[1]*np.cos(x[0]), 10*np.sin(x[0])],
+    ...         [10*x[1]*np.sin(x[0]), -10*np.cos(x[0])+20*x[1]]])
+    ...     return(matr)
+    >>> # Now compute Newton-Raphson
     >>> X0 = [0, 1]
     >>> results, iter = sim.NewtonRaphson(F,J,X0)
     >>> print(results)
     [-0.236,0.8554]
     >>> print(iter) # Iteration Counter
     4
-    
+
     See Also
     --------
     nr_pq:              Newton-Raphson System Generator
     mbuspowerflow:      Multi-Bus Power Flow Calculator
-    
+
     """
     # Test for one-variable inputs
-    if isinstance(F(X0),(int,float,_np.float64)): # System is size-1
-        if not isinstance(J(X0),(int,float,_np.float64)): # Jacobian isn't size-1
+    if isinstance(F(X0), (int, float, _np.float64)):  # System is size-1
+        if not isinstance(J(X0), (int, float, _np.float64)):  # Jacobian isn't size-1
             raise ValueError("ERROR: The Jacobian isn't size-1.")
-        return( newton( F, X0, J ) )
-    
+        return newton(F, X0, J)
+
     # Test for valid argument sizes
     f0sz = len(F(X0))
     j0sz = len(J(X0))
-    if(f0sz!=j0sz): # Size mismatch
-        raise ValueError("ERROR: The arguments return arrays or lists"+
-                        " of different sizes: f0="+str(f0sz)+"; j0="+str(j0sz))
+    if f0sz != j0sz:  # Size mismatch
+        raise ValueError("ERROR: The arguments return arrays or lists" +
+                         " of different sizes: f0=" + str(f0sz) + "; j0=" + str(j0sz))
+
     # Define Internal Inversion System
     def inv(m):
         a, b = m.shape
         if a != b:
             raise ValueError("Only square matrices are invertible.")
         i = _np.eye(a, a)
         return _np.linalg.lstsq(m, i, rcond=None)[0]
+
     F_value = F(X0)
     F_norm = _np.linalg.norm(F_value, ord=2)  # L2 norm of vector
     iteration_counter = 0
     teps = eps
     while abs(F_norm) > teps and iteration_counter < mxiter:
-        try: # Try Solve Operation
+        try:  # Try Solve Operation
             delta = _np.linalg.solve(J(X0), -F_value)
-            teps = eps # Change Test Epsilon if Needed
-        except _np.linalg.LinAlgError: # Use Least Square if Error
+            teps = eps  # Change Test Epsilon if Needed
+        except _np.linalg.LinAlgError:  # Use Least Square if Error
             # Warn User, but only Once
             try:
                 tst = userhasbeenwarned
             except NameError:
                 userhasbeenwarned = True
                 _warn("WARNING: Singular matrix, attempting LSQ method.")
             # Calculate Delta Using Least-Squares Inverse
@@ -806,26 +823,27 @@
         F_norm = _np.linalg.norm(F_value, ord=2)
         iteration_counter += 1
 
     # Here, either a solution is found, or too many iterations
     if abs(F_norm) > teps:
         iteration_counter = -1
         _warn("WARNING: Maximum number of iterations exceeded.")
-        _warn("Most recent delta:"+str(delta))
-        _warn("Most recent F-Norm:"+str(F_norm))
-    return(X0, iteration_counter)
+        _warn("Most recent delta:" + str(delta))
+        _warn("Most recent F-Norm:" + str(F_norm))
+    return X0, iteration_counter
+
 
 # Define Newton-Raphson P/Q Evaluator
-def nr_pq(Ybus,V_set,P_set,Q_set,extend=True,argshape=False,verbose=False):
+def nr_pq(Ybus, V_set, P_set, Q_set, extend=True, argshape=False, verbose=False):
     """
     Newton Raphson Real/Reactive Power Function Generator.
-    
+
     Given specified parameters, will generate the necessary real and reactive
     power functions necessary to compute the system's power flow.
-    
+
     Parameters
     ----------
     Ybus:       array_like
                 Postitive Sequence Y-Bus Matrix for Network.
     V_set:      list of list of float
                 List of known and unknown voltages.
                 Known voltages should be provided as
@@ -854,52 +872,53 @@
                 Control argument to force return of the voltage
                 argument array as a tuple of: (Θ-len, V-len).
                 default=False
     verbose:    bool, optional
                 Control argument to print verbose information
                 about function generation, useful for debugging.
                 default=False
-    
+
     Returns
     -------
     retset:     array_like
                 An array of function handles corresponding to
                 the appropriate voltage magnitude and angle
                 calculation functions based on the real and
                 reactive power values. Function(s) will accept
                 an argument of the form:
                 [Θ1, Θ2,..., Θn, V1, V2,..., Vm]
                 where n is the number of busses with unknown
                 voltage angle, and m is the number of busses
                 with unknown voltage magnitude.
-    
+
     Examples
     --------
+    >>> # doctest: +SKIP
     >>> import numpy as np
     >>> from electricpy import sim # Import Simulation Submodule
     >>> ybustest = [[-10j,10j],
-        [10j,-10j]]
+    ...             [10j,-10j]]
     >>> Vlist = [[1,0],[None,None]] # We don't know the voltage or angle at bus 2
     >>> Plist = [None,-2.0] # 2pu watts consumed
     >>> Qlist = [None,-1.0] # 1pu vars consumed
     >>> F = nr_pq(ybustest,Vlist,Plist,Qlist)
     >>> X0 = [0,1] # Define Initial Conditions
     >>> J = sim.jacobian(F) # Find Jacobian
     >>> # Now use Newton-Raphson to Solve
     >>> results, iter = sim.NewtonRaphson(F,J,X0)
     >>> print(results)
     [-0.236,0.8554]
     >>> print(iter) # Iteration Counter
     4
-    
+
     See Also
     --------
     NewtonRaphson:      Newton-Raphson System Solver
     mbuspowerflow:      Multi-Bus Power Flow Calculator
-    
+
     """
     # Condition Inputs
     Ybus = _np.asarray(Ybus)
     row, col = Ybus.shape
     N = row
     # Check Ybus shape
     if row != col:
@@ -907,42 +926,44 @@
     if N != len(V_set):
         raise ValueError("Invalid V_set Shape")
     if N != len(P_set):
         raise ValueError("Invalid P_set Shape")
     if N != len(Q_set):
         raise ValueError("Invalid Q_set Shape")
     for i in range(N):
-        if all((P_set[i],Q_set[i],V_set[i][0])):
+        if all((P_set[i], Q_set[i], V_set[i][0])):
             raise ValueError("Over-Constrained System")
+
     # Define Function Concatinator Class
     class c_func_concat:
-        def __init__(self,funcs): # Initialize class with tupple of functions
-            self.nfuncs = len(funcs) # Determine how many functions are in tuple
-            self.func_reg = {} # Create empty keyed list of function handles
-            for key in range(self.nfuncs): # Iterate adding to key
-                self.func_reg[key] = funcs[key] # Fill keyed list with functions
+        def __init__(self, funcs):  # Initialize class with tupple of functions
+            self.nfuncs = len(funcs)  # Determine how many functions are in tuple
+            self.func_reg = {}  # Create empty keyed list of function handles
+            for key in range(self.nfuncs):  # Iterate adding to key
+                self.func_reg[key] = funcs[key]  # Fill keyed list with functions
 
-        def func_c(self,x): # Concatenated Function
-            rets = _np.array([]) # Create blank numpy array to store function outputs
+        def func_c(self, x):  # Concatenated Function
+            rets = _np.array([])  # Create blank numpy array to store function outputs
             for i in range(self.nfuncs):
-                y = self.func_reg[i](x) # Calculate each function at value x
-                rets = _np.append(rets, y) # Add value to return array
-            return(rets)
+                y = self.func_reg[i](x)  # Calculate each function at value x
+                rets = _np.append(rets, y)  # Add value to return array
+            return rets
+
     # Impliment Global Lists
     global P_funcs, Q_funcs, P_strgs, Q_strgs
     global V_list, YBUS, P_list, Q_list
     global d_list, x_list
     P_funcs = []
     Q_funcs = []
     P_strgs = []
     Q_strgs = []
     Vi_list = []
-    lists = [P_strgs,Q_strgs]
-    i = 0 # Index
-    ii = 0 # String Index
+    lists = [P_strgs, Q_strgs]
+    i = 0  # Index
+    ii = 0  # String Index
     # Load Global Lists
     V_list = V_set
     YBUS = Ybus
     P_list = P_set
     Q_list = Q_set
     # Define Calculation Strings
     ## 0:  Vk magnitude
@@ -960,115 +981,116 @@
     magoff = 1
     angoff = 1
     for _k in range(N):
         Padd = False
         Qadd = False
         for _j in range(N):
             if P_list[_k] == None:
-                continue # Don't Generate Requirements for Slack Bus
-            if (_k != _j) and not Padd: # Skip i,i Terms
+                continue  # Don't Generate Requirements for Slack Bus
+            if (_k != _j) and not Padd:  # Skip i,i Terms
                 ang_len += 1
                 Padd = True
             if (_k != _j) and (Q_list[_k] != None) and not Qadd:
                 mag_len += 1
                 Qadd = True
     Vxdim = ang_len + mag_len
     if verbose:
-        print("Angle EQ's (P):",ang_len,"\tMagnitude EQ's (Q):",mag_len)
-        print("Vx Dimension:",Vxdim)
+        print("Angle EQ's (P):", ang_len, "\tMagnitude EQ's (Q):", mag_len)
+        print("Vx Dimension:", Vxdim)
     # Iteratively Generate P and Q Requirements
     for _k in range(N):
         # Set for New Entry
         newentry = True
         for _j in range(N):
             # Add New Entry To Lists
             for LST in lists:
                 LST.append(None)
             if P_list[_k] == None:
-                continue # Don't Generate Requirements for Slack Bus
+                continue  # Don't Generate Requirements for Slack Bus
             # Collect Other Terms
-            Yind = "[{}][{}]".format(_k,_j)
-            if verbose: print("K:",_k,"\tJ:",_j)
+            Yind = "[{}][{}]".format(_k, _j)
+            if verbose: print("K:", _k, "\tJ:", _j)
             # Generate Voltage-Related Strings
-            if _k != _j: # Skip i,i Terms
+            if _k != _j:  # Skip i,i Terms
                 # Generate K-Related Strings
-                if V_list[_k][0] == None: # The Vk magnitude is unknown
-                    Vkm = "Vx[{}]".format(_k+ang_len-magoff*_k) # Use Variable Magnitude
-                    Vka = "Vx[{}]".format(_k-angoff) # Use Variable Angle
-                else: # The Vk magnitude is known
-                    Vkm = "V_list[{}][0]".format(_k) # Load Magnitude
-                    if V_list[_k][1] == None: # The Vj angle is unknown
-                        Vka = "Vx[{}]".format(_k-angoff) # Use Variable Angle
+                if V_list[_k][0] == None:  # The Vk magnitude is unknown
+                    Vkm = "Vx[{}]".format(_k + ang_len - magoff * _k)  # Use Variable Magnitude
+                    Vka = "Vx[{}]".format(_k - angoff)  # Use Variable Angle
+                else:  # The Vk magnitude is known
+                    Vkm = "V_list[{}][0]".format(_k)  # Load Magnitude
+                    if V_list[_k][1] == None:  # The Vj angle is unknown
+                        Vka = "Vx[{}]".format(_k - angoff)  # Use Variable Angle
                     else:
-                        Vka = "V_list[{}][1]".format(_k) # Load Angle
+                        Vka = "V_list[{}][1]".format(_k)  # Load Angle
                 # Generate J-Related Strings
-                if V_list[_j][0] == None: # The Vj magnitude is unknown
-                    Vjm = "Vx[{}]".format(_j+ang_len-magoff*_j) # Use Variable Magnitude
-                    Vja = "Vx[{}]".format(_j-angoff) # Use Variable Angle
-                else: # The Vj magnitude is known
-                    Vjm = "V_list[{}][0]".format(_j) # Load Magnitude
-                    if V_list[_j][1] == None: # The Vj angle is unknown
-                        Vja = "Vx[{}]".format(_j-angoff) # Use Variable Angle
+                if V_list[_j][0] is None:  # The Vj magnitude is unknown
+                    Vjm = "Vx[{}]".format(_j + ang_len - magoff * _j)  # Use Variable Magnitude
+                    Vja = "Vx[{}]".format(_j - angoff)  # Use Variable Angle
+                else:  # The Vj magnitude is known
+                    Vjm = "V_list[{}][0]".format(_j)  # Load Magnitude
+                    if V_list[_j][1] is None:  # The Vj angle is unknown
+                        Vja = "Vx[{}]".format(_j - angoff)  # Use Variable Angle
                     else:
-                        Vja = "V_list[{}][1]".format(_j) # Load Angle
+                        Vja = "V_list[{}][1]".format(_j)  # Load Angle
                 # Generate String and Append to List of Functions
-                P_strgs[i] = ( Pstr.format(Vkm,Vka,Vjm,Vja,Yind) ) 
-                if verbose: print("New P-String:",P_strgs[i])
+                P_strgs[i] = (Pstr.format(Vkm, Vka, Vjm, Vja, Yind))
+                if verbose: print("New P-String:", P_strgs[i])
                 # Generate Q Requirement
-                if Q_list[_k] != None:
-                   # Generate String and Append to List of Functions
+                if Q_list[_k] is not None:
+                    # Generate String and Append to List of Functions
                     if newentry:
                         newentry = False
                         Qgen = "-Vx[{0}]**2*YBUS[{0}][{0}].imag".format(_k)
                     else:
                         Qgen = ""
-                    Q_strgs[i] = ( Qstr.format(Vkm,Vka,Vjm,Vja,Yind,Qgen) )
-                    if verbose: print("New Q-String:",Q_strgs[i])
+                    Q_strgs[i] = (Qstr.format(Vkm, Vka, Vjm, Vja, Yind, Qgen))
+                    if verbose: print("New Q-String:", Q_strgs[i])
             # Increment Index at Each Interior Level
             i += 1
         tempPstr = "P_funcs.append(lambda Vx: -P_list[{0}]".format(_k)
         tempQstr = "Q_funcs.append(lambda Vx: -Q_list[{0}]".format(_k)
-        for _i in range(ii,i):
+        for _i in range(ii, i):
             P = P_strgs[_i]
             Q = Q_strgs[_i]
-            if P != None:
-                tempPstr += "+"+P
-            if Q != None:
-                tempQstr += "+"+Q
+            if P is not None:
+                tempPstr += "+" + P
+            if Q is not None:
+                tempQstr += "+" + Q
         tempPstr += ")"
         tempQstr += ")"
         if any(P_strgs[ii:i]):
-            if verbose: print("Full P-Func Str:",tempPstr)
+            if verbose: print("Full P-Func Str:", tempPstr)
             exec(tempPstr)
         if any(Q_strgs[ii:i]):
-            if verbose: print("Full Q-Func Str:",tempQstr)
+            if verbose: print("Full Q-Func Str:", tempQstr)
             exec(tempQstr)
-        ii = i # Increase Lower Index
-    retset = (P_funcs,Q_funcs)
+        ii = i  # Increase Lower Index
+    retset = (P_funcs, Q_funcs)
     if extend:
         funcset = P_funcs.copy()
         funcset.extend(Q_funcs)
         funcgroup = c_func_concat(funcset)
         retset = funcgroup.func_c
     if argshape:
-        retset = (retset,(ang_len,mag_len))
-    return(retset)
+        retset = (retset, (ang_len, mag_len))
+    return retset
+
 
 # Define Multi-Bus Power Flow Calculator
-def mbuspowerflow(Ybus,Vknown,Pknown,Qknown,X0='flatstart',eps=1e-4,
-                  mxiter=100,returnct=False,degrees=True,split=False,
-                  slackbus=0,lsq_eps=0.25):
+def mbuspowerflow(Ybus, Vknown, Pknown, Qknown, X0='flatstart', eps=1e-4,
+                  mxiter=100, returnct=False, degrees=True, split=False,
+                  slackbus=0, lsq_eps=0.25):
     """
     Multi-Bus Power Flow Calculator.
-    
+
     Function wrapper to simplify the evaluation of a power flow calculation.
     Determines the function array (F) and the Jacobian array (J) and uses the
     Newton-Raphson method to iteratively evaluate the system to converge to a
     solution.
-    
+
     Parameters
     ----------
     Ybus:       array_like
                 Postitive Sequence Y-Bus Matrix for Network.
     Vknown:     list of list of float
                 List of known and unknown voltages.
                 Known voltages should be provided as
@@ -1121,64 +1143,79 @@
                 used to reformat the data sets to a format
                 necessary for proper generation and Newton
                 Raphson computation. Must be zero-based.
                 default=0
     lsq_eps:    float, optional
                 Least Squares Method (Failover) Epsilon - the error value.
                 default=0.25
-    
-    
+
+
     .. image:: /static/mbuspowerflow_example.png
-    
+
     Examples
     --------
+    >>> # doctest: +SKIP
     >>> # Perform Power-Flow Analysis for Figure
     >>> import numpy as np
     >>> from electricpy import sim # Import Simulation Submodule
     >>> ybustest = [[-10j,10j],
-        [10j,-10j]]
+    ...             [10j,-10j]]
     >>> Vlist = [[1,0],[None,None]] # We don't know the voltage or angle at bus 2
     >>> Plist = [None,-2.0] # 2pu watts consumed
     >>> Qlist = [None,-1.0] # 1pu vars consumed
-    >>> nr_res = sim.mbuspowerflow(ybustest,Vlist,Plist,Qlist,degrees=True,split=True,returnct=True)
-    >>> print(nr_res)
+    >>> sim.mbuspowerflow(
+    ...     ybustest,
+    ...     Vlist,
+    ...     Plist,
+    ...     Qlist,
+    ...     degrees=True,
+    ...     split=True,
+    ...     returnct=True
+    ... )
     ([array([-13.52185223]), array([ 0.85537271])], 4)
-    
+
     See Also
     --------
     NewtonRaphson:          Newton-Raphson System Solver
     nr_pq:                  Newton-Raphson System Generator
     electricpy.powerflow:   Simple (2-bus) Power Flow Calculator
     """
+    # Identify Lack of Support
+    if not __NUMDIFFTOOL_SUPPORT__:
+        raise ImportError(
+            "(!)  Cannot perform request due to lack of installed package: "
+            "`numdifftools` which may be obtained with: `pip install "
+            "numdifftools`."
+        )
     # Reformat Inputs to Meet Criteria
     if slackbus != 0:
         # Ybus
         Ybus = _np.asarray(Ybus)
         row, col = Ybus.shape
-        Ybus = _np.roll(Ybus,(col-slackbus),(0,1))
+        Ybus = _np.roll(Ybus, (col - slackbus), (0, 1))
         # Vknown, Pknown, and Qknown
-        Vknown = _np.roll(Vknown,(len(Vknown)-slackbus),0).tolist()
-        Pknown = _np.roll(Pknown,(len(Pknown)-slackbus),0).tolist()
-        Qknown = _np.roll(Qknown,(len(Qknown)-slackbus),0).tolist()
+        Vknown = _np.roll(Vknown, (len(Vknown) - slackbus), 0).tolist()
+        Pknown = _np.roll(Pknown, (len(Pknown) - slackbus), 0).tolist()
+        Qknown = _np.roll(Qknown, (len(Qknown) - slackbus), 0).tolist()
     # Generate F Function Array
-    F, shp = nr_pq(Ybus,Vknown,Pknown,Qknown,True,True,False)
+    F, shp = nr_pq(Ybus, Vknown, Pknown, Qknown, True, True, False)
     # Handle Flat-Start Condition
     if X0 == 'flatstart':
         ang_len, mag_len = shp
-        X0 = _np.append(_np.zeros(ang_len),_np.ones(mag_len))
+        X0 = _np.append(_np.zeros(ang_len), _np.ones(mag_len))
     # Evaluate Jacobian
     J = jacobian(F)
     # Compute Newton-Raphson
-    nr_result, iter_count = NewtonRaphson(F,J,X0,eps,mxiter,lsq_eps)
+    nr_result, iter_count = NewtonRaphson(F, J, X0, eps, mxiter, lsq_eps)
     # Convert to Degrees if Necessary
     if degrees:
         for i in range(ang_len):
             nr_result[i] = _np.degrees(nr_result[i])
     # Split into Mag/Ang Arrays if Necessary
     if split:
-        nr_result = [nr_result[:ang_len],nr_result[-mag_len:]]
+        nr_result = [nr_result[:ang_len], nr_result[-mag_len:]]
     # Return with Iteration Counter
     if returnct:
-        return(nr_result, iter_count)
-    return(nr_result)
+        return nr_result, iter_count
+    return nr_result
 
-# END OF FILE
+# END OF FILE
```

